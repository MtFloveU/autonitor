### FILE: ./code.txt


### FILE: ./core/data_processor.dart
import 'dart:convert';
import 'package:async/async.dart';
import 'package:drift/drift.dart';
import '../models/account.dart';
import '../services/database.dart';
import '../services/twitter_api_service.dart';
import '../services/twitter_api_v1_service.dart';
import '../utils/diff_utils.dart';
import 'package:async_locks/async_locks.dart';

typedef LogCallback = void Function(String message);

class DataProcessor {
  final AppDatabase _database;
  final TwitterApiService _apiServiceGql;
  final TwitterApiV1Service _apiServiceV1;
  final String _ownerId;
  final String _ownerCookie;
  final LogCallback _log;

  DataProcessor({
    required AppDatabase database,
    required TwitterApiService apiServiceGql,
    required TwitterApiV1Service apiServiceV1,
    required Account ownerAccount,
    required LogCallback logCallback,
  }) : _database = database,
       _apiServiceGql = apiServiceGql,
       _apiServiceV1 = apiServiceV1,
       _ownerId = ownerAccount.id,
       _ownerCookie = ownerAccount.cookie,
       _log = logCallback;

  Future<void> runFullProcess() async {
    _log("Starting analysis process for account ID: $_ownerId...");

    try {
      _log("Fetching old relationships from database...");
      final List<FollowUser> oldRelationsList = await _database
          .getNetworkRelationships(_ownerId);
      final Map<String, FollowUser> oldRelationsMap = {
        for (var relation in oldRelationsList) relation.userId: relation,
      };
      _log("Found ${oldRelationsMap.length} existing relationships.");

      _log("Fetching new followers list from API...");
      final Map<String, Map<String, dynamic>> newUserJsons = {};
      final Set<String> newFollowerIds = {};
      final Set<String> newFollowingIds = {};

      String? nextFollowerCursor;
      do {
        final followerResult = await _apiServiceV1.getFollowers(
          _ownerId,
          _ownerCookie,
          cursor: nextFollowerCursor,
        );
        for (var userJson in followerResult.users) {
          final userId =
              userJson['id_str'] as String? ?? userJson['id']?.toString();
          if (userId != null) {
            newUserJsons[userId] = Map<String, dynamic>.from(userJson);
            newFollowerIds.add(userId);
          }
        }
        nextFollowerCursor = followerResult.nextCursor;
        _log(
          "Fetched ${followerResult.users.length} followers, next cursor: $nextFollowerCursor",
        );
      } while (nextFollowerCursor != null &&
          nextFollowerCursor != '0' &&
          nextFollowerCursor.isNotEmpty);

      _log(
        "Finished fetching followers. Total unique users so far: ${newUserJsons.length}",
      );
      _log("Fetching new following list from API...");

      String? nextFollowingCursor;
      do {
        final followingResult = await _apiServiceV1.getFollowing(
          _ownerId,
          _ownerCookie,
          cursor: nextFollowingCursor,
        );
        for (var userJson in followingResult.users) {
          final userId =
              userJson['id_str'] as String? ?? userJson['id']?.toString();
          if (userId != null) {
            newFollowingIds.add(userId);
            if (!newUserJsons.containsKey(userId)) {
              newUserJsons[userId] = Map<String, dynamic>.from(userJson);
            }
          }
        }
        nextFollowingCursor = followingResult.nextCursor;
        _log(
          "Fetched ${followingResult.users.length} following, next cursor: $nextFollowingCursor",
        );
      } while (nextFollowingCursor != null &&
          nextFollowingCursor != '0' &&
          nextFollowingCursor.isNotEmpty);

      _log(
        "Finished fetching following. Total unique users in combined list: ${newUserJsons.length}",
      );

      final Set<String> newIds = newUserJsons.keys.toSet();
      final Set<String> oldIds = oldRelationsMap.keys.toSet();
      final Set<String> addedIds = newIds.difference(oldIds);
      final Set<String> removedIds = oldIds.difference(newIds);
      final Set<String> keptIds = newIds.intersection(oldIds);
      _log(
        "Calculated differences: ${addedIds.length} added, ${removedIds.length} removed, ${keptIds.length} kept.",
      );

      _log(
        "Processing ${removedIds.length} removed users to determine status...",
      );
      final Map<String, String> categorizedRemovals = {};
      if (removedIds.isNotEmpty) {
        final semaphore = Semaphore(5);
        final group = FutureGroup<void>();
        for (final removedId in removedIds) {
          group.add(
            Future(() async {
              await semaphore.acquire();
              String category = 'unknown_error';
              try {
                final Map<String, dynamic> gqlJson = await _apiServiceGql
                    .getUserByRestId(removedId, _ownerCookie);
                final result = gqlJson['data']?['user']?['result'];
                final typename = result?['__typename'];

                if (typename == 'User') {
                  final legacy = result?['legacy'];
                  final interstitial =
                      legacy?['profile_interstitial_type'] as String?;
                  if (interstitial != null && interstitial.isNotEmpty) {
                    category = 'temporarily_restricted';
                  } else {
                    // --- Final Removed Logic ---
                    final oldRel = oldRelationsMap[removedId];
                    final wasFollower = oldRel?.isFollower ?? false;
                    final wasFollowing = oldRel?.isFollowing ?? false;

                    if (wasFollower && wasFollowing)
                      category = 'mutual_unfollowed'; // Old: Mutual -> Gone
                    else if (wasFollower)
                      category =
                          'normal_unfollowed'; // Old: They Followed -> Gone (They unfollowed)
                    else if (wasFollowing)
                      category =
                          'normal_unfollowed'; // Old: You Followed -> Gone (You unfollowed) <-- CHANGE
                    else
                      category = 'unknown_removed_state';
                    // --- Final End ---
                  }
                } else if (typename == 'UserUnavailable') {
                  category = 'suspended';
                } else if (gqlJson['data']?['user'] == null ||
                    (gqlJson['data']?['user'] is Map &&
                        gqlJson['data']['user'].isEmpty)) {
                  category = 'deactivated';
                } else {
                  _log(
                    "Warning: Unexpected GraphQL response for $removedId: $gqlJson",
                  );
                  category = 'unknown_gql_response';
                }
              } catch (e) {
                _log("Error fetching GraphQL for removed user $removedId: $e");
                category = 'unknown_error';
              } finally {
                categorizedRemovals[removedId] = category;
                semaphore.release();
              }
            }),
          );
        }
        group.close();
        await group.future;
        _log("Finished processing removed users.");
      }

      _log("Calculating profile diffs for ${keptIds.length} kept users...");
      final List<FollowUsersHistoryCompanion> historyToInsert = [];
      for (final keptId in keptIds) {
        final newJsonMap = newUserJsons[keptId];
        final oldJsonString = oldRelationsMap[keptId]?.latestRawJson;
        final newJsonString = newJsonMap != null
            ? jsonEncode(newJsonMap)
            : null;
        final diffString = calculateReverseDiff(newJsonString, oldJsonString);
        if (diffString != null && diffString.isNotEmpty) {
          historyToInsert.add(
            FollowUsersHistoryCompanion(
              ownerId: Value(_ownerId),
              userId: Value(keptId),
              reverseDiffJson: Value(diffString),
              timestamp: Value(DateTime.now()),
            ),
          );
        }
      }
      _log("Found ${historyToInsert.length} profile changes among kept users.");

      _log("Preparing data for database update...");
      final List<FollowUsersCompanion> companionsToUpsert = [];
      for (final userId in newIds) {
        final userJson = newUserJsons[userId]!;
        companionsToUpsert.add(
          FollowUsersCompanion(
            ownerId: Value(_ownerId),
            userId: Value(userId),
            name: Value(userJson['name'] as String?),
            screenName: Value(userJson['screen_name'] as String?),
            avatarUrl: Value(userJson['profile_image_url_https'] as String?),
            bio: Value(userJson['description'] as String?),
            latestRawJson: Value(jsonEncode(userJson)),
            isFollower: Value(newFollowerIds.contains(userId)),
            isFollowing: Value(newFollowingIds.contains(userId)),
            avatarLocalPath: const Value.absent(),
          ),
        );
      }

      final List<ChangeReportsCompanion> reportCompanions = [];
      final now = DateTime.now();

      // --- Final Added Logic ---
      for (final addedId in addedIds) {
        reportCompanions.add(
          ChangeReportsCompanion(
            ownerId: Value(_ownerId),
            userId: Value(addedId),
            changeType: Value(
              'new_followers_following',
            ), // <-- Unified type for all added
            timestamp: Value(now),
          ),
        );
      }
      // --- Final End ---

      // Removals (using categorized results from above)
      categorizedRemovals.forEach((userId, categoryKey) {
        reportCompanions.add(
          ChangeReportsCompanion(
            ownerId: Value(_ownerId),
            userId: Value(userId),
            changeType: Value(categoryKey),
            timestamp: Value(now),
          ),
        );
      });

      // --- Final Kept Logic for state changes ---
      for (final keptId in keptIds) {
        final oldRel = oldRelationsMap[keptId];
        final wasFollower = oldRel?.isFollower ?? false;
        final wasFollowing = oldRel?.isFollowing ?? false;
        final isNowFollower = newFollowerIds.contains(keptId);
        final isNowFollowing = newFollowingIds.contains(keptId);

        // Check for 'be_followed_back'
        if (!wasFollower && wasFollowing && isNowFollower && isNowFollowing) {
          // Old: You followed only -> New: Mutual
          reportCompanions.add(
            ChangeReportsCompanion(
              ownerId: Value(_ownerId),
              userId: Value(keptId),
              changeType: Value('be_followed_back'),
              timestamp: Value(now),
            ),
          );
        }
        // Check for 'oneway_unfollowed' (Mutual -> Single)
        else if (wasFollower &&
            wasFollowing &&
            isNowFollower &&
            !isNowFollowing) {
          // Old: Mutual -> New: They follow only (You unfollowed)
          reportCompanions.add(
            ChangeReportsCompanion(
              ownerId: Value(_ownerId),
              userId: Value(keptId),
              changeType: Value('oneway_unfollowed'),
              timestamp: Value(now),
            ),
          );
        } else if (wasFollower &&
            wasFollowing &&
            !isNowFollower &&
            isNowFollowing) {
          // Old: Mutual -> New: You follow only (They unfollowed)
          reportCompanions.add(
            ChangeReportsCompanion(
              ownerId: Value(_ownerId),
              userId: Value(keptId),
              changeType: Value('oneway_unfollowed'),
              timestamp: Value(now),
            ),
          );
        }
        // Add other state change detections here if needed (e.g., normal_unfollowed for kept users?)
      }
      // --- Final End ---

      _log("Writing changes to database...");
      await _database.transaction(() async {
        if (removedIds.isNotEmpty) {
          await _database.deleteNetworkRelationships(
            _ownerId,
            removedIds.toList(),
          );
          _log(
            "Deleted ${removedIds.length} relationships from NetworkRelationships.",
          );
        }
        if (companionsToUpsert.isNotEmpty) {
          await _database.batchUpsertNetworkRelationships(companionsToUpsert);
          _log(
            "Upserted ${companionsToUpsert.length} relationships into NetworkRelationships.",
          );
        }
        if (historyToInsert.isNotEmpty) {
          await _database.batchInsertFollowUsersHistory(historyToInsert);
          _log("Inserted ${historyToInsert.length} profile history records.");
        }
        await _database.replaceChangeReport(_ownerId, reportCompanions);
        _log(
          "Replaced ChangeReport with ${reportCompanions.length} new entries.",
        );
      });

      _log(
        "Analysis process completed successfully for account ID: $_ownerId.",
      );
    } catch (e, s) {
      _log(
        "!!! CRITICAL ERROR during analysis process for account ID: $_ownerId: $e",
      );
      _log("Stacktrace: $s");
      rethrow;
    }
  }
}


### FILE: ./l10n/app_en.arb
{
  "@@locale": "en",
  "language": "Language",
  "@language": {
    "description": "Label for the language setting"
  },
  "app_title": "Autonitor",
  "settings": "Settings",
  "home": "Home",
  "data": "Data",
  "accounts": "Accounts",
  "switchAccount": "Switch Account",
  "followers": "Followers",
  "following": "Following",
  "new_account": "Add a new account",
  "view_cookie": "View Cookie",
  "close": "Close",
  "view_on_twitter": "View on Twitter",
  "metadata": "Metadata",
  "tweets": "Tweets",
  "media_count": "Media Count",
  "likes": "Likes",
  "listed_count": "Listed Count",
  "identity": "Identity-related",
  "back": "Back",
  "history": "History",
  "suspended": "Suspended",
  "deactivated": "Deactivated",
  "normal_unfollowed": "Normal Unfollowed",
  "be_followed_back": "Be Followed Back",
  "mutual_unfollowed": "Mutual Unfollowed",
  "oneway_unfollowed": "One-way Unfollowed",
  "new_followers_following": "New Followers & Following",
  "empty_list_message": "The list is empty",
  "switch_account": "Switch Account",
  "run": "Run",
  "choose_login_method": "Choose Login Method",
  "browser_login": "Login via Browser",
  "manual_cookie": "Manual Cookie Input",
  "joined": "Joined",
  "im_logged_in": "I've logged in",
  "cancel": "Cancel",
  "ok": "OK",
  "account_added_successfully": "Account added successfully!",
  "saving_account": "Saving account...",
  "cookie": "Cookie",
  "no_cookie_found": "No cookie found",
  "no_auth_token_found": "No auth_token found",
  "found_auth_token_last_check": "Auth Token found in last check",
  "general": "General",
  "login_first": "Log in Needed",
  "login_first_description": "Add at least one account to continue",
  "log_in": "Log In",
  "delete": "Delete",
  "confirm_delete_account": "Are you sure you want to delete account {accountId}? This action cannot be undone. Deleting an account will permanently remove all its associated data (history, follower/following lists etc.). If you only want to update the cookie, simply add the account again.",
  "@confirm_delete_account": {
    "placeholders": {
      "accountId": {
        "description": "The ID of the account to be deleted"
      }
    }
  },
  "copy": "Copy",
  "copied_to_clipboard": "Copied to clipboard!",
  "no_json_data_available": "No JSON data available"
}

### FILE: ./l10n/app_localizations.dart
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_en.dart';
import 'app_localizations_zh.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'l10n/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, you’ll need to edit this
/// file.
///
/// First, open your project’s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// project’s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
abstract class AppLocalizations {
  AppLocalizations(String locale)
    : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates =
      <LocalizationsDelegate<dynamic>>[
        delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
      ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('en'),
    Locale('zh'),
    Locale('zh', 'TW'),
  ];

  /// Label for the language setting
  ///
  /// In en, this message translates to:
  /// **'Language'**
  String get language;

  /// No description provided for @app_title.
  ///
  /// In en, this message translates to:
  /// **'Autonitor'**
  String get app_title;

  /// No description provided for @settings.
  ///
  /// In en, this message translates to:
  /// **'Settings'**
  String get settings;

  /// No description provided for @home.
  ///
  /// In en, this message translates to:
  /// **'Home'**
  String get home;

  /// No description provided for @data.
  ///
  /// In en, this message translates to:
  /// **'Data'**
  String get data;

  /// No description provided for @accounts.
  ///
  /// In en, this message translates to:
  /// **'Accounts'**
  String get accounts;

  /// No description provided for @switchAccount.
  ///
  /// In en, this message translates to:
  /// **'Switch Account'**
  String get switchAccount;

  /// No description provided for @followers.
  ///
  /// In en, this message translates to:
  /// **'Followers'**
  String get followers;

  /// No description provided for @following.
  ///
  /// In en, this message translates to:
  /// **'Following'**
  String get following;

  /// No description provided for @new_account.
  ///
  /// In en, this message translates to:
  /// **'Add a new account'**
  String get new_account;

  /// No description provided for @view_cookie.
  ///
  /// In en, this message translates to:
  /// **'View Cookie'**
  String get view_cookie;

  /// No description provided for @close.
  ///
  /// In en, this message translates to:
  /// **'Close'**
  String get close;

  /// No description provided for @view_on_twitter.
  ///
  /// In en, this message translates to:
  /// **'View on Twitter'**
  String get view_on_twitter;

  /// No description provided for @metadata.
  ///
  /// In en, this message translates to:
  /// **'Metadata'**
  String get metadata;

  /// No description provided for @tweets.
  ///
  /// In en, this message translates to:
  /// **'Tweets'**
  String get tweets;

  /// No description provided for @media_count.
  ///
  /// In en, this message translates to:
  /// **'Media Count'**
  String get media_count;

  /// No description provided for @likes.
  ///
  /// In en, this message translates to:
  /// **'Likes'**
  String get likes;

  /// No description provided for @listed_count.
  ///
  /// In en, this message translates to:
  /// **'Listed Count'**
  String get listed_count;

  /// No description provided for @identity.
  ///
  /// In en, this message translates to:
  /// **'Identity-related'**
  String get identity;

  /// No description provided for @back.
  ///
  /// In en, this message translates to:
  /// **'Back'**
  String get back;

  /// No description provided for @history.
  ///
  /// In en, this message translates to:
  /// **'History'**
  String get history;

  /// No description provided for @suspended.
  ///
  /// In en, this message translates to:
  /// **'Suspended'**
  String get suspended;

  /// No description provided for @deactivated.
  ///
  /// In en, this message translates to:
  /// **'Deactivated'**
  String get deactivated;

  /// No description provided for @normal_unfollowed.
  ///
  /// In en, this message translates to:
  /// **'Normal Unfollowed'**
  String get normal_unfollowed;

  /// No description provided for @be_followed_back.
  ///
  /// In en, this message translates to:
  /// **'Be Followed Back'**
  String get be_followed_back;

  /// No description provided for @mutual_unfollowed.
  ///
  /// In en, this message translates to:
  /// **'Mutual Unfollowed'**
  String get mutual_unfollowed;

  /// No description provided for @oneway_unfollowed.
  ///
  /// In en, this message translates to:
  /// **'One-way Unfollowed'**
  String get oneway_unfollowed;

  /// No description provided for @new_followers_following.
  ///
  /// In en, this message translates to:
  /// **'New Followers & Following'**
  String get new_followers_following;

  /// No description provided for @empty_list_message.
  ///
  /// In en, this message translates to:
  /// **'The list is empty'**
  String get empty_list_message;

  /// No description provided for @switch_account.
  ///
  /// In en, this message translates to:
  /// **'Switch Account'**
  String get switch_account;

  /// No description provided for @run.
  ///
  /// In en, this message translates to:
  /// **'Run'**
  String get run;

  /// No description provided for @choose_login_method.
  ///
  /// In en, this message translates to:
  /// **'Choose Login Method'**
  String get choose_login_method;

  /// No description provided for @browser_login.
  ///
  /// In en, this message translates to:
  /// **'Login via Browser'**
  String get browser_login;

  /// No description provided for @manual_cookie.
  ///
  /// In en, this message translates to:
  /// **'Manual Cookie Input'**
  String get manual_cookie;

  /// No description provided for @joined.
  ///
  /// In en, this message translates to:
  /// **'Joined'**
  String get joined;

  /// No description provided for @im_logged_in.
  ///
  /// In en, this message translates to:
  /// **'I\'ve logged in'**
  String get im_logged_in;

  /// No description provided for @cancel.
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get cancel;

  /// No description provided for @ok.
  ///
  /// In en, this message translates to:
  /// **'OK'**
  String get ok;

  /// No description provided for @account_added_successfully.
  ///
  /// In en, this message translates to:
  /// **'Account added successfully!'**
  String get account_added_successfully;

  /// No description provided for @saving_account.
  ///
  /// In en, this message translates to:
  /// **'Saving account...'**
  String get saving_account;

  /// No description provided for @cookie.
  ///
  /// In en, this message translates to:
  /// **'Cookie'**
  String get cookie;

  /// No description provided for @no_cookie_found.
  ///
  /// In en, this message translates to:
  /// **'No cookie found'**
  String get no_cookie_found;

  /// No description provided for @no_auth_token_found.
  ///
  /// In en, this message translates to:
  /// **'No auth_token found'**
  String get no_auth_token_found;

  /// No description provided for @found_auth_token_last_check.
  ///
  /// In en, this message translates to:
  /// **'Auth Token found in last check'**
  String get found_auth_token_last_check;

  /// No description provided for @general.
  ///
  /// In en, this message translates to:
  /// **'General'**
  String get general;

  /// No description provided for @login_first.
  ///
  /// In en, this message translates to:
  /// **'Log in Needed'**
  String get login_first;

  /// No description provided for @login_first_description.
  ///
  /// In en, this message translates to:
  /// **'Add at least one account to continue'**
  String get login_first_description;

  /// No description provided for @log_in.
  ///
  /// In en, this message translates to:
  /// **'Log In'**
  String get log_in;

  /// No description provided for @delete.
  ///
  /// In en, this message translates to:
  /// **'Delete'**
  String get delete;

  /// No description provided for @confirm_delete_account.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to delete account {accountId}? This action cannot be undone. Deleting an account will permanently remove all its associated data (history, follower/following lists etc.). If you only want to update the cookie, simply add the account again.'**
  String confirm_delete_account(Object accountId);

  /// No description provided for @copy.
  ///
  /// In en, this message translates to:
  /// **'Copy'**
  String get copy;

  /// No description provided for @copied_to_clipboard.
  ///
  /// In en, this message translates to:
  /// **'Copied to clipboard!'**
  String get copied_to_clipboard;

  /// No description provided for @no_json_data_available.
  ///
  /// In en, this message translates to:
  /// **'No JSON data available'**
  String get no_json_data_available;
}

class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) =>
      <String>['en', 'zh'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {
  // Lookup logic when language+country codes are specified.
  switch (locale.languageCode) {
    case 'zh':
      {
        switch (locale.countryCode) {
          case 'TW':
            return AppLocalizationsZhTw();
        }
        break;
      }
  }

  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'en':
      return AppLocalizationsEn();
    case 'zh':
      return AppLocalizationsZh();
  }

  throw FlutterError(
    'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
    'an issue with the localizations generation tool. Please file an issue '
    'on GitHub with a reproducible sample app and the gen-l10n configuration '
    'that was used.',
  );
}


### FILE: ./l10n/app_localizations_en.dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get language => 'Language';

  @override
  String get app_title => 'Autonitor';

  @override
  String get settings => 'Settings';

  @override
  String get home => 'Home';

  @override
  String get data => 'Data';

  @override
  String get accounts => 'Accounts';

  @override
  String get switchAccount => 'Switch Account';

  @override
  String get followers => 'Followers';

  @override
  String get following => 'Following';

  @override
  String get new_account => 'Add a new account';

  @override
  String get view_cookie => 'View Cookie';

  @override
  String get close => 'Close';

  @override
  String get view_on_twitter => 'View on Twitter';

  @override
  String get metadata => 'Metadata';

  @override
  String get tweets => 'Tweets';

  @override
  String get media_count => 'Media Count';

  @override
  String get likes => 'Likes';

  @override
  String get listed_count => 'Listed Count';

  @override
  String get identity => 'Identity-related';

  @override
  String get back => 'Back';

  @override
  String get history => 'History';

  @override
  String get suspended => 'Suspended';

  @override
  String get deactivated => 'Deactivated';

  @override
  String get normal_unfollowed => 'Normal Unfollowed';

  @override
  String get be_followed_back => 'Be Followed Back';

  @override
  String get mutual_unfollowed => 'Mutual Unfollowed';

  @override
  String get oneway_unfollowed => 'One-way Unfollowed';

  @override
  String get new_followers_following => 'New Followers & Following';

  @override
  String get empty_list_message => 'The list is empty';

  @override
  String get switch_account => 'Switch Account';

  @override
  String get run => 'Run';

  @override
  String get choose_login_method => 'Choose Login Method';

  @override
  String get browser_login => 'Login via Browser';

  @override
  String get manual_cookie => 'Manual Cookie Input';

  @override
  String get joined => 'Joined';

  @override
  String get im_logged_in => 'I\'ve logged in';

  @override
  String get cancel => 'Cancel';

  @override
  String get ok => 'OK';

  @override
  String get account_added_successfully => 'Account added successfully!';

  @override
  String get saving_account => 'Saving account...';

  @override
  String get cookie => 'Cookie';

  @override
  String get no_cookie_found => 'No cookie found';

  @override
  String get no_auth_token_found => 'No auth_token found';

  @override
  String get found_auth_token_last_check => 'Auth Token found in last check';

  @override
  String get general => 'General';

  @override
  String get login_first => 'Log in Needed';

  @override
  String get login_first_description => 'Add at least one account to continue';

  @override
  String get log_in => 'Log In';

  @override
  String get delete => 'Delete';

  @override
  String confirm_delete_account(Object accountId) {
    return 'Are you sure you want to delete account $accountId? This action cannot be undone. Deleting an account will permanently remove all its associated data (history, follower/following lists etc.). If you only want to update the cookie, simply add the account again.';
  }

  @override
  String get copy => 'Copy';

  @override
  String get copied_to_clipboard => 'Copied to clipboard!';

  @override
  String get no_json_data_available => 'No JSON data available';
}


### FILE: ./l10n/app_localizations_zh.dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Chinese (`zh`).
class AppLocalizationsZh extends AppLocalizations {
  AppLocalizationsZh([String locale = 'zh']) : super(locale);

  @override
  String get language => '语言';

  @override
  String get app_title => 'Autonitor';

  @override
  String get settings => '设置';

  @override
  String get home => '首页';

  @override
  String get data => '数据';

  @override
  String get accounts => '账号';

  @override
  String get switchAccount => '切换账号';

  @override
  String get followers => '关注者';

  @override
  String get following => '正在关注';

  @override
  String get new_account => '添加新账号';

  @override
  String get view_cookie => '查看 Cookie';

  @override
  String get close => '关闭';

  @override
  String get view_on_twitter => '在 Twitter 上查看';

  @override
  String get metadata => '元数据';

  @override
  String get tweets => '推文';

  @override
  String get media_count => '媒体数量';

  @override
  String get likes => '点赞数量';

  @override
  String get listed_count => '被收录列表';

  @override
  String get identity => '身份相关';

  @override
  String get back => '返回';

  @override
  String get history => '历史';

  @override
  String get suspended => '被冻结';

  @override
  String get deactivated => '注销';

  @override
  String get normal_unfollowed => '普通取关';

  @override
  String get be_followed_back => '被回关';

  @override
  String get mutual_unfollowed => '互关双取';

  @override
  String get oneway_unfollowed => '互关单取';

  @override
  String get new_followers_following => '新增关注';

  @override
  String get empty_list_message => '列表为空';

  @override
  String get switch_account => '切换账号';

  @override
  String get run => '运行';

  @override
  String get choose_login_method => '选择登录方式';

  @override
  String get browser_login => '浏览器登录';

  @override
  String get manual_cookie => '输入Cookie';

  @override
  String get joined => '加入于';

  @override
  String get im_logged_in => '我已登录';

  @override
  String get cancel => '取消';

  @override
  String get ok => '确定';

  @override
  String get account_added_successfully => '账号添加成功！';

  @override
  String get saving_account => '正在保存账号...';

  @override
  String get cookie => 'Cookie';

  @override
  String get no_cookie_found => '未能找到 cookie';

  @override
  String get no_auth_token_found => '未能找到 auth_token';

  @override
  String get found_auth_token_last_check => '在上次检查中找到了 Auth Token';

  @override
  String get general => '通用';

  @override
  String get login_first => '需要登录';

  @override
  String get login_first_description => '请至少添加一个账号以继续';

  @override
  String get log_in => '登录';

  @override
  String get delete => '删除';

  @override
  String confirm_delete_account(Object accountId) {
    return '您确定要删除账号 $accountId 吗？此操作无法撤销。删除账号将永久移除其所有关联数据（历史记录、关注者/关注列表等）。如果您只想更新 Cookie，请直接重新添加该账号。';
  }

  @override
  String get copy => '复制';

  @override
  String get copied_to_clipboard => '已复制到剪贴板！';

  @override
  String get no_json_data_available => '无 JSON 数据';
}

/// The translations for Chinese, as used in Taiwan (`zh_TW`).
class AppLocalizationsZhTw extends AppLocalizationsZh {
  AppLocalizationsZhTw() : super('zh_TW');

  @override
  String get language => '語言';

  @override
  String get app_title => 'Autonitor';

  @override
  String get settings => '設定';

  @override
  String get home => '首頁';

  @override
  String get data => '數據';

  @override
  String get accounts => '賬戶';

  @override
  String get switchAccount => '切換賬戶';

  @override
  String get followers => '跟隨者';

  @override
  String get following => '跟隨中';

  @override
  String get new_account => '添加新賬戶';

  @override
  String get view_cookie => '查看 Cookie';

  @override
  String get close => '關閉';

  @override
  String get view_on_twitter => '在 Twitter 上查看';

  @override
  String get metadata => '元數據';

  @override
  String get tweets => '推文';

  @override
  String get media_count => '媒體數量';

  @override
  String get likes => '讚數';

  @override
  String get listed_count => '被收錄列表';

  @override
  String get identity => '身份相關';

  @override
  String get back => '返回';

  @override
  String get history => '歷史';

  @override
  String get suspended => '遭停權';

  @override
  String get deactivated => '註銷';

  @override
  String get normal_unfollowed => '普通取跟';

  @override
  String get be_followed_back => '被回跟';

  @override
  String get mutual_unfollowed => '互跟雙取';

  @override
  String get oneway_unfollowed => '互跟單取';

  @override
  String get new_followers_following => '新增跟隨';

  @override
  String get empty_list_message => '空列表';

  @override
  String get switch_account => '切換賬戶';

  @override
  String get run => '運行';

  @override
  String get choose_login_method => '選擇登入方式';

  @override
  String get browser_login => '透過瀏覽器登入';

  @override
  String get manual_cookie => '鍵入Cookie';

  @override
  String get joined => '加入於';

  @override
  String get im_logged_in => '我已登入';

  @override
  String get cancel => '取消';

  @override
  String get ok => '確定';

  @override
  String get account_added_successfully => '賬戶添加成功！';

  @override
  String get saving_account => '正在保存賬戶...';

  @override
  String get cookie => 'Cookie';

  @override
  String get no_cookie_found => '未能找到 cookie';

  @override
  String get no_auth_token_found => '未能找到 auth_token';

  @override
  String get found_auth_token_last_check => '在上次檢查中找到了 Auth Token';

  @override
  String get general => '通用';

  @override
  String get login_first => '需要登入';

  @override
  String get login_first_description => '請至少添加一個帳戶以繼續';

  @override
  String get log_in => '登入';

  @override
  String get delete => '刪除';

  @override
  String confirm_delete_account(Object accountId) {
    return '您確定要刪除賬戶 $accountId 嗎？此操作無法撤銷。刪除賬戶將永久移除其所有關聯數據（歷史紀錄、跟隨者/跟隨列表等）。如果您只想更新 Cookie，請直接重新添加該賬戶。';
  }

  @override
  String get copy => '拷貝';

  @override
  String get copied_to_clipboard => '已拷貝到剪貼簿！';

  @override
  String get no_json_data_available => '無 JSON 數據';
}


### FILE: ./l10n/app_zh.arb
{
  "@@locale": "zh",
  "language": "语言",
  "@language": {
    "description": "语言设置的标签"
  },
  "app_title": "Autonitor",
  "settings": "设置",
  "home": "首页",
  "data": "数据",
  "accounts": "账号",
  "switchAccount": "切换账号",
  "followers": "关注者",
  "following": "正在关注",
  "new_account": "添加新账号",
  "view_cookie": "查看 Cookie",
  "close": "关闭",
  "view_on_twitter": "在 Twitter 上查看",
  "metadata": "元数据",
  "tweets": "推文",
  "media_count": "媒体数量",
  "likes": "点赞数量",
  "listed_count": "被收录列表",
  "identity": "身份相关",
  "back": "返回",
  "history": "历史",
  "suspended": "被冻结",
  "deactivated": "注销",
  "normal_unfollowed": "普通取关",
  "be_followed_back": "被回关",
  "mutual_unfollowed": "互关双取",
  "oneway_unfollowed": "互关单取",
  "new_followers_following": "新增关注",
  "empty_list_message": "列表为空",
  "switch_account": "切换账号",
  "run": "运行",
  "choose_login_method": "选择登录方式",
  "browser_login": "浏览器登录",
  "manual_cookie": "输入Cookie",
  "joined": "加入于",
  "im_logged_in": "我已登录",
  "cancel": "取消",
  "ok": "确定",
  "account_added_successfully": "账号添加成功！",
  "saving_account": "正在保存账号...",
  "cookie": "Cookie",
  "no_cookie_found": "未能找到 cookie",
  "no_auth_token_found": "未能找到 auth_token",
  "found_auth_token_last_check": "在上次检查中找到了 Auth Token",
  "general": "通用",
  "login_first": "需要登录",
  "login_first_description": "请至少添加一个账号以继续",
  "log_in": "登录",
  "delete": "删除",
  "confirm_delete_account": "您确定要删除账号 {accountId} 吗？此操作无法撤销。删除账号将永久移除其所有关联数据（历史记录、关注者/关注列表等）。如果您只想更新 Cookie，请直接重新添加该账号。",
  "@confirm_delete_account": {
    "placeholders": {
      "accountId": {
        "description": "The ID of the account to be deleted"
      }
    }
  },
  "copy": "复制",
  "copied_to_clipboard": "已复制到剪贴板！",
  "no_json_data_available": "无 JSON 数据"
}

### FILE: ./l10n/app_zh_TW.arb
{
  "@@locale": "zh_TW",
  "language": "語言",
  "@language": {
    "description": "語言設定的標籤"
  },
  "app_title": "Autonitor",
  "settings": "設定",
  "home": "首頁",
  "data": "數據",
  "accounts": "賬戶",
  "switchAccount": "切換賬戶",
  "followers": "跟隨者",
  "following": "跟隨中",
  "new_account": "添加新賬戶",
  "view_cookie": "查看 Cookie",
  "close": "關閉",
  "view_on_twitter": "在 Twitter 上查看",
  "metadata": "元數據",
  "tweets": "推文",
  "media_count": "媒體數量",
  "likes": "讚數",
  "listed_count": "被收錄列表",
  "identity": "身份相關",
  "back": "返回",
  "history": "歷史",
  "suspended": "遭停權",
  "deactivated": "註銷",
  "normal_unfollowed": "普通取跟",
  "be_followed_back": "被回跟",
  "mutual_unfollowed": "互跟雙取",
  "oneway_unfollowed": "互跟單取",
  "new_followers_following": "新增跟隨",
  "empty_list_message": "空列表",
  "switch_account": "切換賬戶",
  "run": "運行",
  "choose_login_method": "選擇登入方式",
  "browser_login": "透過瀏覽器登入",
  "manual_cookie": "鍵入Cookie",
  "joined": "加入於",
  "im_logged_in": "我已登入",
  "cancel": "取消",
  "ok": "確定",
  "account_added_successfully": "賬戶添加成功！",
  "saving_account": "正在保存賬戶...",
  "cookie": "Cookie",
  "no_cookie_found": "未能找到 cookie",
  "no_auth_token_found": "未能找到 auth_token",
  "found_auth_token_last_check": "在上次檢查中找到了 Auth Token",
  "general": "通用",
  "login_first": "需要登入",
  "login_first_description": "請至少添加一個帳戶以繼續",
  "log_in": "登入",
  "delete": "刪除",
  "confirm_delete_account": "您確定要刪除賬戶 {accountId} 嗎？此操作無法撤銷。刪除賬戶將永久移除其所有關聯數據（歷史紀錄、跟隨者/跟隨列表等）。如果您只想更新 Cookie，請直接重新添加該賬戶。",
  "@confirm_delete_account": {
    "placeholders": {
      "accountId": {
        "description": "The ID of the account to be deleted"
      }
    }
  },
  "copy": "拷貝",
  "copied_to_clipboard": "已拷貝到剪貼簿！",
  "no_json_data_available": "無 JSON 數據"
}

### FILE: ./main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:autonitor/ui/main_scaffold.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'l10n/app_localizations.dart';
import 'providers/settings_provider.dart';
import 'services/database.dart';

final databaseProvider = Provider<AppDatabase>((ref) {
  return AppDatabase();
});

void main() {
  runApp(
    const ProviderScope(
      child: MyApp(),
    ),
  );
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  // 4. 添加 WidgetRef ref
  Widget build(BuildContext context, WidgetRef ref) {
    // 5. 监听设置
    final settingsValue = ref.watch(settingsProvider);

    return MaterialApp(
      onGenerateTitle: (context) {
        return AppLocalizations.of(context)?.app_title ?? 'Autonitor';
      },
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      darkTheme: ThemeData(
        brightness: Brightness.dark,
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      themeMode: ThemeMode.system,
      home: const MainScaffold(),

      // --- 本地化配置 ---
      localizationsDelegates: const [
        AppLocalizations.delegate, // 你生成的 AppLocalizations 代理
        GlobalMaterialLocalizations.delegate, // Material 组件的默认本地化
        GlobalWidgetsLocalizations.delegate, // Widget 的默认本地化 (如文本方向)
        GlobalCupertinoLocalizations.delegate, // Cupertino 组件的本地化 (如果用到)
      ],
      // 6. 更新 supportedLocales
      supportedLocales: const [
        Locale('en'),       // 英语
        Locale('zh', 'CN'), // 简体中文
        Locale('zh', 'TW'), // 繁體中文
        Locale('zh'),       // 基础中文 (作为 fallback)
      ],

      // 7. 设置 locale 属性
      locale: settingsValue.when(
        loading: () => null, // 加载中，使用系统默认
        error: (e, s) => null, // 出错，使用系统默认
        data: (settings) => settings.locale, // 使用 Provider 中的 Locale (null 表示 Auto/系统默认)
      ),
    );
  }
}



### FILE: ./models/account.dart
class Account {
  final String? latestRawJson;
  /// The unique Twitter User ID (Rest ID / twid).
  final String id;

  /// The full cookie string required for authentication.
  final String cookie;

  /// The user's display name (e.g., "Elon Musk"). Fetched from API.
  final String? name;

  /// The user's screen name / handle (e.g., "elonmusk"). Fetched from API.
  final String? screenName;

  /// The URL for the user's profile image. Fetched from API.
  final String? avatarUrl;

  /// The URL for the user's profile banner.
  final String? bannerUrl;

  /// The user's biography.
  final String? bio;

  /// The user's profile location.
  final String? location;

  /// The user's profile link (t.co).
  final String? link;

  /// The ISO 8601 string of when the account was created.
  final String? joinTime;

  /// The number of followers.
  final int followersCount;

  /// The number of accounts the user is following.
  final int followingCount;
  final int statusesCount;
  final int mediaCount;
  final int favouritesCount;
  final int listedCount;

  Account({
    required this.id,
    required this.cookie,
    this.name,
    this.screenName,
    this.avatarUrl,
    this.bannerUrl,
    this.bio,
    this.location,
    this.link,
    this.joinTime,
    this.followersCount = 0,
    this.followingCount = 0,
    this.statusesCount = 0,
    this.mediaCount = 0,
    this.favouritesCount = 0,
    this.listedCount = 0,
    this.latestRawJson,
  });

  /// Creates an Account instance from a JSON map.
  factory Account.fromJson(Map<String, dynamic> json) {
    return Account(
      id: json['id'] as String? ?? '', // Provide default empty string
      cookie: json['cookie'] as String? ?? '', // Provide default empty string
      name: json['name'] as String?,
      screenName: json['screenName'] as String?,
      avatarUrl: json['avatarUrl'] as String?,
      bannerUrl: json['bannerUrl'] as String?,
      bio: json['bio'] as String?,
      location: json['location'] as String?,
      link: json['link'] as String?,
      joinTime: json['joinTime'] as String?,
      followersCount: json['followersCount'] as int? ?? 0,
      followingCount: json['followingCount'] as int? ?? 0,
      statusesCount: json['statusesCount'] ?? 0,
      mediaCount: json['mediaCount'] ?? 0,
      favouritesCount: json['favouritesCount'] ?? 0,
      listedCount: json['listedCount'] ?? 0,
      latestRawJson: json['latestRawJson'] as String?,
    );
  }

  /// Converts the Account instance to a JSON map.
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'cookie': cookie,
      'name': name,
      'screenName': screenName,
      'avatarUrl': avatarUrl,
      'bannerUrl': bannerUrl,
      'bio': bio,
      'location': location,
      'link': link,
      'joinTime': joinTime,
      'followersCount': followersCount,
      'followingCount': followingCount,
      'statusesCount': statusesCount,
      'mediaCount': mediaCount,
      'favouritesCount': favouritesCount,
      'listedCount': listedCount,
      'latestRawJson': latestRawJson,
    };
  }

  // Optional: Add copyWith for easier updates
  Account copyWith({
    String? id,
    String? cookie,
    String? name,
    String? screenName,
    String? avatarUrl,
    String? bannerUrl,
    String? bio,
    String? location,
    String? link,
    String? joinTime,
    int? followersCount,
    int? followingCount,
    int? statusesCount,
    int? mediaCount,
    int? favouritesCount,
    int? listedCount,
    String? latestRawJson,
  }) {
    return Account(
      id: id ?? this.id,
      cookie: cookie ?? this.cookie,
      name: name ?? this.name,
      screenName: screenName ?? this.screenName,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      bannerUrl: bannerUrl ?? this.bannerUrl,
      bio: bio ?? this.bio,
      location: location ?? this.location,
      link: link ?? this.link,
      joinTime: joinTime ?? this.joinTime,
      followersCount: followersCount ?? this.followersCount,
      followingCount: followingCount ?? this.followingCount,
      statusesCount: statusesCount ?? this.statusesCount,
      mediaCount: mediaCount ?? this.mediaCount,
      favouritesCount: favouritesCount ?? this.favouritesCount,
      listedCount: listedCount ?? this.listedCount,
      latestRawJson: latestRawJson ?? this.latestRawJson,
    );
  }

  // Optional: Override toString for better debugging
  @override
  String toString() {
    return 'Account(id: $id, name: $name, screenName: $screenName, avatarUrl: $avatarUrl, cookie: ${cookie.length > 10 ? cookie.substring(0, 10) + '...' : cookie})';
  }
}


### FILE: ./models/app_settings.dart
import 'package:flutter/material.dart';

class AppSettings {
  /// 选择的语言 ('Auto', '简体中文', 'English' 等)。
  final Locale? locale;
  // 未来可以添加其他设置字段，例如：
  // final bool isDarkMode;

  /// 构造函数，默认语言为 'Auto'。
  AppSettings({
    this.locale,
    // 在这里初始化其他默认设置
    // this.isDarkMode = false,
  });

  /// 创建一个包含更新值的新实例。
  AppSettings copyWith({Locale? locale}) {
    return AppSettings(locale: locale);
  }

  /// 将设置对象转换为 JSON Map 以便存储。
  Map<String, dynamic> toJson() => {
    'languageCode': locale?.languageCode,
    'countryCode': locale?.countryCode,
  };

  /// 从 JSON Map 创建设置对象。
  factory AppSettings.fromJson(Map<String, dynamic> json) {
    final languageCode = json['languageCode'] as String?;
    final countryCode = json['countryCode'] as String?;
    return AppSettings(
      locale: languageCode != null ? Locale(languageCode, countryCode) : null,
    );
  }
}


### FILE: ./models/cache_data.dart
// [已更新]
// 核心改动：
// 1. 新增了 `toJson` 方法，用于将 CacheData 对象实例序列化为 Map<String, dynamic>。
// 2. 这是解决 `The method 'toJson' isn't defined` 编译错误所必需的。

class CacheData {
  final String accountId;
  final String accountName;
  final String lastUpdateTime;
  final int followersCount;
  final int followingCount;
  final int unfollowedCount;
  final int mutualUnfollowedCount;
  final int singleUnfollowedCount;
  final int frozenCount;
  final int deactivatedCount;
  final int refollowedCount;
  final int newFollowersCount;

  CacheData({
    required this.accountId,
    required this.accountName,
    required this.lastUpdateTime,
    required this.followersCount,
    required this.followingCount,
    required this.unfollowedCount,
    required this.mutualUnfollowedCount,
    required this.singleUnfollowedCount,
    required this.frozenCount,
    required this.deactivatedCount,
    required this.refollowedCount,
    required this.newFollowersCount,
  });

  factory CacheData.fromJson(Map<String, dynamic> json) {
    return CacheData(
      accountId: json['accountId'] ?? '',
      accountName: json['accountName'] ?? 'Unknown',
      lastUpdateTime: json['lastUpdateTime'] ?? '',
      followersCount: json['followersCount'] ?? 0,
      followingCount: json['followingCount'] ?? 0,
      unfollowedCount: json['unfollowedCount'] ?? 0,
      mutualUnfollowedCount: json['mutualUnfollowedCount'] ?? 0,
      singleUnfollowedCount: json['singleUnfollowedCount'] ?? 0,
      frozenCount: json['frozenCount'] ?? 0,
      deactivatedCount: json['deactivatedCount'] ?? 0,
      refollowedCount: json['refollowedCount'] ?? 0,
      newFollowersCount: json['newFollowersCount'] ?? 0,
    );
  }

  /// [新增] 将 CacheData 实例转换为 Map 的方法
  Map<String, dynamic> toJson() {
    return {
      'accountId': accountId,
      'accountName': accountName,
      'lastUpdateTime': lastUpdateTime,
      'followersCount': followersCount,
      'followingCount': followingCount,
      'unfollowedCount': unfollowedCount,
      'mutualUnfollowedCount': mutualUnfollowedCount,
      'singleUnfollowedCount': singleUnfollowedCount,
      'frozenCount': frozenCount,
      'deactivatedCount': deactivatedCount,
      'refollowedCount': refollowedCount,
      'newFollowersCount': newFollowersCount,
    };
  }
}



### FILE: ./models/twitter_user.dart
// [已更新]
// 核心改动：
// 1. 添加了 `fromJson` 工厂构造函数，让这个类可以从一个Map(JSON)对象创建实例。
// 2. 添加了 `toJson` 方法，让这个类的实例可以被转换成一个Map(JSON)对象。
// 3. 这使得TwitterUser对象可以在应用中被序列化和反序列化，是数据持久化的基础。
class TwitterUser {
  final String avatarUrl;
  final String name;
  final String id;
  final String restId;
  final String joinTime;
  final String? bio;
  final String? location;
  final String? bannerUrl;
  final String? link;
  final int followingCount;
  final int followersCount;
  final int statusesCount;
  final int mediaCount;
  final int favouritesCount;
  final int listedCount;
  final String? latestRawJson;

  const TwitterUser({
    required this.avatarUrl,
    required this.name,
    required this.id,
    required this.restId,
    required this.joinTime,
    required this.bio,
    required this.location,
    required this.bannerUrl,
    required this.link,
    required this.followersCount,
    required this.followingCount,
    required this.statusesCount,
    required this.mediaCount,
    required this.favouritesCount,
    required this.listedCount,
    required this.latestRawJson,
  });

  // 从Map(JSON)创建TwitterUser实例
  factory TwitterUser.fromJson(Map<String, dynamic> json) {
    return TwitterUser(
      avatarUrl: json['avatarUrl'] ?? '',
      name: json['name'] ?? 'Unknown Name',
      id: json['id'] ?? 'Unknown ID',
      restId: json['restId'] ?? '',
      bio: json['bio'],
      location: json['location'],
      joinTime: json['joinTime'],
      bannerUrl: json['bannerUrl'],
      link: json['link'],
      followersCount: json['followersCount'] ?? 0,
      followingCount: json['followingCount'] ?? 0,
      statusesCount: json['statusesCount'] ?? 0,
      mediaCount: json['mediaCount'] ?? 0,
      favouritesCount: json['favouritesCount'] ?? 0,
      listedCount: json['listedCount'] ?? 0,
      latestRawJson: json['latestRawJson'] as String?,
    );
  }

  // 将TwitterUser实例转换为Map(JSON)
  Map<String, dynamic> toJson() {
    return {
      'avatarUrl': avatarUrl,
      'name': name,
      'id': id,
      'restId': restId,
      'bio': bio,
      'location': location,
      'joinTime': joinTime,
      'bannerUrl': bannerUrl,
      'statusesCount': statusesCount,
      'mediaCount': mediaCount,
      'favouritesCount': favouritesCount,
      'listedCount': listedCount,
      'latestRawJson': latestRawJson,
    };
  }
}


### FILE: ./providers/auth_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/account.dart';
import '../services/secure_storage_service.dart';
import '../services/twitter_api_service.dart';
import '../services/database.dart';
import '../main.dart';
import 'dart:convert';
import 'package:drift/drift.dart';
import '../utils/diff_utils.dart';
import 'package:async/async.dart';
import 'package:async_locks/async_locks.dart';
import '../services/twitter_api_v1_service.dart';
import '../core/data_processor.dart';

class RefreshResult {
  final String accountId;
  final bool success;
  final String? error;

  RefreshResult({required this.accountId, required this.success, this.error});
}

final accountsProvider = StateNotifierProvider<AccountsNotifier, List<Account>>(
  (ref) {
    return AccountsNotifier(ref);
  },
);

class ActiveAccountNotifier extends StateNotifier<Account?> {
  final Ref _ref;
  late final SecureStorageService _storageService;

  ActiveAccountNotifier(this._ref) : super(null) {
    _storageService = _ref.read(secureStorageServiceProvider);
    _initializeActiveAccount();
  }

  Future<void> _initializeActiveAccount() async {
    final activeId = await _storageService.readActiveAccountId();
    final accounts = _ref.read(accountsProvider);
    print(
      "ActiveAccountNotifier: Initializing... Loaded active ID: $activeId. Current accounts: ${accounts.length}",
    );
    if (activeId != null && accounts.isNotEmpty) {
      try {
        final initialAccount = accounts.firstWhere((acc) => acc.id == activeId);
        state = initialAccount;
        print(
          "ActiveAccountNotifier: Initial active account set to ID ${state?.id}.",
        );
      } catch (e) {
        print(
          "ActiveAccountNotifier: Stored active ID $activeId not found in accounts list. Resetting.",
        );
        await _storageService.deleteActiveAccountId();
        if (accounts.isNotEmpty) {
          state = accounts.first;
          await _storageService.saveActiveAccountId(state!.id);
          print(
            "ActiveAccountNotifier: Reset active account to first account ID ${state?.id}.",
          );
        } else {
          state = null;
          print("ActiveAccountNotifier: No accounts available after reset.");
        }
      }
    } else if (accounts.isNotEmpty) {
      state = accounts.first;
      await _storageService.saveActiveAccountId(state!.id);
      print(
        "ActiveAccountNotifier: No active ID stored, setting first account ID ${state?.id} as active.",
      );
    } else {
      state = null;
      print(
        "ActiveAccountNotifier: No accounts available, active account remains null.",
      );
    }
  }

  Future<void> setActive(Account? account) async {
    state = account;
    if (account != null) {
      await _storageService.saveActiveAccountId(account.id);
      print(
        "ActiveAccountNotifier: Set active account ID: ${account.id} and persisted.",
      );
    } else {
      await _storageService.deleteActiveAccountId();
      print("ActiveAccountNotifier: Cleared active account ID and persisted.");
    }
  }

  Future<void> updateFromList(List<Account> newList) async {
    print(
      "ActiveAccountNotifier: Account list updated. Current active ID: ${state?.id}. New list size: ${newList.length}",
    );
    if (state == null) {
      if (newList.isNotEmpty) {
        await setActive(newList.first);
        print(
          "ActiveAccountNotifier: No previous active account, set first of new list (${state?.id}) as active.",
        );
      } else {
        print(
          "ActiveAccountNotifier: No previous active account and new list is empty.",
        );
      }
    } else {
      final bool stillExists = newList.any((acc) => acc.id == state!.id);
      if (!stillExists) {
        print(
          "ActiveAccountNotifier: Active account ID ${state!.id} no longer exists in the updated list.",
        );
        await setActive(newList.isNotEmpty ? newList.first : null);
        print(
          "ActiveAccountNotifier: Reset active account to ${state?.id ?? 'null'}.",
        );
      } else {
        print(
          "ActiveAccountNotifier: Active account ID ${state!.id} still exists. No change needed.",
        );
        final updatedAccountInstance = newList.firstWhere(
          (acc) => acc.id == state!.id,
        );
        if (state != updatedAccountInstance) {
          state = updatedAccountInstance;
          print(
            "ActiveAccountNotifier: Updated active account instance for ID ${state!.id}.",
          );
        }
      }
    }
  }
}

final activeAccountProvider =
    StateNotifierProvider<ActiveAccountNotifier, Account?>((ref) {
      final notifier = ActiveAccountNotifier(ref);
      ref.listen(accountsProvider, (previousList, newList) {
        notifier.updateFromList(newList);
      });
      return notifier;
    });

final analysisLogProvider = StateProvider<List<String>>((ref) => []);

class AccountsNotifier extends StateNotifier<List<Account>> {
  final Ref _ref;
  late final SecureStorageService _storageService;
  late final TwitterApiService _apiService;
  late final AppDatabase _database;
  late final TwitterApiV1Service _apiServiceV1;

  AccountsNotifier(this._ref) : super([]) {
    _storageService = _ref.read(secureStorageServiceProvider);
    _apiService = _ref.read(twitterApiServiceProvider);
    _apiServiceV1 = _ref.read(twitterApiV1ServiceProvider);
    _database = _ref.read(databaseProvider);
    loadAccounts();
  }

  Future<void> loadAccounts() async {
    try {
      final profiles = await _database.select(_database.loggedAccounts).get();
      final cookies = await _storageService.getAllCookies();
      final List<Account> loadedAccounts = [];
      for (final profile in profiles) {
        final cookie = cookies[profile.id];
        if (cookie != null) {
          loadedAccounts.add(
            Account(
              id: profile.id,
              cookie: cookie,
              name: profile.name,
              screenName: profile.screenName,
              avatarUrl: profile.avatarUrl,
              bannerUrl: profile.bannerUrl,
              bio: profile.bio,
              location: profile.location,
              link: profile.link,
              joinTime: profile.joinTime,
              followersCount: profile.followersCount,
              followingCount: profile.followingCount,
              statusesCount: profile.statusesCount,
              mediaCount: profile.mediaCount,
              favouritesCount: profile.favouritesCount,
              listedCount: profile.listedCount,
              latestRawJson: profile.latestRawJson,
            ),
          );
        } else {
          print(
            "AccountsNotifier: Warning - Profile found for ID ${profile.id} but no cookie in SecureStorage. Skipping this account.",
          );
        }
      }
      state = loadedAccounts;
      print("AccountsNotifier: Loaded and assembled ${state.length} accounts.");
      _ref.read(activeAccountProvider.notifier).updateFromList(state);
    } catch (e, s) {
      print("AccountsNotifier: Error loading accounts: $e\n$s");
      state = [];
      _ref.read(activeAccountProvider.notifier).updateFromList(state);
    }
  }

  String? _parseTwidFromCookie(String cookie) {
    try {
      final parts = cookie.split(';');
      final twidPart = parts.firstWhere(
        (part) => part.trim().startsWith('twid='),
        orElse: () => '',
      );
      if (twidPart.isNotEmpty) {
        var valuePart = twidPart.split('=')[1].trim();
        valuePart = Uri.decodeComponent(valuePart);
        if (valuePart.startsWith('u=')) {
          final id = valuePart.substring(2);
          return id.isNotEmpty ? id : null;
        } else if (valuePart.startsWith('u_')) {
          final id = valuePart.substring(2);
          return id.isNotEmpty ? id : null;
        } else {
          print("解析 twid 失败: twid value ($valuePart) 不以 'u=' 或 'u_' 开头");
          return null;
        }
      }
      return null;
    } catch (e) {
      print("Error parsing twid from cookie: $e");
      return null;
    }
  }

  Future<void> addAccount(String cookie) async {
    final twid = _parseTwidFromCookie(cookie);
    if (twid == null) {
      throw Exception('无法从Cookie中解析出twid');
    }

    String? name;
    String? screenName;
    String? avatarUrl;
    String? bannerUrl;
    String? bio;
    String? location;
    String? link;
    String? joinTime;
    int followersCount = 0;
    int followingCount = 0;
    int statusesCount = 0;
    int mediaCount = 0;
    int favouritesCount = 0;
    int listedCount = 0;
    String rawJsonString = '{}';

    try {
      final Map<String, dynamic> userProfileJson = await _apiService
          .getUserByRestId(twid, cookie);
      rawJsonString = jsonEncode(userProfileJson);
      final result = userProfileJson['data']?['user']?['result'];

      if (result != null &&
          result is Map<String, dynamic> &&
          result['__typename'] == 'User') {
        final core = result['core'];
        final legacy = result['legacy'];

        if (core != null && core is Map<String, dynamic>) {
          name = core['name'] as String?;
          screenName = core['screen_name'] as String?;
          avatarUrl = (result['avatar']['image_url'] as String?)?.replaceFirst(
            '_normal',
            '_400x400',
          );
          joinTime = core['created_at'] as String?;
          print(
            "addAccount: Profile fetched - Name: $name, ScreenName: $screenName, Avatar: $avatarUrl",
          );
        } else {
          print("addAccount: API 返回成功，但 core 数据缺失或格式不正确。");
        }

        if (legacy != null && legacy is Map<String, dynamic>) {
          bio = legacy['description'] as String?;
          followersCount = legacy['followers_count'] as int? ?? 0;
          followingCount = legacy['friends_count'] as int? ?? 0;
          final String? tcoUrl = legacy['url'] as String?;
          String? finalLink = tcoUrl;

          try {
            final entities = legacy['entities'] as Map<String, dynamic>?;
            final urlBlock = entities?['url'] as Map<String, dynamic>?;
            final urlsList = urlBlock?['urls'] as List<dynamic>?;
            if (tcoUrl != null && urlsList != null) {
              for (final item in urlsList) {
                final urlMap = item as Map<String, dynamic>?;
                if (urlMap != null && urlMap['url'] == tcoUrl) {
                  finalLink = urlMap['expanded_url'] as String?;
                  break;
                }
              }
            }
          } catch (e) {
            // Fallback handled
          }
          link = finalLink;
          bannerUrl = legacy['profile_banner_url'] as String?;
          statusesCount = legacy['statuses_count'] as int? ?? 0;
          mediaCount = legacy['media_count'] as int? ?? 0;
          favouritesCount = legacy['favourites_count'] as int? ?? 0;
          listedCount = legacy['listed_count'] as int? ?? 0;
        }

        final locationMap = result['location'] as Map<String, dynamic>?;
        location = locationMap?['location'] as String?;
      } else {
        print("addAccount: API 返回成功，但 result 数据缺失或格式不正确。");
      }
    } catch (e) {
      print("addAccount: 调用 API 或解析 Profile 时出错: $e");
      rethrow;
    }

    await _storageService.saveCookie(twid, cookie);
    print("addAccount: Saved cookie to SecureStorage for ID: $twid");

    try {
      await _database.transaction(() async {
        final oldProfile = await (_database.select(
          _database.loggedAccounts,
        )..where((tbl) => tbl.id.equals(twid))).getSingleOrNull();
        final oldJsonString = oldProfile?.latestRawJson;

        final diffString = calculateReverseDiff(rawJsonString, oldJsonString);
        print(
          "addAccount: Calculated reverse diff (length: ${diffString?.length ?? 'null'}) for ID: $twid",
        );

        final companion = LoggedAccountsCompanion(
          id: Value(twid),
          name: Value(name),
          screenName: Value(screenName),
          avatarUrl: Value(avatarUrl),
          bannerUrl: Value(bannerUrl),
          bio: Value(bio),
          location: Value(location),
          link: Value(link),
          joinTime: Value(joinTime),
          followersCount: Value(followersCount),
          followingCount: Value(followingCount),
          statusesCount: Value(statusesCount),
          mediaCount: Value(mediaCount),
          favouritesCount: Value(favouritesCount),
          listedCount: Value(listedCount),
          latestRawJson: Value(rawJsonString),
          avatarLocalPath: Value(null),
          bannerLocalPath: Value(null),
        );

        await _database
            .into(_database.loggedAccounts)
            .insert(companion, mode: InsertMode.replace);
        print(
          "addAccount: Inserted/Replaced profile in LoggedAccounts for ID: $twid",
        );

        if (diffString != null && diffString.isNotEmpty) {
          final historyCompanion = AccountProfileHistoryCompanion(
            ownerId: Value(twid),
            reverseDiffJson: Value(diffString),
            timestamp: Value(DateTime.now()),
          );
          await _database
              .into(_database.accountProfileHistory)
              .insert(historyCompanion);
          print(
            "addAccount: Inserted profile history into AccountProfileHistory for ID: $twid",
          );
        }
      });

      await loadAccounts();
    } catch (e, s) {
      print(
        "addAccount: Error during database transaction for ID $twid: $e\n$s",
      );
      throw Exception('Failed to save account data: $e');
    }
  }

  Future<void> removeAccount(String id) async {
    try {
      await _storageService.deleteCookie(id);
      print("AccountsNotifier: Deleted cookie from SecureStorage for ID $id.");

      final deletedRows = await (_database.delete(
        _database.loggedAccounts,
      )..where((tbl) => tbl.id.equals(id))).go();

      if (deletedRows > 0) {
        print("AccountsNotifier: Deleted profile from database for ID $id.");
      } else {
        print(
          "AccountsNotifier: Warning - Tried to delete profile for ID $id, but it was not found in the database.",
        );
      }

      await loadAccounts();
    } catch (e, s) {
      print("AccountsNotifier: Error removing account ID $id: $e\n$s");
    }
  }

  // --- 新增：运行分析流程 ---
  Future<void> runAnalysisProcess(Account accountToProcess) async {
    // <-- 添加参数
    // final currentActiveAccount = _ref.read(activeAccountProvider); // <-- 删除这行
    // if (currentActiveAccount == null) { // <-- 删除这部分检查，因为参数是必需的
    //   _ref.read(analysisLogProvider.notifier).state = ['Error: No active account selected.'];
    //   throw Exception('No active account selected.');
    // }

    _ref.read(analysisLogProvider.notifier).state = [];

    void logCallback(String message) {
      _ref
          .read(analysisLogProvider.notifier)
          .update((state) => [...state, message]);
    }

    logCallback('Initializing DataProcessor...');
    final dataProcessor = DataProcessor(
      database: _database,
      apiServiceGql: _apiService,
      apiServiceV1: _apiServiceV1,
      ownerAccount: accountToProcess, // <-- 使用传入的参数
      logCallback: logCallback,
    );

    try {
      // 使用 accountToProcess.id 而不是 currentActiveAccount.id (如果之前用了的话)
      await dataProcessor.runFullProcess();
      await loadAccounts(); // 保持不变
      logCallback('Process finished successfully.');
    } catch (e, s) {
      logCallback(
        '!!! PROCESS FAILED for account ${accountToProcess.id}: $e',
      ); // 可以在日志中加入 ID
      logCallback('Stacktrace: $s');
      rethrow;
    }
  }

  // --- 新增结束 ---
  Future<List<RefreshResult>> refreshAllAccountProfiles(
    List<Account> accounts,
  ) async {
    final semaphore = Semaphore(5);
    final group = FutureGroup<RefreshResult>();

    print(
      "AccountsNotifier: Starting refresh for ${accounts.length} accounts with concurrency limit 5...",
    );

    for (final account in accounts) {
      group.add(
        Future(() async {
          await semaphore.acquire();
          try {
            print("AccountsNotifier: Refreshing profile for ${account.id}...");
            await _refreshSingleAccountProfile(account);
            print("AccountsNotifier: Refresh successful for ${account.id}.");
            return RefreshResult(accountId: account.id, success: true);
          } catch (e) {
            print("AccountsNotifier: Refresh failed for ${account.id}: $e");
            return RefreshResult(
              accountId: account.id,
              success: false,
              error: e.toString(),
            );
          } finally {
            semaphore.release();
          }
        }),
      );
    }

    group.close();
    final results = await group.future;
    print("AccountsNotifier: Refresh process completed.");
    return results;
  }

  Future<void> _refreshSingleAccountProfile(Account account) async {
    String? name;
    String? screenName;
    String? avatarUrl;
    String? bannerUrl;
    String? bio;
    String? location;
    String? link;
    String? joinTime;
    int followersCount = 0;
    int followingCount = 0;
    int statusesCount = 0;
    int mediaCount = 0;
    int favouritesCount = 0;
    int listedCount = 0;
    String rawJsonString = '{}';

    try {
      final Map<String, dynamic> userProfileJson = await _apiService
          .getUserByRestId(account.id, account.cookie);
      rawJsonString = jsonEncode(userProfileJson);
      final result = userProfileJson['data']?['user']?['result'];

      if (result != null &&
          result is Map<String, dynamic> &&
          result['__typename'] == 'User') {
        final core = result['core'];
        final legacy = result['legacy'];
        if (core != null && core is Map<String, dynamic>) {
          name = core['name'] as String?;
          screenName = core['screen_name'] as String?;
          avatarUrl = (result['avatar']['image_url'] as String?)?.replaceFirst(
            '_normal',
            '_400x400',
          );
          joinTime = core['created_at'] as String?;
        }
        if (legacy != null && legacy is Map<String, dynamic>) {
          bio = legacy['description'] as String?;
          followersCount = legacy['followers_count'] as int? ?? 0;
          followingCount = legacy['friends_count'] as int? ?? 0;
          final String? tcoUrl = legacy['url'] as String?;
          String? finalLink = tcoUrl;
          try {
            final entities = legacy['entities'] as Map<String, dynamic>?;
            final urlBlock = entities?['url'] as Map<String, dynamic>?;
            final urlsList = urlBlock?['urls'] as List<dynamic>?;
            if (tcoUrl != null && urlsList != null) {
              for (final item in urlsList) {
                final urlMap = item as Map<String, dynamic>?;
                if (urlMap != null && urlMap['url'] == tcoUrl) {
                  finalLink = urlMap['expanded_url'] as String?;
                  break;
                }
              }
            }
          } catch (e) {
            /* Fallback handled */
          }
          link = finalLink;
          bannerUrl = legacy['profile_banner_url'] as String?;
          statusesCount = legacy['statuses_count'] as int? ?? 0;
          mediaCount = legacy['media_count'] as int? ?? 0;
          favouritesCount = legacy['favourites_count'] as int? ?? 0;
          listedCount = legacy['listed_count'] as int? ?? 0;
        }
        final locationMap = result['location'] as Map<String, dynamic>?;
        location = locationMap?['location'] as String?;
      } else {
        throw Exception('API returned invalid user data.');
      }

      await _database.transaction(() async {
        final oldProfile = await (_database.select(
          _database.loggedAccounts,
        )..where((tbl) => tbl.id.equals(account.id))).getSingleOrNull();
        final oldJsonString = oldProfile?.latestRawJson;
        final diffString = calculateReverseDiff(rawJsonString, oldJsonString);

        final companion = LoggedAccountsCompanion(
          id: Value(account.id),
          name: Value(name),
          screenName: Value(screenName),
          avatarUrl: Value(avatarUrl),
          bannerUrl: Value(bannerUrl),
          bio: Value(bio),
          location: Value(location),
          link: Value(link),
          joinTime: Value(joinTime),
          followersCount: Value(followersCount),
          followingCount: Value(followingCount),
          statusesCount: Value(statusesCount),
          mediaCount: Value(mediaCount),
          favouritesCount: Value(favouritesCount),
          listedCount: Value(listedCount),
          latestRawJson: Value(rawJsonString),
          avatarLocalPath: oldProfile?.avatarLocalPath == null
              ? const Value.absent()
              : Value(oldProfile!.avatarLocalPath),
          bannerLocalPath: oldProfile?.bannerLocalPath == null
              ? const Value.absent()
              : Value(oldProfile!.bannerLocalPath),
        );

        await _database
            .into(_database.loggedAccounts)
            .insert(companion, mode: InsertMode.replace);

        if (diffString != null && diffString.isNotEmpty) {
          final historyCompanion = AccountProfileHistoryCompanion(
            ownerId: Value(account.id),
            reverseDiffJson: Value(diffString),
            timestamp: Value(DateTime.now()),
          );
          await _database
              .into(_database.accountProfileHistory)
              .insert(historyCompanion);
          print(
            "AccountsNotifier: Inserted profile history for ${account.id} during refresh.",
          );
        }
      });
    } catch (e) {
      print("AccountsNotifier: Error refreshing profile for ${account.id}: $e");
      rethrow;
    }
  }
}


### FILE: ./providers/settings_provider.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart'; // 导入 Riverpod
import '../models/app_settings.dart'; // 导入模型
import '../services/settings_service.dart'; // 导入服务

// 提供 SettingsService 实例的 Provider
final settingsServiceProvider = Provider((ref) => SettingsService());

// 用于管理 AppSettings 状态并通知变化的 StateNotifierProvider
final settingsProvider =
    StateNotifierProvider<SettingsNotifier, AsyncValue<AppSettings>>((ref) {
  // 依赖 settingsServiceProvider 来获取服务实例
  final service = ref.watch(settingsServiceProvider);
  // 创建 SettingsNotifier 并传入服务
  return SettingsNotifier(service);
});

// StateNotifier 类，包含加载和更新设置的逻辑
class SettingsNotifier extends StateNotifier<AsyncValue<AppSettings>> {
  final SettingsService _settingsService;

  // 构造函数，初始化状态为加载中，并立即开始加载设置
  SettingsNotifier(this._settingsService) : super(const AsyncValue.loading()) {
    _load(); 
  }

  /// 异步加载设置并更新状态
  Future<void> _load() async {
    state = const AsyncValue.loading(); // 设置为加载中状态
    try {
      final settings = await _settingsService.loadSettings(); // 调用服务加载
      state = AsyncValue.data(settings); // 加载成功，更新状态为数据
    } catch (e, s) {
      state = AsyncValue.error(e, s); // 加载失败，更新状态为错误
      print('加载设置失败: $e');
    }
  }

  /// 更新应用语言设置
  Future<void> updateLocale(Locale? newLocale) async {
    // 获取当前状态的数据，如果状态是加载中或错误，则使用默认设置
    final currentSettings = state.value ?? AppSettings(); 

    // 使用 copyWith 创建包含新语言的设置对象
    final newState = currentSettings.copyWith(locale: newLocale);

    // 立即乐观地更新 UI 状态为新数据
    state = AsyncValue.data(newState);

    // 调用服务将新状态持久化保存
    try {
      await _settingsService.saveSettings(newState);
    } catch (e, s) {
      // 如果保存失败，将状态设置为错误，并打印日志
      state = AsyncValue.error('保存语言设置失败: $e', s);
      // （可选）可以考虑重新加载之前的状态：await _load();
      print('保存语言设置失败: $e');
    }
  }

  // 未来可以在这里添加更新其他设置的方法
  // Future<void> updateDarkMode(bool isDark) async { ... }
}

### FILE: ./services/database.dart
// --- 1. 导入必要的库 ---
import 'dart:io'; // 用于文件系统操作
import 'package:drift/drift.dart'; // Drift 核心
import 'package:drift/native.dart'; // Drift 的 SQLite (native) 引擎
import 'package:path_provider/path_provider.dart'; // 查找文件路径
import 'package:path/path.dart' as p; // 拼接文件路径

// --- 2. 告诉 Drift 这个文件需要一个“伙伴”文件 ---
part 'database.g.dart'; // 这个文件还不存在，代码生成器会自动创建它

// --- 3. 定义你的表 ---

// 表 1: LoggedAccounts (你的 "LoggedAccounts")
// 存储你已登录账号的个人资料
@DataClassName('LoggedAccount') // 定义生成的数据类名称
class LoggedAccounts extends Table {
  // Twitter User ID (rest_id), 我们用它作为主键
  TextColumn get id => text()();

  // 你在图中提到的 "UI 显示值"
  TextColumn get name => text().nullable()();
  TextColumn get screenName => text().nullable()();
  TextColumn get bio => text().nullable()();
  TextColumn get location => text().nullable()();
  TextColumn get link => text().nullable()();
  TextColumn get joinTime => text().nullable()();

  // 统计数值
  IntColumn get followersCount => integer().withDefault(const Constant(0))();
  IntColumn get followingCount => integer().withDefault(const Constant(0))();
  IntColumn get statusesCount => integer().withDefault(const Constant(0))();
  IntColumn get mediaCount => integer().withDefault(const Constant(0))();
  IntColumn get favouritesCount => integer().withDefault(const Constant(0))();
  IntColumn get listedCount => integer().withDefault(const Constant(0))();

  // 存储最新的 GraphQL JSON
  TextColumn get latestRawJson => text().named('latest_raw_json').nullable()();

  // 图片存储路径
  TextColumn get avatarUrl => text().nullable()(); // 原始网络 URL
  TextColumn get bannerUrl => text().nullable()(); // 原始网络 URL
  TextColumn get avatarLocalPath =>
      text().named('avatar_local_path').nullable()();
  TextColumn get bannerLocalPath =>
      text().named('banner_local_path').nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// 表 2: AccountProfileHistory (你的 JSON DIFF 表)
// 存储 LoggedAccounts 的历史版本（反向差异）
@DataClassName('AccountProfileHistoryEntry')
class AccountProfileHistory extends Table {
  IntColumn get id => integer().autoIncrement()();

  // 历史归属于哪个账号
  TextColumn get ownerId => text()
      .named('owner_id')
      .references(LoggedAccounts, #id, onDelete: KeyAction.cascade)();

  // 存储“反向差异”补丁
  TextColumn get reverseDiffJson => text().named('reverse_diff_json')();

  DateTimeColumn get timestamp => dateTime()();
}

// 表 3: FollowUsers (你的 "FollowUsers")
// 存储每个已登录账号的“网络池”（关注者+正在关注）
@DataClassName('FollowUser')
class FollowUsers extends Table {
  // 归属于哪个已登录账号
  TextColumn get ownerId => text()
      .named('owner_id')
      .references(LoggedAccounts, #id, onDelete: KeyAction.cascade)();

  // 列表中的用户 ID
  TextColumn get userId => text().named('user_id')();

  // 存储 API 1.1 的最新 JSON
  TextColumn get latestRawJson => text().named('latest_raw_json').nullable()();

  // "UI 显示值"，用于快速加载列表
  TextColumn get name => text().nullable()();
  TextColumn get screenName => text().nullable()();
  TextColumn get avatarUrl => text().nullable()(); // API 1.1 提供的头像 URL
  TextColumn get bio => text().nullable()(); // (API 1.1 里的 description)

  // 图片存储路径
  TextColumn get avatarLocalPath =>
      text().named('avatar_local_path').nullable()();

  // 关键状态字段，用于计算差异
  BoolColumn get isFollower => boolean().withDefault(const Constant(false))();
  BoolColumn get isFollowing => boolean().withDefault(const Constant(false))();

  // 复合主键：(ownerId, userId) 共同保证唯一性
  @override
  Set<Column> get primaryKey => {ownerId, userId};
}

// 表 4: FollowUsersHistory (你的 JSON DIFF 表)
// 存储 FollowUsers 的历史版本（反向差异）
@DataClassName('FollowUserHistoryEntry')
class FollowUsersHistory extends Table {
  IntColumn get id => integer().autoIncrement()();

  // 历史归属于哪个账号的哪个用户
  TextColumn get ownerId => text().named('owner_id')();
  TextColumn get userId => text().named('user_id')();

  // 存储“反向差异”补丁
  TextColumn get reverseDiffJson => text().named('reverse_diff_json')();

  DateTimeColumn get timestamp => dateTime()();

  // 外键，指向 FollowUsers 表
  @override
  List<String> get customConstraints => [
    'FOREIGN KEY(owner_id, user_id) REFERENCES follow_users(owner_id, user_id) ON DELETE CASCADE',
  ];
}

// 表 5: ChangeReport (你的 "Change Report")
// 存储已计算出的“关系变更索引”
@DataClassName('ChangeReportEntry')
class ChangeReports extends Table {
  IntColumn get id => integer().autoIncrement()();

  // 报告归属于哪个账号
  TextColumn get ownerId => text()
      .named('owner_id')
      .references(LoggedAccounts, #id, onDelete: KeyAction.cascade)();

  // 发生变更的用户 ID
  TextColumn get userId => text().named('user_id')();

  // 变更类型 (即你的列表名)
  // e.g., "normal_unfollowed", "mutual_unfollowed", "new_follower", etc. [cite: 529-539]
  TextColumn get changeType => text().named('change_type')();

  DateTimeColumn get timestamp => dateTime()();
}

// --- 4. 定义数据库主类 ---
@DriftDatabase(
  tables: [
    LoggedAccounts,
    AccountProfileHistory,
    FollowUsers,
    FollowUsersHistory,
    ChangeReports,
  ],
)
@DriftDatabase(
  tables: [
    LoggedAccounts,
    AccountProfileHistory,
    FollowUsers,
    FollowUsersHistory,
    ChangeReports,
  ],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 1;

  // --- 新增数据库操作方法 ---

  /// 查询指定 ownerId 的所有网络关系
  Future<List<FollowUser>> getNetworkRelationships(String ownerId) async {
    return (select(
      followUsers,
    )..where((tbl) => tbl.ownerId.equals(ownerId))).get();
    // select(followUsers) 开始一个查询，目标是 followUsers 表
    // ..where(...) 添加一个条件：只选择 ownerId 匹配的行
    // .get() 执行查询并返回 List<FollowUser> (FollowUser 是 Drift 自动生成的数据类)
  }

  /// 批量更新或插入网络关系 (Upsert)
  Future<void> batchUpsertNetworkRelationships(
    List<FollowUsersCompanion> companions,
  ) async {
    await batch((batch) {
      // batch.insertAll 方法用于批量插入
      // mode: InsertMode.replace 表示如果主键 (ownerId, userId) 已存在，则替换旧行
      batch.insertAll(followUsers, companions, mode: InsertMode.replace);
    });
  }

  /// 批量删除指定 ownerId 下的特定 userIds 的网络关系
  Future<void> deleteNetworkRelationships(
    String ownerId,
    List<String> userIdsToRemove,
  ) async {
    // delete 方法用于删除操作
    // ..where(...) 指定条件：ownerId 匹配 并且 userId 在 userIdsToRemove 列表中
    await (delete(followUsers)..where(
          (tbl) =>
              tbl.ownerId.equals(ownerId) & tbl.userId.isIn(userIdsToRemove),
        ))
        .go();
    // .go() 执行删除操作
  }

  /// 批量插入关注用户历史记录
  Future<void> batchInsertFollowUsersHistory(
    List<FollowUsersHistoryCompanion> historyCompanions,
  ) async {
    await batch((batch) {
      // 历史记录通常只插入，不替换
      batch.insertAll(followUsersHistory, historyCompanions);
    });
  }

  /// 替换指定 ownerId 的所有变更报告
  Future<void> replaceChangeReport(
    String ownerId,
    List<ChangeReportsCompanion> reportCompanions,
  ) async {
    // 使用事务确保原子性：要么都成功，要么都失败
    await transaction(() async {
      // 1. 删除该 ownerId 的所有旧报告
      await (delete(
        changeReports,
      )..where((tbl) => tbl.ownerId.equals(ownerId))).go();

      // 2. 批量插入新的报告
      await batch((batch) {
        batch.insertAll(changeReports, reportCompanions);
      });
    });
  }

  // --- 新增结束 ---
} // <-- AppDatabase 类的结束括号

// ... (_openConnection 函数保持不变)

// --- 5. 定义数据库连接 ---
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'autonitor_data.db')); //
    return NativeDatabase(file);
  });
}


### FILE: ./services/database.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $LoggedAccountsTable extends LoggedAccounts
    with TableInfo<$LoggedAccountsTable, LoggedAccount> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LoggedAccountsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _screenNameMeta = const VerificationMeta(
    'screenName',
  );
  @override
  late final GeneratedColumn<String> screenName = GeneratedColumn<String>(
    'screen_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bioMeta = const VerificationMeta('bio');
  @override
  late final GeneratedColumn<String> bio = GeneratedColumn<String>(
    'bio',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _locationMeta = const VerificationMeta(
    'location',
  );
  @override
  late final GeneratedColumn<String> location = GeneratedColumn<String>(
    'location',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _linkMeta = const VerificationMeta('link');
  @override
  late final GeneratedColumn<String> link = GeneratedColumn<String>(
    'link',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _joinTimeMeta = const VerificationMeta(
    'joinTime',
  );
  @override
  late final GeneratedColumn<String> joinTime = GeneratedColumn<String>(
    'join_time',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _followersCountMeta = const VerificationMeta(
    'followersCount',
  );
  @override
  late final GeneratedColumn<int> followersCount = GeneratedColumn<int>(
    'followers_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _followingCountMeta = const VerificationMeta(
    'followingCount',
  );
  @override
  late final GeneratedColumn<int> followingCount = GeneratedColumn<int>(
    'following_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _statusesCountMeta = const VerificationMeta(
    'statusesCount',
  );
  @override
  late final GeneratedColumn<int> statusesCount = GeneratedColumn<int>(
    'statuses_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _mediaCountMeta = const VerificationMeta(
    'mediaCount',
  );
  @override
  late final GeneratedColumn<int> mediaCount = GeneratedColumn<int>(
    'media_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _favouritesCountMeta = const VerificationMeta(
    'favouritesCount',
  );
  @override
  late final GeneratedColumn<int> favouritesCount = GeneratedColumn<int>(
    'favourites_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _listedCountMeta = const VerificationMeta(
    'listedCount',
  );
  @override
  late final GeneratedColumn<int> listedCount = GeneratedColumn<int>(
    'listed_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _latestRawJsonMeta = const VerificationMeta(
    'latestRawJson',
  );
  @override
  late final GeneratedColumn<String> latestRawJson = GeneratedColumn<String>(
    'latest_raw_json',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarUrlMeta = const VerificationMeta(
    'avatarUrl',
  );
  @override
  late final GeneratedColumn<String> avatarUrl = GeneratedColumn<String>(
    'avatar_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bannerUrlMeta = const VerificationMeta(
    'bannerUrl',
  );
  @override
  late final GeneratedColumn<String> bannerUrl = GeneratedColumn<String>(
    'banner_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarLocalPathMeta = const VerificationMeta(
    'avatarLocalPath',
  );
  @override
  late final GeneratedColumn<String> avatarLocalPath = GeneratedColumn<String>(
    'avatar_local_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bannerLocalPathMeta = const VerificationMeta(
    'bannerLocalPath',
  );
  @override
  late final GeneratedColumn<String> bannerLocalPath = GeneratedColumn<String>(
    'banner_local_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    screenName,
    bio,
    location,
    link,
    joinTime,
    followersCount,
    followingCount,
    statusesCount,
    mediaCount,
    favouritesCount,
    listedCount,
    latestRawJson,
    avatarUrl,
    bannerUrl,
    avatarLocalPath,
    bannerLocalPath,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'logged_accounts';
  @override
  VerificationContext validateIntegrity(
    Insertable<LoggedAccount> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('screen_name')) {
      context.handle(
        _screenNameMeta,
        screenName.isAcceptableOrUnknown(data['screen_name']!, _screenNameMeta),
      );
    }
    if (data.containsKey('bio')) {
      context.handle(
        _bioMeta,
        bio.isAcceptableOrUnknown(data['bio']!, _bioMeta),
      );
    }
    if (data.containsKey('location')) {
      context.handle(
        _locationMeta,
        location.isAcceptableOrUnknown(data['location']!, _locationMeta),
      );
    }
    if (data.containsKey('link')) {
      context.handle(
        _linkMeta,
        link.isAcceptableOrUnknown(data['link']!, _linkMeta),
      );
    }
    if (data.containsKey('join_time')) {
      context.handle(
        _joinTimeMeta,
        joinTime.isAcceptableOrUnknown(data['join_time']!, _joinTimeMeta),
      );
    }
    if (data.containsKey('followers_count')) {
      context.handle(
        _followersCountMeta,
        followersCount.isAcceptableOrUnknown(
          data['followers_count']!,
          _followersCountMeta,
        ),
      );
    }
    if (data.containsKey('following_count')) {
      context.handle(
        _followingCountMeta,
        followingCount.isAcceptableOrUnknown(
          data['following_count']!,
          _followingCountMeta,
        ),
      );
    }
    if (data.containsKey('statuses_count')) {
      context.handle(
        _statusesCountMeta,
        statusesCount.isAcceptableOrUnknown(
          data['statuses_count']!,
          _statusesCountMeta,
        ),
      );
    }
    if (data.containsKey('media_count')) {
      context.handle(
        _mediaCountMeta,
        mediaCount.isAcceptableOrUnknown(data['media_count']!, _mediaCountMeta),
      );
    }
    if (data.containsKey('favourites_count')) {
      context.handle(
        _favouritesCountMeta,
        favouritesCount.isAcceptableOrUnknown(
          data['favourites_count']!,
          _favouritesCountMeta,
        ),
      );
    }
    if (data.containsKey('listed_count')) {
      context.handle(
        _listedCountMeta,
        listedCount.isAcceptableOrUnknown(
          data['listed_count']!,
          _listedCountMeta,
        ),
      );
    }
    if (data.containsKey('latest_raw_json')) {
      context.handle(
        _latestRawJsonMeta,
        latestRawJson.isAcceptableOrUnknown(
          data['latest_raw_json']!,
          _latestRawJsonMeta,
        ),
      );
    }
    if (data.containsKey('avatar_url')) {
      context.handle(
        _avatarUrlMeta,
        avatarUrl.isAcceptableOrUnknown(data['avatar_url']!, _avatarUrlMeta),
      );
    }
    if (data.containsKey('banner_url')) {
      context.handle(
        _bannerUrlMeta,
        bannerUrl.isAcceptableOrUnknown(data['banner_url']!, _bannerUrlMeta),
      );
    }
    if (data.containsKey('avatar_local_path')) {
      context.handle(
        _avatarLocalPathMeta,
        avatarLocalPath.isAcceptableOrUnknown(
          data['avatar_local_path']!,
          _avatarLocalPathMeta,
        ),
      );
    }
    if (data.containsKey('banner_local_path')) {
      context.handle(
        _bannerLocalPathMeta,
        bannerLocalPath.isAcceptableOrUnknown(
          data['banner_local_path']!,
          _bannerLocalPathMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  LoggedAccount map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LoggedAccount(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      screenName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}screen_name'],
      ),
      bio: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bio'],
      ),
      location: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location'],
      ),
      link: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}link'],
      ),
      joinTime: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}join_time'],
      ),
      followersCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}followers_count'],
      )!,
      followingCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}following_count'],
      )!,
      statusesCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}statuses_count'],
      )!,
      mediaCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}media_count'],
      )!,
      favouritesCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}favourites_count'],
      )!,
      listedCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}listed_count'],
      )!,
      latestRawJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}latest_raw_json'],
      ),
      avatarUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_url'],
      ),
      bannerUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}banner_url'],
      ),
      avatarLocalPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_local_path'],
      ),
      bannerLocalPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}banner_local_path'],
      ),
    );
  }

  @override
  $LoggedAccountsTable createAlias(String alias) {
    return $LoggedAccountsTable(attachedDatabase, alias);
  }
}

class LoggedAccount extends DataClass implements Insertable<LoggedAccount> {
  final String id;
  final String? name;
  final String? screenName;
  final String? bio;
  final String? location;
  final String? link;
  final String? joinTime;
  final int followersCount;
  final int followingCount;
  final int statusesCount;
  final int mediaCount;
  final int favouritesCount;
  final int listedCount;
  final String? latestRawJson;
  final String? avatarUrl;
  final String? bannerUrl;
  final String? avatarLocalPath;
  final String? bannerLocalPath;
  const LoggedAccount({
    required this.id,
    this.name,
    this.screenName,
    this.bio,
    this.location,
    this.link,
    this.joinTime,
    required this.followersCount,
    required this.followingCount,
    required this.statusesCount,
    required this.mediaCount,
    required this.favouritesCount,
    required this.listedCount,
    this.latestRawJson,
    this.avatarUrl,
    this.bannerUrl,
    this.avatarLocalPath,
    this.bannerLocalPath,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || screenName != null) {
      map['screen_name'] = Variable<String>(screenName);
    }
    if (!nullToAbsent || bio != null) {
      map['bio'] = Variable<String>(bio);
    }
    if (!nullToAbsent || location != null) {
      map['location'] = Variable<String>(location);
    }
    if (!nullToAbsent || link != null) {
      map['link'] = Variable<String>(link);
    }
    if (!nullToAbsent || joinTime != null) {
      map['join_time'] = Variable<String>(joinTime);
    }
    map['followers_count'] = Variable<int>(followersCount);
    map['following_count'] = Variable<int>(followingCount);
    map['statuses_count'] = Variable<int>(statusesCount);
    map['media_count'] = Variable<int>(mediaCount);
    map['favourites_count'] = Variable<int>(favouritesCount);
    map['listed_count'] = Variable<int>(listedCount);
    if (!nullToAbsent || latestRawJson != null) {
      map['latest_raw_json'] = Variable<String>(latestRawJson);
    }
    if (!nullToAbsent || avatarUrl != null) {
      map['avatar_url'] = Variable<String>(avatarUrl);
    }
    if (!nullToAbsent || bannerUrl != null) {
      map['banner_url'] = Variable<String>(bannerUrl);
    }
    if (!nullToAbsent || avatarLocalPath != null) {
      map['avatar_local_path'] = Variable<String>(avatarLocalPath);
    }
    if (!nullToAbsent || bannerLocalPath != null) {
      map['banner_local_path'] = Variable<String>(bannerLocalPath);
    }
    return map;
  }

  LoggedAccountsCompanion toCompanion(bool nullToAbsent) {
    return LoggedAccountsCompanion(
      id: Value(id),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      screenName: screenName == null && nullToAbsent
          ? const Value.absent()
          : Value(screenName),
      bio: bio == null && nullToAbsent ? const Value.absent() : Value(bio),
      location: location == null && nullToAbsent
          ? const Value.absent()
          : Value(location),
      link: link == null && nullToAbsent ? const Value.absent() : Value(link),
      joinTime: joinTime == null && nullToAbsent
          ? const Value.absent()
          : Value(joinTime),
      followersCount: Value(followersCount),
      followingCount: Value(followingCount),
      statusesCount: Value(statusesCount),
      mediaCount: Value(mediaCount),
      favouritesCount: Value(favouritesCount),
      listedCount: Value(listedCount),
      latestRawJson: latestRawJson == null && nullToAbsent
          ? const Value.absent()
          : Value(latestRawJson),
      avatarUrl: avatarUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarUrl),
      bannerUrl: bannerUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(bannerUrl),
      avatarLocalPath: avatarLocalPath == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarLocalPath),
      bannerLocalPath: bannerLocalPath == null && nullToAbsent
          ? const Value.absent()
          : Value(bannerLocalPath),
    );
  }

  factory LoggedAccount.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LoggedAccount(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String?>(json['name']),
      screenName: serializer.fromJson<String?>(json['screenName']),
      bio: serializer.fromJson<String?>(json['bio']),
      location: serializer.fromJson<String?>(json['location']),
      link: serializer.fromJson<String?>(json['link']),
      joinTime: serializer.fromJson<String?>(json['joinTime']),
      followersCount: serializer.fromJson<int>(json['followersCount']),
      followingCount: serializer.fromJson<int>(json['followingCount']),
      statusesCount: serializer.fromJson<int>(json['statusesCount']),
      mediaCount: serializer.fromJson<int>(json['mediaCount']),
      favouritesCount: serializer.fromJson<int>(json['favouritesCount']),
      listedCount: serializer.fromJson<int>(json['listedCount']),
      latestRawJson: serializer.fromJson<String?>(json['latestRawJson']),
      avatarUrl: serializer.fromJson<String?>(json['avatarUrl']),
      bannerUrl: serializer.fromJson<String?>(json['bannerUrl']),
      avatarLocalPath: serializer.fromJson<String?>(json['avatarLocalPath']),
      bannerLocalPath: serializer.fromJson<String?>(json['bannerLocalPath']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String?>(name),
      'screenName': serializer.toJson<String?>(screenName),
      'bio': serializer.toJson<String?>(bio),
      'location': serializer.toJson<String?>(location),
      'link': serializer.toJson<String?>(link),
      'joinTime': serializer.toJson<String?>(joinTime),
      'followersCount': serializer.toJson<int>(followersCount),
      'followingCount': serializer.toJson<int>(followingCount),
      'statusesCount': serializer.toJson<int>(statusesCount),
      'mediaCount': serializer.toJson<int>(mediaCount),
      'favouritesCount': serializer.toJson<int>(favouritesCount),
      'listedCount': serializer.toJson<int>(listedCount),
      'latestRawJson': serializer.toJson<String?>(latestRawJson),
      'avatarUrl': serializer.toJson<String?>(avatarUrl),
      'bannerUrl': serializer.toJson<String?>(bannerUrl),
      'avatarLocalPath': serializer.toJson<String?>(avatarLocalPath),
      'bannerLocalPath': serializer.toJson<String?>(bannerLocalPath),
    };
  }

  LoggedAccount copyWith({
    String? id,
    Value<String?> name = const Value.absent(),
    Value<String?> screenName = const Value.absent(),
    Value<String?> bio = const Value.absent(),
    Value<String?> location = const Value.absent(),
    Value<String?> link = const Value.absent(),
    Value<String?> joinTime = const Value.absent(),
    int? followersCount,
    int? followingCount,
    int? statusesCount,
    int? mediaCount,
    int? favouritesCount,
    int? listedCount,
    Value<String?> latestRawJson = const Value.absent(),
    Value<String?> avatarUrl = const Value.absent(),
    Value<String?> bannerUrl = const Value.absent(),
    Value<String?> avatarLocalPath = const Value.absent(),
    Value<String?> bannerLocalPath = const Value.absent(),
  }) => LoggedAccount(
    id: id ?? this.id,
    name: name.present ? name.value : this.name,
    screenName: screenName.present ? screenName.value : this.screenName,
    bio: bio.present ? bio.value : this.bio,
    location: location.present ? location.value : this.location,
    link: link.present ? link.value : this.link,
    joinTime: joinTime.present ? joinTime.value : this.joinTime,
    followersCount: followersCount ?? this.followersCount,
    followingCount: followingCount ?? this.followingCount,
    statusesCount: statusesCount ?? this.statusesCount,
    mediaCount: mediaCount ?? this.mediaCount,
    favouritesCount: favouritesCount ?? this.favouritesCount,
    listedCount: listedCount ?? this.listedCount,
    latestRawJson: latestRawJson.present
        ? latestRawJson.value
        : this.latestRawJson,
    avatarUrl: avatarUrl.present ? avatarUrl.value : this.avatarUrl,
    bannerUrl: bannerUrl.present ? bannerUrl.value : this.bannerUrl,
    avatarLocalPath: avatarLocalPath.present
        ? avatarLocalPath.value
        : this.avatarLocalPath,
    bannerLocalPath: bannerLocalPath.present
        ? bannerLocalPath.value
        : this.bannerLocalPath,
  );
  LoggedAccount copyWithCompanion(LoggedAccountsCompanion data) {
    return LoggedAccount(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      screenName: data.screenName.present
          ? data.screenName.value
          : this.screenName,
      bio: data.bio.present ? data.bio.value : this.bio,
      location: data.location.present ? data.location.value : this.location,
      link: data.link.present ? data.link.value : this.link,
      joinTime: data.joinTime.present ? data.joinTime.value : this.joinTime,
      followersCount: data.followersCount.present
          ? data.followersCount.value
          : this.followersCount,
      followingCount: data.followingCount.present
          ? data.followingCount.value
          : this.followingCount,
      statusesCount: data.statusesCount.present
          ? data.statusesCount.value
          : this.statusesCount,
      mediaCount: data.mediaCount.present
          ? data.mediaCount.value
          : this.mediaCount,
      favouritesCount: data.favouritesCount.present
          ? data.favouritesCount.value
          : this.favouritesCount,
      listedCount: data.listedCount.present
          ? data.listedCount.value
          : this.listedCount,
      latestRawJson: data.latestRawJson.present
          ? data.latestRawJson.value
          : this.latestRawJson,
      avatarUrl: data.avatarUrl.present ? data.avatarUrl.value : this.avatarUrl,
      bannerUrl: data.bannerUrl.present ? data.bannerUrl.value : this.bannerUrl,
      avatarLocalPath: data.avatarLocalPath.present
          ? data.avatarLocalPath.value
          : this.avatarLocalPath,
      bannerLocalPath: data.bannerLocalPath.present
          ? data.bannerLocalPath.value
          : this.bannerLocalPath,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LoggedAccount(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('screenName: $screenName, ')
          ..write('bio: $bio, ')
          ..write('location: $location, ')
          ..write('link: $link, ')
          ..write('joinTime: $joinTime, ')
          ..write('followersCount: $followersCount, ')
          ..write('followingCount: $followingCount, ')
          ..write('statusesCount: $statusesCount, ')
          ..write('mediaCount: $mediaCount, ')
          ..write('favouritesCount: $favouritesCount, ')
          ..write('listedCount: $listedCount, ')
          ..write('latestRawJson: $latestRawJson, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('bannerUrl: $bannerUrl, ')
          ..write('avatarLocalPath: $avatarLocalPath, ')
          ..write('bannerLocalPath: $bannerLocalPath')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    screenName,
    bio,
    location,
    link,
    joinTime,
    followersCount,
    followingCount,
    statusesCount,
    mediaCount,
    favouritesCount,
    listedCount,
    latestRawJson,
    avatarUrl,
    bannerUrl,
    avatarLocalPath,
    bannerLocalPath,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LoggedAccount &&
          other.id == this.id &&
          other.name == this.name &&
          other.screenName == this.screenName &&
          other.bio == this.bio &&
          other.location == this.location &&
          other.link == this.link &&
          other.joinTime == this.joinTime &&
          other.followersCount == this.followersCount &&
          other.followingCount == this.followingCount &&
          other.statusesCount == this.statusesCount &&
          other.mediaCount == this.mediaCount &&
          other.favouritesCount == this.favouritesCount &&
          other.listedCount == this.listedCount &&
          other.latestRawJson == this.latestRawJson &&
          other.avatarUrl == this.avatarUrl &&
          other.bannerUrl == this.bannerUrl &&
          other.avatarLocalPath == this.avatarLocalPath &&
          other.bannerLocalPath == this.bannerLocalPath);
}

class LoggedAccountsCompanion extends UpdateCompanion<LoggedAccount> {
  final Value<String> id;
  final Value<String?> name;
  final Value<String?> screenName;
  final Value<String?> bio;
  final Value<String?> location;
  final Value<String?> link;
  final Value<String?> joinTime;
  final Value<int> followersCount;
  final Value<int> followingCount;
  final Value<int> statusesCount;
  final Value<int> mediaCount;
  final Value<int> favouritesCount;
  final Value<int> listedCount;
  final Value<String?> latestRawJson;
  final Value<String?> avatarUrl;
  final Value<String?> bannerUrl;
  final Value<String?> avatarLocalPath;
  final Value<String?> bannerLocalPath;
  final Value<int> rowid;
  const LoggedAccountsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.screenName = const Value.absent(),
    this.bio = const Value.absent(),
    this.location = const Value.absent(),
    this.link = const Value.absent(),
    this.joinTime = const Value.absent(),
    this.followersCount = const Value.absent(),
    this.followingCount = const Value.absent(),
    this.statusesCount = const Value.absent(),
    this.mediaCount = const Value.absent(),
    this.favouritesCount = const Value.absent(),
    this.listedCount = const Value.absent(),
    this.latestRawJson = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.bannerUrl = const Value.absent(),
    this.avatarLocalPath = const Value.absent(),
    this.bannerLocalPath = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LoggedAccountsCompanion.insert({
    required String id,
    this.name = const Value.absent(),
    this.screenName = const Value.absent(),
    this.bio = const Value.absent(),
    this.location = const Value.absent(),
    this.link = const Value.absent(),
    this.joinTime = const Value.absent(),
    this.followersCount = const Value.absent(),
    this.followingCount = const Value.absent(),
    this.statusesCount = const Value.absent(),
    this.mediaCount = const Value.absent(),
    this.favouritesCount = const Value.absent(),
    this.listedCount = const Value.absent(),
    this.latestRawJson = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.bannerUrl = const Value.absent(),
    this.avatarLocalPath = const Value.absent(),
    this.bannerLocalPath = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<LoggedAccount> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? screenName,
    Expression<String>? bio,
    Expression<String>? location,
    Expression<String>? link,
    Expression<String>? joinTime,
    Expression<int>? followersCount,
    Expression<int>? followingCount,
    Expression<int>? statusesCount,
    Expression<int>? mediaCount,
    Expression<int>? favouritesCount,
    Expression<int>? listedCount,
    Expression<String>? latestRawJson,
    Expression<String>? avatarUrl,
    Expression<String>? bannerUrl,
    Expression<String>? avatarLocalPath,
    Expression<String>? bannerLocalPath,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (screenName != null) 'screen_name': screenName,
      if (bio != null) 'bio': bio,
      if (location != null) 'location': location,
      if (link != null) 'link': link,
      if (joinTime != null) 'join_time': joinTime,
      if (followersCount != null) 'followers_count': followersCount,
      if (followingCount != null) 'following_count': followingCount,
      if (statusesCount != null) 'statuses_count': statusesCount,
      if (mediaCount != null) 'media_count': mediaCount,
      if (favouritesCount != null) 'favourites_count': favouritesCount,
      if (listedCount != null) 'listed_count': listedCount,
      if (latestRawJson != null) 'latest_raw_json': latestRawJson,
      if (avatarUrl != null) 'avatar_url': avatarUrl,
      if (bannerUrl != null) 'banner_url': bannerUrl,
      if (avatarLocalPath != null) 'avatar_local_path': avatarLocalPath,
      if (bannerLocalPath != null) 'banner_local_path': bannerLocalPath,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LoggedAccountsCompanion copyWith({
    Value<String>? id,
    Value<String?>? name,
    Value<String?>? screenName,
    Value<String?>? bio,
    Value<String?>? location,
    Value<String?>? link,
    Value<String?>? joinTime,
    Value<int>? followersCount,
    Value<int>? followingCount,
    Value<int>? statusesCount,
    Value<int>? mediaCount,
    Value<int>? favouritesCount,
    Value<int>? listedCount,
    Value<String?>? latestRawJson,
    Value<String?>? avatarUrl,
    Value<String?>? bannerUrl,
    Value<String?>? avatarLocalPath,
    Value<String?>? bannerLocalPath,
    Value<int>? rowid,
  }) {
    return LoggedAccountsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      screenName: screenName ?? this.screenName,
      bio: bio ?? this.bio,
      location: location ?? this.location,
      link: link ?? this.link,
      joinTime: joinTime ?? this.joinTime,
      followersCount: followersCount ?? this.followersCount,
      followingCount: followingCount ?? this.followingCount,
      statusesCount: statusesCount ?? this.statusesCount,
      mediaCount: mediaCount ?? this.mediaCount,
      favouritesCount: favouritesCount ?? this.favouritesCount,
      listedCount: listedCount ?? this.listedCount,
      latestRawJson: latestRawJson ?? this.latestRawJson,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      bannerUrl: bannerUrl ?? this.bannerUrl,
      avatarLocalPath: avatarLocalPath ?? this.avatarLocalPath,
      bannerLocalPath: bannerLocalPath ?? this.bannerLocalPath,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (screenName.present) {
      map['screen_name'] = Variable<String>(screenName.value);
    }
    if (bio.present) {
      map['bio'] = Variable<String>(bio.value);
    }
    if (location.present) {
      map['location'] = Variable<String>(location.value);
    }
    if (link.present) {
      map['link'] = Variable<String>(link.value);
    }
    if (joinTime.present) {
      map['join_time'] = Variable<String>(joinTime.value);
    }
    if (followersCount.present) {
      map['followers_count'] = Variable<int>(followersCount.value);
    }
    if (followingCount.present) {
      map['following_count'] = Variable<int>(followingCount.value);
    }
    if (statusesCount.present) {
      map['statuses_count'] = Variable<int>(statusesCount.value);
    }
    if (mediaCount.present) {
      map['media_count'] = Variable<int>(mediaCount.value);
    }
    if (favouritesCount.present) {
      map['favourites_count'] = Variable<int>(favouritesCount.value);
    }
    if (listedCount.present) {
      map['listed_count'] = Variable<int>(listedCount.value);
    }
    if (latestRawJson.present) {
      map['latest_raw_json'] = Variable<String>(latestRawJson.value);
    }
    if (avatarUrl.present) {
      map['avatar_url'] = Variable<String>(avatarUrl.value);
    }
    if (bannerUrl.present) {
      map['banner_url'] = Variable<String>(bannerUrl.value);
    }
    if (avatarLocalPath.present) {
      map['avatar_local_path'] = Variable<String>(avatarLocalPath.value);
    }
    if (bannerLocalPath.present) {
      map['banner_local_path'] = Variable<String>(bannerLocalPath.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LoggedAccountsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('screenName: $screenName, ')
          ..write('bio: $bio, ')
          ..write('location: $location, ')
          ..write('link: $link, ')
          ..write('joinTime: $joinTime, ')
          ..write('followersCount: $followersCount, ')
          ..write('followingCount: $followingCount, ')
          ..write('statusesCount: $statusesCount, ')
          ..write('mediaCount: $mediaCount, ')
          ..write('favouritesCount: $favouritesCount, ')
          ..write('listedCount: $listedCount, ')
          ..write('latestRawJson: $latestRawJson, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('bannerUrl: $bannerUrl, ')
          ..write('avatarLocalPath: $avatarLocalPath, ')
          ..write('bannerLocalPath: $bannerLocalPath, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AccountProfileHistoryTable extends AccountProfileHistory
    with TableInfo<$AccountProfileHistoryTable, AccountProfileHistoryEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AccountProfileHistoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES logged_accounts (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _reverseDiffJsonMeta = const VerificationMeta(
    'reverseDiffJson',
  );
  @override
  late final GeneratedColumn<String> reverseDiffJson = GeneratedColumn<String>(
    'reverse_diff_json',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    ownerId,
    reverseDiffJson,
    timestamp,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'account_profile_history';
  @override
  VerificationContext validateIntegrity(
    Insertable<AccountProfileHistoryEntry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('reverse_diff_json')) {
      context.handle(
        _reverseDiffJsonMeta,
        reverseDiffJson.isAcceptableOrUnknown(
          data['reverse_diff_json']!,
          _reverseDiffJsonMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_reverseDiffJsonMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AccountProfileHistoryEntry map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AccountProfileHistoryEntry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      reverseDiffJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reverse_diff_json'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
    );
  }

  @override
  $AccountProfileHistoryTable createAlias(String alias) {
    return $AccountProfileHistoryTable(attachedDatabase, alias);
  }
}

class AccountProfileHistoryEntry extends DataClass
    implements Insertable<AccountProfileHistoryEntry> {
  final int id;
  final String ownerId;
  final String reverseDiffJson;
  final DateTime timestamp;
  const AccountProfileHistoryEntry({
    required this.id,
    required this.ownerId,
    required this.reverseDiffJson,
    required this.timestamp,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['owner_id'] = Variable<String>(ownerId);
    map['reverse_diff_json'] = Variable<String>(reverseDiffJson);
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  AccountProfileHistoryCompanion toCompanion(bool nullToAbsent) {
    return AccountProfileHistoryCompanion(
      id: Value(id),
      ownerId: Value(ownerId),
      reverseDiffJson: Value(reverseDiffJson),
      timestamp: Value(timestamp),
    );
  }

  factory AccountProfileHistoryEntry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccountProfileHistoryEntry(
      id: serializer.fromJson<int>(json['id']),
      ownerId: serializer.fromJson<String>(json['ownerId']),
      reverseDiffJson: serializer.fromJson<String>(json['reverseDiffJson']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ownerId': serializer.toJson<String>(ownerId),
      'reverseDiffJson': serializer.toJson<String>(reverseDiffJson),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  AccountProfileHistoryEntry copyWith({
    int? id,
    String? ownerId,
    String? reverseDiffJson,
    DateTime? timestamp,
  }) => AccountProfileHistoryEntry(
    id: id ?? this.id,
    ownerId: ownerId ?? this.ownerId,
    reverseDiffJson: reverseDiffJson ?? this.reverseDiffJson,
    timestamp: timestamp ?? this.timestamp,
  );
  AccountProfileHistoryEntry copyWithCompanion(
    AccountProfileHistoryCompanion data,
  ) {
    return AccountProfileHistoryEntry(
      id: data.id.present ? data.id.value : this.id,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      reverseDiffJson: data.reverseDiffJson.present
          ? data.reverseDiffJson.value
          : this.reverseDiffJson,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AccountProfileHistoryEntry(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('reverseDiffJson: $reverseDiffJson, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, ownerId, reverseDiffJson, timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccountProfileHistoryEntry &&
          other.id == this.id &&
          other.ownerId == this.ownerId &&
          other.reverseDiffJson == this.reverseDiffJson &&
          other.timestamp == this.timestamp);
}

class AccountProfileHistoryCompanion
    extends UpdateCompanion<AccountProfileHistoryEntry> {
  final Value<int> id;
  final Value<String> ownerId;
  final Value<String> reverseDiffJson;
  final Value<DateTime> timestamp;
  const AccountProfileHistoryCompanion({
    this.id = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.reverseDiffJson = const Value.absent(),
    this.timestamp = const Value.absent(),
  });
  AccountProfileHistoryCompanion.insert({
    this.id = const Value.absent(),
    required String ownerId,
    required String reverseDiffJson,
    required DateTime timestamp,
  }) : ownerId = Value(ownerId),
       reverseDiffJson = Value(reverseDiffJson),
       timestamp = Value(timestamp);
  static Insertable<AccountProfileHistoryEntry> custom({
    Expression<int>? id,
    Expression<String>? ownerId,
    Expression<String>? reverseDiffJson,
    Expression<DateTime>? timestamp,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (ownerId != null) 'owner_id': ownerId,
      if (reverseDiffJson != null) 'reverse_diff_json': reverseDiffJson,
      if (timestamp != null) 'timestamp': timestamp,
    });
  }

  AccountProfileHistoryCompanion copyWith({
    Value<int>? id,
    Value<String>? ownerId,
    Value<String>? reverseDiffJson,
    Value<DateTime>? timestamp,
  }) {
    return AccountProfileHistoryCompanion(
      id: id ?? this.id,
      ownerId: ownerId ?? this.ownerId,
      reverseDiffJson: reverseDiffJson ?? this.reverseDiffJson,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (reverseDiffJson.present) {
      map['reverse_diff_json'] = Variable<String>(reverseDiffJson.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccountProfileHistoryCompanion(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('reverseDiffJson: $reverseDiffJson, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }
}

class $FollowUsersTable extends FollowUsers
    with TableInfo<$FollowUsersTable, FollowUser> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FollowUsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES logged_accounts (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _latestRawJsonMeta = const VerificationMeta(
    'latestRawJson',
  );
  @override
  late final GeneratedColumn<String> latestRawJson = GeneratedColumn<String>(
    'latest_raw_json',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _screenNameMeta = const VerificationMeta(
    'screenName',
  );
  @override
  late final GeneratedColumn<String> screenName = GeneratedColumn<String>(
    'screen_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarUrlMeta = const VerificationMeta(
    'avatarUrl',
  );
  @override
  late final GeneratedColumn<String> avatarUrl = GeneratedColumn<String>(
    'avatar_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bioMeta = const VerificationMeta('bio');
  @override
  late final GeneratedColumn<String> bio = GeneratedColumn<String>(
    'bio',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarLocalPathMeta = const VerificationMeta(
    'avatarLocalPath',
  );
  @override
  late final GeneratedColumn<String> avatarLocalPath = GeneratedColumn<String>(
    'avatar_local_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isFollowerMeta = const VerificationMeta(
    'isFollower',
  );
  @override
  late final GeneratedColumn<bool> isFollower = GeneratedColumn<bool>(
    'is_follower',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_follower" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isFollowingMeta = const VerificationMeta(
    'isFollowing',
  );
  @override
  late final GeneratedColumn<bool> isFollowing = GeneratedColumn<bool>(
    'is_following',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_following" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    ownerId,
    userId,
    latestRawJson,
    name,
    screenName,
    avatarUrl,
    bio,
    avatarLocalPath,
    isFollower,
    isFollowing,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'follow_users';
  @override
  VerificationContext validateIntegrity(
    Insertable<FollowUser> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('latest_raw_json')) {
      context.handle(
        _latestRawJsonMeta,
        latestRawJson.isAcceptableOrUnknown(
          data['latest_raw_json']!,
          _latestRawJsonMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('screen_name')) {
      context.handle(
        _screenNameMeta,
        screenName.isAcceptableOrUnknown(data['screen_name']!, _screenNameMeta),
      );
    }
    if (data.containsKey('avatar_url')) {
      context.handle(
        _avatarUrlMeta,
        avatarUrl.isAcceptableOrUnknown(data['avatar_url']!, _avatarUrlMeta),
      );
    }
    if (data.containsKey('bio')) {
      context.handle(
        _bioMeta,
        bio.isAcceptableOrUnknown(data['bio']!, _bioMeta),
      );
    }
    if (data.containsKey('avatar_local_path')) {
      context.handle(
        _avatarLocalPathMeta,
        avatarLocalPath.isAcceptableOrUnknown(
          data['avatar_local_path']!,
          _avatarLocalPathMeta,
        ),
      );
    }
    if (data.containsKey('is_follower')) {
      context.handle(
        _isFollowerMeta,
        isFollower.isAcceptableOrUnknown(data['is_follower']!, _isFollowerMeta),
      );
    }
    if (data.containsKey('is_following')) {
      context.handle(
        _isFollowingMeta,
        isFollowing.isAcceptableOrUnknown(
          data['is_following']!,
          _isFollowingMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ownerId, userId};
  @override
  FollowUser map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FollowUser(
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      latestRawJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}latest_raw_json'],
      ),
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      screenName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}screen_name'],
      ),
      avatarUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_url'],
      ),
      bio: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bio'],
      ),
      avatarLocalPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_local_path'],
      ),
      isFollower: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_follower'],
      )!,
      isFollowing: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_following'],
      )!,
    );
  }

  @override
  $FollowUsersTable createAlias(String alias) {
    return $FollowUsersTable(attachedDatabase, alias);
  }
}

class FollowUser extends DataClass implements Insertable<FollowUser> {
  final String ownerId;
  final String userId;
  final String? latestRawJson;
  final String? name;
  final String? screenName;
  final String? avatarUrl;
  final String? bio;
  final String? avatarLocalPath;
  final bool isFollower;
  final bool isFollowing;
  const FollowUser({
    required this.ownerId,
    required this.userId,
    this.latestRawJson,
    this.name,
    this.screenName,
    this.avatarUrl,
    this.bio,
    this.avatarLocalPath,
    required this.isFollower,
    required this.isFollowing,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['owner_id'] = Variable<String>(ownerId);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || latestRawJson != null) {
      map['latest_raw_json'] = Variable<String>(latestRawJson);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || screenName != null) {
      map['screen_name'] = Variable<String>(screenName);
    }
    if (!nullToAbsent || avatarUrl != null) {
      map['avatar_url'] = Variable<String>(avatarUrl);
    }
    if (!nullToAbsent || bio != null) {
      map['bio'] = Variable<String>(bio);
    }
    if (!nullToAbsent || avatarLocalPath != null) {
      map['avatar_local_path'] = Variable<String>(avatarLocalPath);
    }
    map['is_follower'] = Variable<bool>(isFollower);
    map['is_following'] = Variable<bool>(isFollowing);
    return map;
  }

  FollowUsersCompanion toCompanion(bool nullToAbsent) {
    return FollowUsersCompanion(
      ownerId: Value(ownerId),
      userId: Value(userId),
      latestRawJson: latestRawJson == null && nullToAbsent
          ? const Value.absent()
          : Value(latestRawJson),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      screenName: screenName == null && nullToAbsent
          ? const Value.absent()
          : Value(screenName),
      avatarUrl: avatarUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarUrl),
      bio: bio == null && nullToAbsent ? const Value.absent() : Value(bio),
      avatarLocalPath: avatarLocalPath == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarLocalPath),
      isFollower: Value(isFollower),
      isFollowing: Value(isFollowing),
    );
  }

  factory FollowUser.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FollowUser(
      ownerId: serializer.fromJson<String>(json['ownerId']),
      userId: serializer.fromJson<String>(json['userId']),
      latestRawJson: serializer.fromJson<String?>(json['latestRawJson']),
      name: serializer.fromJson<String?>(json['name']),
      screenName: serializer.fromJson<String?>(json['screenName']),
      avatarUrl: serializer.fromJson<String?>(json['avatarUrl']),
      bio: serializer.fromJson<String?>(json['bio']),
      avatarLocalPath: serializer.fromJson<String?>(json['avatarLocalPath']),
      isFollower: serializer.fromJson<bool>(json['isFollower']),
      isFollowing: serializer.fromJson<bool>(json['isFollowing']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ownerId': serializer.toJson<String>(ownerId),
      'userId': serializer.toJson<String>(userId),
      'latestRawJson': serializer.toJson<String?>(latestRawJson),
      'name': serializer.toJson<String?>(name),
      'screenName': serializer.toJson<String?>(screenName),
      'avatarUrl': serializer.toJson<String?>(avatarUrl),
      'bio': serializer.toJson<String?>(bio),
      'avatarLocalPath': serializer.toJson<String?>(avatarLocalPath),
      'isFollower': serializer.toJson<bool>(isFollower),
      'isFollowing': serializer.toJson<bool>(isFollowing),
    };
  }

  FollowUser copyWith({
    String? ownerId,
    String? userId,
    Value<String?> latestRawJson = const Value.absent(),
    Value<String?> name = const Value.absent(),
    Value<String?> screenName = const Value.absent(),
    Value<String?> avatarUrl = const Value.absent(),
    Value<String?> bio = const Value.absent(),
    Value<String?> avatarLocalPath = const Value.absent(),
    bool? isFollower,
    bool? isFollowing,
  }) => FollowUser(
    ownerId: ownerId ?? this.ownerId,
    userId: userId ?? this.userId,
    latestRawJson: latestRawJson.present
        ? latestRawJson.value
        : this.latestRawJson,
    name: name.present ? name.value : this.name,
    screenName: screenName.present ? screenName.value : this.screenName,
    avatarUrl: avatarUrl.present ? avatarUrl.value : this.avatarUrl,
    bio: bio.present ? bio.value : this.bio,
    avatarLocalPath: avatarLocalPath.present
        ? avatarLocalPath.value
        : this.avatarLocalPath,
    isFollower: isFollower ?? this.isFollower,
    isFollowing: isFollowing ?? this.isFollowing,
  );
  FollowUser copyWithCompanion(FollowUsersCompanion data) {
    return FollowUser(
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      userId: data.userId.present ? data.userId.value : this.userId,
      latestRawJson: data.latestRawJson.present
          ? data.latestRawJson.value
          : this.latestRawJson,
      name: data.name.present ? data.name.value : this.name,
      screenName: data.screenName.present
          ? data.screenName.value
          : this.screenName,
      avatarUrl: data.avatarUrl.present ? data.avatarUrl.value : this.avatarUrl,
      bio: data.bio.present ? data.bio.value : this.bio,
      avatarLocalPath: data.avatarLocalPath.present
          ? data.avatarLocalPath.value
          : this.avatarLocalPath,
      isFollower: data.isFollower.present
          ? data.isFollower.value
          : this.isFollower,
      isFollowing: data.isFollowing.present
          ? data.isFollowing.value
          : this.isFollowing,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FollowUser(')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('latestRawJson: $latestRawJson, ')
          ..write('name: $name, ')
          ..write('screenName: $screenName, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('bio: $bio, ')
          ..write('avatarLocalPath: $avatarLocalPath, ')
          ..write('isFollower: $isFollower, ')
          ..write('isFollowing: $isFollowing')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    ownerId,
    userId,
    latestRawJson,
    name,
    screenName,
    avatarUrl,
    bio,
    avatarLocalPath,
    isFollower,
    isFollowing,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FollowUser &&
          other.ownerId == this.ownerId &&
          other.userId == this.userId &&
          other.latestRawJson == this.latestRawJson &&
          other.name == this.name &&
          other.screenName == this.screenName &&
          other.avatarUrl == this.avatarUrl &&
          other.bio == this.bio &&
          other.avatarLocalPath == this.avatarLocalPath &&
          other.isFollower == this.isFollower &&
          other.isFollowing == this.isFollowing);
}

class FollowUsersCompanion extends UpdateCompanion<FollowUser> {
  final Value<String> ownerId;
  final Value<String> userId;
  final Value<String?> latestRawJson;
  final Value<String?> name;
  final Value<String?> screenName;
  final Value<String?> avatarUrl;
  final Value<String?> bio;
  final Value<String?> avatarLocalPath;
  final Value<bool> isFollower;
  final Value<bool> isFollowing;
  final Value<int> rowid;
  const FollowUsersCompanion({
    this.ownerId = const Value.absent(),
    this.userId = const Value.absent(),
    this.latestRawJson = const Value.absent(),
    this.name = const Value.absent(),
    this.screenName = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.bio = const Value.absent(),
    this.avatarLocalPath = const Value.absent(),
    this.isFollower = const Value.absent(),
    this.isFollowing = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FollowUsersCompanion.insert({
    required String ownerId,
    required String userId,
    this.latestRawJson = const Value.absent(),
    this.name = const Value.absent(),
    this.screenName = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.bio = const Value.absent(),
    this.avatarLocalPath = const Value.absent(),
    this.isFollower = const Value.absent(),
    this.isFollowing = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ownerId = Value(ownerId),
       userId = Value(userId);
  static Insertable<FollowUser> custom({
    Expression<String>? ownerId,
    Expression<String>? userId,
    Expression<String>? latestRawJson,
    Expression<String>? name,
    Expression<String>? screenName,
    Expression<String>? avatarUrl,
    Expression<String>? bio,
    Expression<String>? avatarLocalPath,
    Expression<bool>? isFollower,
    Expression<bool>? isFollowing,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ownerId != null) 'owner_id': ownerId,
      if (userId != null) 'user_id': userId,
      if (latestRawJson != null) 'latest_raw_json': latestRawJson,
      if (name != null) 'name': name,
      if (screenName != null) 'screen_name': screenName,
      if (avatarUrl != null) 'avatar_url': avatarUrl,
      if (bio != null) 'bio': bio,
      if (avatarLocalPath != null) 'avatar_local_path': avatarLocalPath,
      if (isFollower != null) 'is_follower': isFollower,
      if (isFollowing != null) 'is_following': isFollowing,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FollowUsersCompanion copyWith({
    Value<String>? ownerId,
    Value<String>? userId,
    Value<String?>? latestRawJson,
    Value<String?>? name,
    Value<String?>? screenName,
    Value<String?>? avatarUrl,
    Value<String?>? bio,
    Value<String?>? avatarLocalPath,
    Value<bool>? isFollower,
    Value<bool>? isFollowing,
    Value<int>? rowid,
  }) {
    return FollowUsersCompanion(
      ownerId: ownerId ?? this.ownerId,
      userId: userId ?? this.userId,
      latestRawJson: latestRawJson ?? this.latestRawJson,
      name: name ?? this.name,
      screenName: screenName ?? this.screenName,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      bio: bio ?? this.bio,
      avatarLocalPath: avatarLocalPath ?? this.avatarLocalPath,
      isFollower: isFollower ?? this.isFollower,
      isFollowing: isFollowing ?? this.isFollowing,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (latestRawJson.present) {
      map['latest_raw_json'] = Variable<String>(latestRawJson.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (screenName.present) {
      map['screen_name'] = Variable<String>(screenName.value);
    }
    if (avatarUrl.present) {
      map['avatar_url'] = Variable<String>(avatarUrl.value);
    }
    if (bio.present) {
      map['bio'] = Variable<String>(bio.value);
    }
    if (avatarLocalPath.present) {
      map['avatar_local_path'] = Variable<String>(avatarLocalPath.value);
    }
    if (isFollower.present) {
      map['is_follower'] = Variable<bool>(isFollower.value);
    }
    if (isFollowing.present) {
      map['is_following'] = Variable<bool>(isFollowing.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FollowUsersCompanion(')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('latestRawJson: $latestRawJson, ')
          ..write('name: $name, ')
          ..write('screenName: $screenName, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('bio: $bio, ')
          ..write('avatarLocalPath: $avatarLocalPath, ')
          ..write('isFollower: $isFollower, ')
          ..write('isFollowing: $isFollowing, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FollowUsersHistoryTable extends FollowUsersHistory
    with TableInfo<$FollowUsersHistoryTable, FollowUserHistoryEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FollowUsersHistoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _reverseDiffJsonMeta = const VerificationMeta(
    'reverseDiffJson',
  );
  @override
  late final GeneratedColumn<String> reverseDiffJson = GeneratedColumn<String>(
    'reverse_diff_json',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    ownerId,
    userId,
    reverseDiffJson,
    timestamp,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'follow_users_history';
  @override
  VerificationContext validateIntegrity(
    Insertable<FollowUserHistoryEntry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('reverse_diff_json')) {
      context.handle(
        _reverseDiffJsonMeta,
        reverseDiffJson.isAcceptableOrUnknown(
          data['reverse_diff_json']!,
          _reverseDiffJsonMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_reverseDiffJsonMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FollowUserHistoryEntry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FollowUserHistoryEntry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      reverseDiffJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reverse_diff_json'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
    );
  }

  @override
  $FollowUsersHistoryTable createAlias(String alias) {
    return $FollowUsersHistoryTable(attachedDatabase, alias);
  }
}

class FollowUserHistoryEntry extends DataClass
    implements Insertable<FollowUserHistoryEntry> {
  final int id;
  final String ownerId;
  final String userId;
  final String reverseDiffJson;
  final DateTime timestamp;
  const FollowUserHistoryEntry({
    required this.id,
    required this.ownerId,
    required this.userId,
    required this.reverseDiffJson,
    required this.timestamp,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['owner_id'] = Variable<String>(ownerId);
    map['user_id'] = Variable<String>(userId);
    map['reverse_diff_json'] = Variable<String>(reverseDiffJson);
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  FollowUsersHistoryCompanion toCompanion(bool nullToAbsent) {
    return FollowUsersHistoryCompanion(
      id: Value(id),
      ownerId: Value(ownerId),
      userId: Value(userId),
      reverseDiffJson: Value(reverseDiffJson),
      timestamp: Value(timestamp),
    );
  }

  factory FollowUserHistoryEntry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FollowUserHistoryEntry(
      id: serializer.fromJson<int>(json['id']),
      ownerId: serializer.fromJson<String>(json['ownerId']),
      userId: serializer.fromJson<String>(json['userId']),
      reverseDiffJson: serializer.fromJson<String>(json['reverseDiffJson']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ownerId': serializer.toJson<String>(ownerId),
      'userId': serializer.toJson<String>(userId),
      'reverseDiffJson': serializer.toJson<String>(reverseDiffJson),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  FollowUserHistoryEntry copyWith({
    int? id,
    String? ownerId,
    String? userId,
    String? reverseDiffJson,
    DateTime? timestamp,
  }) => FollowUserHistoryEntry(
    id: id ?? this.id,
    ownerId: ownerId ?? this.ownerId,
    userId: userId ?? this.userId,
    reverseDiffJson: reverseDiffJson ?? this.reverseDiffJson,
    timestamp: timestamp ?? this.timestamp,
  );
  FollowUserHistoryEntry copyWithCompanion(FollowUsersHistoryCompanion data) {
    return FollowUserHistoryEntry(
      id: data.id.present ? data.id.value : this.id,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      userId: data.userId.present ? data.userId.value : this.userId,
      reverseDiffJson: data.reverseDiffJson.present
          ? data.reverseDiffJson.value
          : this.reverseDiffJson,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FollowUserHistoryEntry(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('reverseDiffJson: $reverseDiffJson, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, ownerId, userId, reverseDiffJson, timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FollowUserHistoryEntry &&
          other.id == this.id &&
          other.ownerId == this.ownerId &&
          other.userId == this.userId &&
          other.reverseDiffJson == this.reverseDiffJson &&
          other.timestamp == this.timestamp);
}

class FollowUsersHistoryCompanion
    extends UpdateCompanion<FollowUserHistoryEntry> {
  final Value<int> id;
  final Value<String> ownerId;
  final Value<String> userId;
  final Value<String> reverseDiffJson;
  final Value<DateTime> timestamp;
  const FollowUsersHistoryCompanion({
    this.id = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.userId = const Value.absent(),
    this.reverseDiffJson = const Value.absent(),
    this.timestamp = const Value.absent(),
  });
  FollowUsersHistoryCompanion.insert({
    this.id = const Value.absent(),
    required String ownerId,
    required String userId,
    required String reverseDiffJson,
    required DateTime timestamp,
  }) : ownerId = Value(ownerId),
       userId = Value(userId),
       reverseDiffJson = Value(reverseDiffJson),
       timestamp = Value(timestamp);
  static Insertable<FollowUserHistoryEntry> custom({
    Expression<int>? id,
    Expression<String>? ownerId,
    Expression<String>? userId,
    Expression<String>? reverseDiffJson,
    Expression<DateTime>? timestamp,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (ownerId != null) 'owner_id': ownerId,
      if (userId != null) 'user_id': userId,
      if (reverseDiffJson != null) 'reverse_diff_json': reverseDiffJson,
      if (timestamp != null) 'timestamp': timestamp,
    });
  }

  FollowUsersHistoryCompanion copyWith({
    Value<int>? id,
    Value<String>? ownerId,
    Value<String>? userId,
    Value<String>? reverseDiffJson,
    Value<DateTime>? timestamp,
  }) {
    return FollowUsersHistoryCompanion(
      id: id ?? this.id,
      ownerId: ownerId ?? this.ownerId,
      userId: userId ?? this.userId,
      reverseDiffJson: reverseDiffJson ?? this.reverseDiffJson,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (reverseDiffJson.present) {
      map['reverse_diff_json'] = Variable<String>(reverseDiffJson.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FollowUsersHistoryCompanion(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('reverseDiffJson: $reverseDiffJson, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }
}

class $ChangeReportsTable extends ChangeReports
    with TableInfo<$ChangeReportsTable, ChangeReportEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ChangeReportsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES logged_accounts (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _changeTypeMeta = const VerificationMeta(
    'changeType',
  );
  @override
  late final GeneratedColumn<String> changeType = GeneratedColumn<String>(
    'change_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    ownerId,
    userId,
    changeType,
    timestamp,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'change_reports';
  @override
  VerificationContext validateIntegrity(
    Insertable<ChangeReportEntry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('change_type')) {
      context.handle(
        _changeTypeMeta,
        changeType.isAcceptableOrUnknown(data['change_type']!, _changeTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_changeTypeMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ChangeReportEntry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ChangeReportEntry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      changeType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}change_type'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
    );
  }

  @override
  $ChangeReportsTable createAlias(String alias) {
    return $ChangeReportsTable(attachedDatabase, alias);
  }
}

class ChangeReportEntry extends DataClass
    implements Insertable<ChangeReportEntry> {
  final int id;
  final String ownerId;
  final String userId;
  final String changeType;
  final DateTime timestamp;
  const ChangeReportEntry({
    required this.id,
    required this.ownerId,
    required this.userId,
    required this.changeType,
    required this.timestamp,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['owner_id'] = Variable<String>(ownerId);
    map['user_id'] = Variable<String>(userId);
    map['change_type'] = Variable<String>(changeType);
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  ChangeReportsCompanion toCompanion(bool nullToAbsent) {
    return ChangeReportsCompanion(
      id: Value(id),
      ownerId: Value(ownerId),
      userId: Value(userId),
      changeType: Value(changeType),
      timestamp: Value(timestamp),
    );
  }

  factory ChangeReportEntry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ChangeReportEntry(
      id: serializer.fromJson<int>(json['id']),
      ownerId: serializer.fromJson<String>(json['ownerId']),
      userId: serializer.fromJson<String>(json['userId']),
      changeType: serializer.fromJson<String>(json['changeType']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ownerId': serializer.toJson<String>(ownerId),
      'userId': serializer.toJson<String>(userId),
      'changeType': serializer.toJson<String>(changeType),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  ChangeReportEntry copyWith({
    int? id,
    String? ownerId,
    String? userId,
    String? changeType,
    DateTime? timestamp,
  }) => ChangeReportEntry(
    id: id ?? this.id,
    ownerId: ownerId ?? this.ownerId,
    userId: userId ?? this.userId,
    changeType: changeType ?? this.changeType,
    timestamp: timestamp ?? this.timestamp,
  );
  ChangeReportEntry copyWithCompanion(ChangeReportsCompanion data) {
    return ChangeReportEntry(
      id: data.id.present ? data.id.value : this.id,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      userId: data.userId.present ? data.userId.value : this.userId,
      changeType: data.changeType.present
          ? data.changeType.value
          : this.changeType,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ChangeReportEntry(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('changeType: $changeType, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, ownerId, userId, changeType, timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ChangeReportEntry &&
          other.id == this.id &&
          other.ownerId == this.ownerId &&
          other.userId == this.userId &&
          other.changeType == this.changeType &&
          other.timestamp == this.timestamp);
}

class ChangeReportsCompanion extends UpdateCompanion<ChangeReportEntry> {
  final Value<int> id;
  final Value<String> ownerId;
  final Value<String> userId;
  final Value<String> changeType;
  final Value<DateTime> timestamp;
  const ChangeReportsCompanion({
    this.id = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.userId = const Value.absent(),
    this.changeType = const Value.absent(),
    this.timestamp = const Value.absent(),
  });
  ChangeReportsCompanion.insert({
    this.id = const Value.absent(),
    required String ownerId,
    required String userId,
    required String changeType,
    required DateTime timestamp,
  }) : ownerId = Value(ownerId),
       userId = Value(userId),
       changeType = Value(changeType),
       timestamp = Value(timestamp);
  static Insertable<ChangeReportEntry> custom({
    Expression<int>? id,
    Expression<String>? ownerId,
    Expression<String>? userId,
    Expression<String>? changeType,
    Expression<DateTime>? timestamp,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (ownerId != null) 'owner_id': ownerId,
      if (userId != null) 'user_id': userId,
      if (changeType != null) 'change_type': changeType,
      if (timestamp != null) 'timestamp': timestamp,
    });
  }

  ChangeReportsCompanion copyWith({
    Value<int>? id,
    Value<String>? ownerId,
    Value<String>? userId,
    Value<String>? changeType,
    Value<DateTime>? timestamp,
  }) {
    return ChangeReportsCompanion(
      id: id ?? this.id,
      ownerId: ownerId ?? this.ownerId,
      userId: userId ?? this.userId,
      changeType: changeType ?? this.changeType,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (changeType.present) {
      map['change_type'] = Variable<String>(changeType.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ChangeReportsCompanion(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('changeType: $changeType, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $LoggedAccountsTable loggedAccounts = $LoggedAccountsTable(this);
  late final $AccountProfileHistoryTable accountProfileHistory =
      $AccountProfileHistoryTable(this);
  late final $FollowUsersTable followUsers = $FollowUsersTable(this);
  late final $FollowUsersHistoryTable followUsersHistory =
      $FollowUsersHistoryTable(this);
  late final $ChangeReportsTable changeReports = $ChangeReportsTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    loggedAccounts,
    accountProfileHistory,
    followUsers,
    followUsersHistory,
    changeReports,
  ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules([
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'logged_accounts',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('account_profile_history', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'logged_accounts',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('follow_users', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'logged_accounts',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('change_reports', kind: UpdateKind.delete)],
    ),
  ]);
}

typedef $$LoggedAccountsTableCreateCompanionBuilder =
    LoggedAccountsCompanion Function({
      required String id,
      Value<String?> name,
      Value<String?> screenName,
      Value<String?> bio,
      Value<String?> location,
      Value<String?> link,
      Value<String?> joinTime,
      Value<int> followersCount,
      Value<int> followingCount,
      Value<int> statusesCount,
      Value<int> mediaCount,
      Value<int> favouritesCount,
      Value<int> listedCount,
      Value<String?> latestRawJson,
      Value<String?> avatarUrl,
      Value<String?> bannerUrl,
      Value<String?> avatarLocalPath,
      Value<String?> bannerLocalPath,
      Value<int> rowid,
    });
typedef $$LoggedAccountsTableUpdateCompanionBuilder =
    LoggedAccountsCompanion Function({
      Value<String> id,
      Value<String?> name,
      Value<String?> screenName,
      Value<String?> bio,
      Value<String?> location,
      Value<String?> link,
      Value<String?> joinTime,
      Value<int> followersCount,
      Value<int> followingCount,
      Value<int> statusesCount,
      Value<int> mediaCount,
      Value<int> favouritesCount,
      Value<int> listedCount,
      Value<String?> latestRawJson,
      Value<String?> avatarUrl,
      Value<String?> bannerUrl,
      Value<String?> avatarLocalPath,
      Value<String?> bannerLocalPath,
      Value<int> rowid,
    });

final class $$LoggedAccountsTableReferences
    extends BaseReferences<_$AppDatabase, $LoggedAccountsTable, LoggedAccount> {
  $$LoggedAccountsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<
    $AccountProfileHistoryTable,
    List<AccountProfileHistoryEntry>
  >
  _accountProfileHistoryRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.accountProfileHistory,
        aliasName: $_aliasNameGenerator(
          db.loggedAccounts.id,
          db.accountProfileHistory.ownerId,
        ),
      );

  $$AccountProfileHistoryTableProcessedTableManager
  get accountProfileHistoryRefs {
    final manager = $$AccountProfileHistoryTableTableManager(
      $_db,
      $_db.accountProfileHistory,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _accountProfileHistoryRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FollowUsersTable, List<FollowUser>>
  _followUsersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.followUsers,
    aliasName: $_aliasNameGenerator(
      db.loggedAccounts.id,
      db.followUsers.ownerId,
    ),
  );

  $$FollowUsersTableProcessedTableManager get followUsersRefs {
    final manager = $$FollowUsersTableTableManager(
      $_db,
      $_db.followUsers,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_followUsersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ChangeReportsTable, List<ChangeReportEntry>>
  _changeReportsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.changeReports,
    aliasName: $_aliasNameGenerator(
      db.loggedAccounts.id,
      db.changeReports.ownerId,
    ),
  );

  $$ChangeReportsTableProcessedTableManager get changeReportsRefs {
    final manager = $$ChangeReportsTableTableManager(
      $_db,
      $_db.changeReports,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_changeReportsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$LoggedAccountsTableFilterComposer
    extends Composer<_$AppDatabase, $LoggedAccountsTable> {
  $$LoggedAccountsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bio => $composableBuilder(
    column: $table.bio,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get link => $composableBuilder(
    column: $table.link,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get joinTime => $composableBuilder(
    column: $table.joinTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get followersCount => $composableBuilder(
    column: $table.followersCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get followingCount => $composableBuilder(
    column: $table.followingCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get statusesCount => $composableBuilder(
    column: $table.statusesCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mediaCount => $composableBuilder(
    column: $table.mediaCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get favouritesCount => $composableBuilder(
    column: $table.favouritesCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get listedCount => $composableBuilder(
    column: $table.listedCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bannerUrl => $composableBuilder(
    column: $table.bannerUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bannerLocalPath => $composableBuilder(
    column: $table.bannerLocalPath,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> accountProfileHistoryRefs(
    Expression<bool> Function($$AccountProfileHistoryTableFilterComposer f) f,
  ) {
    final $$AccountProfileHistoryTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.accountProfileHistory,
          getReferencedColumn: (t) => t.ownerId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$AccountProfileHistoryTableFilterComposer(
                $db: $db,
                $table: $db.accountProfileHistory,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<bool> followUsersRefs(
    Expression<bool> Function($$FollowUsersTableFilterComposer f) f,
  ) {
    final $$FollowUsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.followUsers,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FollowUsersTableFilterComposer(
            $db: $db,
            $table: $db.followUsers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> changeReportsRefs(
    Expression<bool> Function($$ChangeReportsTableFilterComposer f) f,
  ) {
    final $$ChangeReportsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.changeReports,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ChangeReportsTableFilterComposer(
            $db: $db,
            $table: $db.changeReports,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$LoggedAccountsTableOrderingComposer
    extends Composer<_$AppDatabase, $LoggedAccountsTable> {
  $$LoggedAccountsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bio => $composableBuilder(
    column: $table.bio,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get link => $composableBuilder(
    column: $table.link,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get joinTime => $composableBuilder(
    column: $table.joinTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get followersCount => $composableBuilder(
    column: $table.followersCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get followingCount => $composableBuilder(
    column: $table.followingCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get statusesCount => $composableBuilder(
    column: $table.statusesCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mediaCount => $composableBuilder(
    column: $table.mediaCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get favouritesCount => $composableBuilder(
    column: $table.favouritesCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get listedCount => $composableBuilder(
    column: $table.listedCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bannerUrl => $composableBuilder(
    column: $table.bannerUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bannerLocalPath => $composableBuilder(
    column: $table.bannerLocalPath,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$LoggedAccountsTableAnnotationComposer
    extends Composer<_$AppDatabase, $LoggedAccountsTable> {
  $$LoggedAccountsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bio =>
      $composableBuilder(column: $table.bio, builder: (column) => column);

  GeneratedColumn<String> get location =>
      $composableBuilder(column: $table.location, builder: (column) => column);

  GeneratedColumn<String> get link =>
      $composableBuilder(column: $table.link, builder: (column) => column);

  GeneratedColumn<String> get joinTime =>
      $composableBuilder(column: $table.joinTime, builder: (column) => column);

  GeneratedColumn<int> get followersCount => $composableBuilder(
    column: $table.followersCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get followingCount => $composableBuilder(
    column: $table.followingCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get statusesCount => $composableBuilder(
    column: $table.statusesCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get mediaCount => $composableBuilder(
    column: $table.mediaCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get favouritesCount => $composableBuilder(
    column: $table.favouritesCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get listedCount => $composableBuilder(
    column: $table.listedCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => column,
  );

  GeneratedColumn<String> get avatarUrl =>
      $composableBuilder(column: $table.avatarUrl, builder: (column) => column);

  GeneratedColumn<String> get bannerUrl =>
      $composableBuilder(column: $table.bannerUrl, builder: (column) => column);

  GeneratedColumn<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bannerLocalPath => $composableBuilder(
    column: $table.bannerLocalPath,
    builder: (column) => column,
  );

  Expression<T> accountProfileHistoryRefs<T extends Object>(
    Expression<T> Function($$AccountProfileHistoryTableAnnotationComposer a) f,
  ) {
    final $$AccountProfileHistoryTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.accountProfileHistory,
          getReferencedColumn: (t) => t.ownerId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$AccountProfileHistoryTableAnnotationComposer(
                $db: $db,
                $table: $db.accountProfileHistory,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> followUsersRefs<T extends Object>(
    Expression<T> Function($$FollowUsersTableAnnotationComposer a) f,
  ) {
    final $$FollowUsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.followUsers,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FollowUsersTableAnnotationComposer(
            $db: $db,
            $table: $db.followUsers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> changeReportsRefs<T extends Object>(
    Expression<T> Function($$ChangeReportsTableAnnotationComposer a) f,
  ) {
    final $$ChangeReportsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.changeReports,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ChangeReportsTableAnnotationComposer(
            $db: $db,
            $table: $db.changeReports,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$LoggedAccountsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LoggedAccountsTable,
          LoggedAccount,
          $$LoggedAccountsTableFilterComposer,
          $$LoggedAccountsTableOrderingComposer,
          $$LoggedAccountsTableAnnotationComposer,
          $$LoggedAccountsTableCreateCompanionBuilder,
          $$LoggedAccountsTableUpdateCompanionBuilder,
          (LoggedAccount, $$LoggedAccountsTableReferences),
          LoggedAccount,
          PrefetchHooks Function({
            bool accountProfileHistoryRefs,
            bool followUsersRefs,
            bool changeReportsRefs,
          })
        > {
  $$LoggedAccountsTableTableManager(
    _$AppDatabase db,
    $LoggedAccountsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LoggedAccountsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LoggedAccountsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LoggedAccountsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> screenName = const Value.absent(),
                Value<String?> bio = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> link = const Value.absent(),
                Value<String?> joinTime = const Value.absent(),
                Value<int> followersCount = const Value.absent(),
                Value<int> followingCount = const Value.absent(),
                Value<int> statusesCount = const Value.absent(),
                Value<int> mediaCount = const Value.absent(),
                Value<int> favouritesCount = const Value.absent(),
                Value<int> listedCount = const Value.absent(),
                Value<String?> latestRawJson = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String?> bannerUrl = const Value.absent(),
                Value<String?> avatarLocalPath = const Value.absent(),
                Value<String?> bannerLocalPath = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LoggedAccountsCompanion(
                id: id,
                name: name,
                screenName: screenName,
                bio: bio,
                location: location,
                link: link,
                joinTime: joinTime,
                followersCount: followersCount,
                followingCount: followingCount,
                statusesCount: statusesCount,
                mediaCount: mediaCount,
                favouritesCount: favouritesCount,
                listedCount: listedCount,
                latestRawJson: latestRawJson,
                avatarUrl: avatarUrl,
                bannerUrl: bannerUrl,
                avatarLocalPath: avatarLocalPath,
                bannerLocalPath: bannerLocalPath,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> name = const Value.absent(),
                Value<String?> screenName = const Value.absent(),
                Value<String?> bio = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> link = const Value.absent(),
                Value<String?> joinTime = const Value.absent(),
                Value<int> followersCount = const Value.absent(),
                Value<int> followingCount = const Value.absent(),
                Value<int> statusesCount = const Value.absent(),
                Value<int> mediaCount = const Value.absent(),
                Value<int> favouritesCount = const Value.absent(),
                Value<int> listedCount = const Value.absent(),
                Value<String?> latestRawJson = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String?> bannerUrl = const Value.absent(),
                Value<String?> avatarLocalPath = const Value.absent(),
                Value<String?> bannerLocalPath = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LoggedAccountsCompanion.insert(
                id: id,
                name: name,
                screenName: screenName,
                bio: bio,
                location: location,
                link: link,
                joinTime: joinTime,
                followersCount: followersCount,
                followingCount: followingCount,
                statusesCount: statusesCount,
                mediaCount: mediaCount,
                favouritesCount: favouritesCount,
                listedCount: listedCount,
                latestRawJson: latestRawJson,
                avatarUrl: avatarUrl,
                bannerUrl: bannerUrl,
                avatarLocalPath: avatarLocalPath,
                bannerLocalPath: bannerLocalPath,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$LoggedAccountsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                accountProfileHistoryRefs = false,
                followUsersRefs = false,
                changeReportsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (accountProfileHistoryRefs) db.accountProfileHistory,
                    if (followUsersRefs) db.followUsers,
                    if (changeReportsRefs) db.changeReports,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (accountProfileHistoryRefs)
                        await $_getPrefetchedData<
                          LoggedAccount,
                          $LoggedAccountsTable,
                          AccountProfileHistoryEntry
                        >(
                          currentTable: table,
                          referencedTable: $$LoggedAccountsTableReferences
                              ._accountProfileHistoryRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$LoggedAccountsTableReferences(
                                db,
                                table,
                                p0,
                              ).accountProfileHistoryRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (followUsersRefs)
                        await $_getPrefetchedData<
                          LoggedAccount,
                          $LoggedAccountsTable,
                          FollowUser
                        >(
                          currentTable: table,
                          referencedTable: $$LoggedAccountsTableReferences
                              ._followUsersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$LoggedAccountsTableReferences(
                                db,
                                table,
                                p0,
                              ).followUsersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (changeReportsRefs)
                        await $_getPrefetchedData<
                          LoggedAccount,
                          $LoggedAccountsTable,
                          ChangeReportEntry
                        >(
                          currentTable: table,
                          referencedTable: $$LoggedAccountsTableReferences
                              ._changeReportsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$LoggedAccountsTableReferences(
                                db,
                                table,
                                p0,
                              ).changeReportsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$LoggedAccountsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LoggedAccountsTable,
      LoggedAccount,
      $$LoggedAccountsTableFilterComposer,
      $$LoggedAccountsTableOrderingComposer,
      $$LoggedAccountsTableAnnotationComposer,
      $$LoggedAccountsTableCreateCompanionBuilder,
      $$LoggedAccountsTableUpdateCompanionBuilder,
      (LoggedAccount, $$LoggedAccountsTableReferences),
      LoggedAccount,
      PrefetchHooks Function({
        bool accountProfileHistoryRefs,
        bool followUsersRefs,
        bool changeReportsRefs,
      })
    >;
typedef $$AccountProfileHistoryTableCreateCompanionBuilder =
    AccountProfileHistoryCompanion Function({
      Value<int> id,
      required String ownerId,
      required String reverseDiffJson,
      required DateTime timestamp,
    });
typedef $$AccountProfileHistoryTableUpdateCompanionBuilder =
    AccountProfileHistoryCompanion Function({
      Value<int> id,
      Value<String> ownerId,
      Value<String> reverseDiffJson,
      Value<DateTime> timestamp,
    });

final class $$AccountProfileHistoryTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $AccountProfileHistoryTable,
          AccountProfileHistoryEntry
        > {
  $$AccountProfileHistoryTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $LoggedAccountsTable _ownerIdTable(_$AppDatabase db) =>
      db.loggedAccounts.createAlias(
        $_aliasNameGenerator(
          db.accountProfileHistory.ownerId,
          db.loggedAccounts.id,
        ),
      );

  $$LoggedAccountsTableProcessedTableManager get ownerId {
    final $_column = $_itemColumn<String>('owner_id')!;

    final manager = $$LoggedAccountsTableTableManager(
      $_db,
      $_db.loggedAccounts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$AccountProfileHistoryTableFilterComposer
    extends Composer<_$AppDatabase, $AccountProfileHistoryTable> {
  $$AccountProfileHistoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  $$LoggedAccountsTableFilterComposer get ownerId {
    final $$LoggedAccountsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableFilterComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AccountProfileHistoryTableOrderingComposer
    extends Composer<_$AppDatabase, $AccountProfileHistoryTable> {
  $$AccountProfileHistoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  $$LoggedAccountsTableOrderingComposer get ownerId {
    final $$LoggedAccountsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableOrderingComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AccountProfileHistoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $AccountProfileHistoryTable> {
  $$AccountProfileHistoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  $$LoggedAccountsTableAnnotationComposer get ownerId {
    final $$LoggedAccountsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableAnnotationComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AccountProfileHistoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AccountProfileHistoryTable,
          AccountProfileHistoryEntry,
          $$AccountProfileHistoryTableFilterComposer,
          $$AccountProfileHistoryTableOrderingComposer,
          $$AccountProfileHistoryTableAnnotationComposer,
          $$AccountProfileHistoryTableCreateCompanionBuilder,
          $$AccountProfileHistoryTableUpdateCompanionBuilder,
          (AccountProfileHistoryEntry, $$AccountProfileHistoryTableReferences),
          AccountProfileHistoryEntry,
          PrefetchHooks Function({bool ownerId})
        > {
  $$AccountProfileHistoryTableTableManager(
    _$AppDatabase db,
    $AccountProfileHistoryTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AccountProfileHistoryTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$AccountProfileHistoryTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$AccountProfileHistoryTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> ownerId = const Value.absent(),
                Value<String> reverseDiffJson = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
              }) => AccountProfileHistoryCompanion(
                id: id,
                ownerId: ownerId,
                reverseDiffJson: reverseDiffJson,
                timestamp: timestamp,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String ownerId,
                required String reverseDiffJson,
                required DateTime timestamp,
              }) => AccountProfileHistoryCompanion.insert(
                id: id,
                ownerId: ownerId,
                reverseDiffJson: reverseDiffJson,
                timestamp: timestamp,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$AccountProfileHistoryTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({ownerId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (ownerId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.ownerId,
                                referencedTable:
                                    $$AccountProfileHistoryTableReferences
                                        ._ownerIdTable(db),
                                referencedColumn:
                                    $$AccountProfileHistoryTableReferences
                                        ._ownerIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$AccountProfileHistoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AccountProfileHistoryTable,
      AccountProfileHistoryEntry,
      $$AccountProfileHistoryTableFilterComposer,
      $$AccountProfileHistoryTableOrderingComposer,
      $$AccountProfileHistoryTableAnnotationComposer,
      $$AccountProfileHistoryTableCreateCompanionBuilder,
      $$AccountProfileHistoryTableUpdateCompanionBuilder,
      (AccountProfileHistoryEntry, $$AccountProfileHistoryTableReferences),
      AccountProfileHistoryEntry,
      PrefetchHooks Function({bool ownerId})
    >;
typedef $$FollowUsersTableCreateCompanionBuilder =
    FollowUsersCompanion Function({
      required String ownerId,
      required String userId,
      Value<String?> latestRawJson,
      Value<String?> name,
      Value<String?> screenName,
      Value<String?> avatarUrl,
      Value<String?> bio,
      Value<String?> avatarLocalPath,
      Value<bool> isFollower,
      Value<bool> isFollowing,
      Value<int> rowid,
    });
typedef $$FollowUsersTableUpdateCompanionBuilder =
    FollowUsersCompanion Function({
      Value<String> ownerId,
      Value<String> userId,
      Value<String?> latestRawJson,
      Value<String?> name,
      Value<String?> screenName,
      Value<String?> avatarUrl,
      Value<String?> bio,
      Value<String?> avatarLocalPath,
      Value<bool> isFollower,
      Value<bool> isFollowing,
      Value<int> rowid,
    });

final class $$FollowUsersTableReferences
    extends BaseReferences<_$AppDatabase, $FollowUsersTable, FollowUser> {
  $$FollowUsersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $LoggedAccountsTable _ownerIdTable(_$AppDatabase db) =>
      db.loggedAccounts.createAlias(
        $_aliasNameGenerator(db.followUsers.ownerId, db.loggedAccounts.id),
      );

  $$LoggedAccountsTableProcessedTableManager get ownerId {
    final $_column = $_itemColumn<String>('owner_id')!;

    final manager = $$LoggedAccountsTableTableManager(
      $_db,
      $_db.loggedAccounts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FollowUsersTableFilterComposer
    extends Composer<_$AppDatabase, $FollowUsersTable> {
  $$FollowUsersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bio => $composableBuilder(
    column: $table.bio,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFollower => $composableBuilder(
    column: $table.isFollower,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFollowing => $composableBuilder(
    column: $table.isFollowing,
    builder: (column) => ColumnFilters(column),
  );

  $$LoggedAccountsTableFilterComposer get ownerId {
    final $$LoggedAccountsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableFilterComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FollowUsersTableOrderingComposer
    extends Composer<_$AppDatabase, $FollowUsersTable> {
  $$FollowUsersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bio => $composableBuilder(
    column: $table.bio,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFollower => $composableBuilder(
    column: $table.isFollower,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFollowing => $composableBuilder(
    column: $table.isFollowing,
    builder: (column) => ColumnOrderings(column),
  );

  $$LoggedAccountsTableOrderingComposer get ownerId {
    final $$LoggedAccountsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableOrderingComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FollowUsersTableAnnotationComposer
    extends Composer<_$AppDatabase, $FollowUsersTable> {
  $$FollowUsersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get avatarUrl =>
      $composableBuilder(column: $table.avatarUrl, builder: (column) => column);

  GeneratedColumn<String> get bio =>
      $composableBuilder(column: $table.bio, builder: (column) => column);

  GeneratedColumn<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isFollower => $composableBuilder(
    column: $table.isFollower,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isFollowing => $composableBuilder(
    column: $table.isFollowing,
    builder: (column) => column,
  );

  $$LoggedAccountsTableAnnotationComposer get ownerId {
    final $$LoggedAccountsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableAnnotationComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FollowUsersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FollowUsersTable,
          FollowUser,
          $$FollowUsersTableFilterComposer,
          $$FollowUsersTableOrderingComposer,
          $$FollowUsersTableAnnotationComposer,
          $$FollowUsersTableCreateCompanionBuilder,
          $$FollowUsersTableUpdateCompanionBuilder,
          (FollowUser, $$FollowUsersTableReferences),
          FollowUser,
          PrefetchHooks Function({bool ownerId})
        > {
  $$FollowUsersTableTableManager(_$AppDatabase db, $FollowUsersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FollowUsersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FollowUsersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FollowUsersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> ownerId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> latestRawJson = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> screenName = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String?> bio = const Value.absent(),
                Value<String?> avatarLocalPath = const Value.absent(),
                Value<bool> isFollower = const Value.absent(),
                Value<bool> isFollowing = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FollowUsersCompanion(
                ownerId: ownerId,
                userId: userId,
                latestRawJson: latestRawJson,
                name: name,
                screenName: screenName,
                avatarUrl: avatarUrl,
                bio: bio,
                avatarLocalPath: avatarLocalPath,
                isFollower: isFollower,
                isFollowing: isFollowing,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String ownerId,
                required String userId,
                Value<String?> latestRawJson = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> screenName = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String?> bio = const Value.absent(),
                Value<String?> avatarLocalPath = const Value.absent(),
                Value<bool> isFollower = const Value.absent(),
                Value<bool> isFollowing = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FollowUsersCompanion.insert(
                ownerId: ownerId,
                userId: userId,
                latestRawJson: latestRawJson,
                name: name,
                screenName: screenName,
                avatarUrl: avatarUrl,
                bio: bio,
                avatarLocalPath: avatarLocalPath,
                isFollower: isFollower,
                isFollowing: isFollowing,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FollowUsersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({ownerId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (ownerId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.ownerId,
                                referencedTable: $$FollowUsersTableReferences
                                    ._ownerIdTable(db),
                                referencedColumn: $$FollowUsersTableReferences
                                    ._ownerIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FollowUsersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FollowUsersTable,
      FollowUser,
      $$FollowUsersTableFilterComposer,
      $$FollowUsersTableOrderingComposer,
      $$FollowUsersTableAnnotationComposer,
      $$FollowUsersTableCreateCompanionBuilder,
      $$FollowUsersTableUpdateCompanionBuilder,
      (FollowUser, $$FollowUsersTableReferences),
      FollowUser,
      PrefetchHooks Function({bool ownerId})
    >;
typedef $$FollowUsersHistoryTableCreateCompanionBuilder =
    FollowUsersHistoryCompanion Function({
      Value<int> id,
      required String ownerId,
      required String userId,
      required String reverseDiffJson,
      required DateTime timestamp,
    });
typedef $$FollowUsersHistoryTableUpdateCompanionBuilder =
    FollowUsersHistoryCompanion Function({
      Value<int> id,
      Value<String> ownerId,
      Value<String> userId,
      Value<String> reverseDiffJson,
      Value<DateTime> timestamp,
    });

class $$FollowUsersHistoryTableFilterComposer
    extends Composer<_$AppDatabase, $FollowUsersHistoryTable> {
  $$FollowUsersHistoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ownerId => $composableBuilder(
    column: $table.ownerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FollowUsersHistoryTableOrderingComposer
    extends Composer<_$AppDatabase, $FollowUsersHistoryTable> {
  $$FollowUsersHistoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ownerId => $composableBuilder(
    column: $table.ownerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FollowUsersHistoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $FollowUsersHistoryTable> {
  $$FollowUsersHistoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get ownerId =>
      $composableBuilder(column: $table.ownerId, builder: (column) => column);

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);
}

class $$FollowUsersHistoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FollowUsersHistoryTable,
          FollowUserHistoryEntry,
          $$FollowUsersHistoryTableFilterComposer,
          $$FollowUsersHistoryTableOrderingComposer,
          $$FollowUsersHistoryTableAnnotationComposer,
          $$FollowUsersHistoryTableCreateCompanionBuilder,
          $$FollowUsersHistoryTableUpdateCompanionBuilder,
          (
            FollowUserHistoryEntry,
            BaseReferences<
              _$AppDatabase,
              $FollowUsersHistoryTable,
              FollowUserHistoryEntry
            >,
          ),
          FollowUserHistoryEntry,
          PrefetchHooks Function()
        > {
  $$FollowUsersHistoryTableTableManager(
    _$AppDatabase db,
    $FollowUsersHistoryTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FollowUsersHistoryTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FollowUsersHistoryTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FollowUsersHistoryTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> ownerId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> reverseDiffJson = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
              }) => FollowUsersHistoryCompanion(
                id: id,
                ownerId: ownerId,
                userId: userId,
                reverseDiffJson: reverseDiffJson,
                timestamp: timestamp,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String ownerId,
                required String userId,
                required String reverseDiffJson,
                required DateTime timestamp,
              }) => FollowUsersHistoryCompanion.insert(
                id: id,
                ownerId: ownerId,
                userId: userId,
                reverseDiffJson: reverseDiffJson,
                timestamp: timestamp,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FollowUsersHistoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FollowUsersHistoryTable,
      FollowUserHistoryEntry,
      $$FollowUsersHistoryTableFilterComposer,
      $$FollowUsersHistoryTableOrderingComposer,
      $$FollowUsersHistoryTableAnnotationComposer,
      $$FollowUsersHistoryTableCreateCompanionBuilder,
      $$FollowUsersHistoryTableUpdateCompanionBuilder,
      (
        FollowUserHistoryEntry,
        BaseReferences<
          _$AppDatabase,
          $FollowUsersHistoryTable,
          FollowUserHistoryEntry
        >,
      ),
      FollowUserHistoryEntry,
      PrefetchHooks Function()
    >;
typedef $$ChangeReportsTableCreateCompanionBuilder =
    ChangeReportsCompanion Function({
      Value<int> id,
      required String ownerId,
      required String userId,
      required String changeType,
      required DateTime timestamp,
    });
typedef $$ChangeReportsTableUpdateCompanionBuilder =
    ChangeReportsCompanion Function({
      Value<int> id,
      Value<String> ownerId,
      Value<String> userId,
      Value<String> changeType,
      Value<DateTime> timestamp,
    });

final class $$ChangeReportsTableReferences
    extends
        BaseReferences<_$AppDatabase, $ChangeReportsTable, ChangeReportEntry> {
  $$ChangeReportsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $LoggedAccountsTable _ownerIdTable(_$AppDatabase db) =>
      db.loggedAccounts.createAlias(
        $_aliasNameGenerator(db.changeReports.ownerId, db.loggedAccounts.id),
      );

  $$LoggedAccountsTableProcessedTableManager get ownerId {
    final $_column = $_itemColumn<String>('owner_id')!;

    final manager = $$LoggedAccountsTableTableManager(
      $_db,
      $_db.loggedAccounts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ChangeReportsTableFilterComposer
    extends Composer<_$AppDatabase, $ChangeReportsTable> {
  $$ChangeReportsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get changeType => $composableBuilder(
    column: $table.changeType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  $$LoggedAccountsTableFilterComposer get ownerId {
    final $$LoggedAccountsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableFilterComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ChangeReportsTableOrderingComposer
    extends Composer<_$AppDatabase, $ChangeReportsTable> {
  $$ChangeReportsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get changeType => $composableBuilder(
    column: $table.changeType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  $$LoggedAccountsTableOrderingComposer get ownerId {
    final $$LoggedAccountsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableOrderingComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ChangeReportsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ChangeReportsTable> {
  $$ChangeReportsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get changeType => $composableBuilder(
    column: $table.changeType,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  $$LoggedAccountsTableAnnotationComposer get ownerId {
    final $$LoggedAccountsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableAnnotationComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ChangeReportsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ChangeReportsTable,
          ChangeReportEntry,
          $$ChangeReportsTableFilterComposer,
          $$ChangeReportsTableOrderingComposer,
          $$ChangeReportsTableAnnotationComposer,
          $$ChangeReportsTableCreateCompanionBuilder,
          $$ChangeReportsTableUpdateCompanionBuilder,
          (ChangeReportEntry, $$ChangeReportsTableReferences),
          ChangeReportEntry,
          PrefetchHooks Function({bool ownerId})
        > {
  $$ChangeReportsTableTableManager(_$AppDatabase db, $ChangeReportsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ChangeReportsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ChangeReportsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ChangeReportsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> ownerId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> changeType = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
              }) => ChangeReportsCompanion(
                id: id,
                ownerId: ownerId,
                userId: userId,
                changeType: changeType,
                timestamp: timestamp,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String ownerId,
                required String userId,
                required String changeType,
                required DateTime timestamp,
              }) => ChangeReportsCompanion.insert(
                id: id,
                ownerId: ownerId,
                userId: userId,
                changeType: changeType,
                timestamp: timestamp,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ChangeReportsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({ownerId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (ownerId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.ownerId,
                                referencedTable: $$ChangeReportsTableReferences
                                    ._ownerIdTable(db),
                                referencedColumn: $$ChangeReportsTableReferences
                                    ._ownerIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ChangeReportsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ChangeReportsTable,
      ChangeReportEntry,
      $$ChangeReportsTableFilterComposer,
      $$ChangeReportsTableOrderingComposer,
      $$ChangeReportsTableAnnotationComposer,
      $$ChangeReportsTableCreateCompanionBuilder,
      $$ChangeReportsTableUpdateCompanionBuilder,
      (ChangeReportEntry, $$ChangeReportsTableReferences),
      ChangeReportEntry,
      PrefetchHooks Function({bool ownerId})
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$LoggedAccountsTableTableManager get loggedAccounts =>
      $$LoggedAccountsTableTableManager(_db, _db.loggedAccounts);
  $$AccountProfileHistoryTableTableManager get accountProfileHistory =>
      $$AccountProfileHistoryTableTableManager(_db, _db.accountProfileHistory);
  $$FollowUsersTableTableManager get followUsers =>
      $$FollowUsersTableTableManager(_db, _db.followUsers);
  $$FollowUsersHistoryTableTableManager get followUsersHistory =>
      $$FollowUsersHistoryTableTableManager(_db, _db.followUsersHistory);
  $$ChangeReportsTableTableManager get changeReports =>
      $$ChangeReportsTableTableManager(_db, _db.changeReports);
}


### FILE: ./services/secure_storage_service.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

final secureStorageServiceProvider = Provider((ref) => SecureStorageService());

class SecureStorageService {
  final _storage = const FlutterSecureStorage();

  static const _activeAccountIdKey = 'active_account_id';

  /// 保存指定 ID 的 cookie
  Future<void> saveCookie(String id, String cookie) async {
    try {
      // 使用账号 ID 作为 key 的一部分，确保唯一性
      await _storage.write(key: 'cookie_$id', value: cookie);
    } catch (e) {
      print("Error saving cookie for ID $id: $e");
      // 可以考虑向上抛出异常，让调用者知道失败了
      // throw Exception('Failed to save cookie: $e');
    }
  }

  /// 读取指定 ID 的 cookie
  Future<String?> getCookie(String id) async {
    try {
      return await _storage.read(key: 'cookie_$id');
    } catch (e) {
      print("Error reading cookie for ID $id: $e");
      return null;
    }
  }

  /// 删除指定 ID 的 cookie
  Future<void> deleteCookie(String id) async {
    try {
      await _storage.delete(key: 'cookie_$id');
    } catch (e) {
      print("Error deleting cookie for ID $id: $e");
      // 可以考虑向上抛出异常
      // throw Exception('Failed to delete cookie: $e');
    }
  }

  /// 读取所有存储的 cookies，返回一个 Map<String, String> (ID -> Cookie)
  Future<Map<String, String>> getAllCookies() async {
    try {
      // 读取所有 secure storage 中的键值对
      final allValues = await _storage.readAll();
      final Map<String, String> cookies = {};
      // 筛选出以 'cookie_' 开头的键
      allValues.forEach((key, value) {
        if (key.startsWith('cookie_')) {
          // 提取 ID (去掉 'cookie_' 前缀)
          final id = key.substring('cookie_'.length);
          cookies[id] = value;
        }
      });
      return cookies;
    } catch (e) {
      print("Error reading all cookies: $e");
      return {}; // 出错时返回空 Map
    }
  }

  Future<String?> readActiveAccountId() async {
    try {
      return await _storage.read(key: _activeAccountIdKey);
    } catch (e) {
      print("Error reading active account ID: $e");
      return null;
    }
  }

  Future<void> saveActiveAccountId(String id) async {
    try {
      await _storage.write(key: _activeAccountIdKey, value: id);
    } catch (e) {
      print("Error saving active account ID: $e");
    }
  }

  Future<void> deleteActiveAccountId() async {
    try {
      await _storage.delete(key: _activeAccountIdKey);
    } catch (e) {
      print("Error deleting active account ID: $e");
    }
  }
}


### FILE: ./services/settings_service.dart
import 'dart:convert'; // 用于 JSON 编解码
import 'package:shared_preferences/shared_preferences.dart'; // 导入插件
import '../models/app_settings.dart'; // 导入设置模型

/// 用于加载和保存应用设置的服务类。
class SettingsService {
  // 用于在 shared_preferences 中存储设置的键
  static const _settingsKey = 'app_settings_v1'; 

  /// 从 shared preferences 加载设置。
  /// 如果找不到或发生错误，则返回默认设置。
  Future<AppSettings> loadSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonString = prefs.getString(_settingsKey);
      if (jsonString != null) {
        // 如果找到了 JSON 字符串，解码并用 fromJson 创建 AppSettings 对象
        final jsonMap = jsonDecode(jsonString) as Map<String, dynamic>;
        return AppSettings.fromJson(jsonMap);
      }
    } catch (e) {
      // 记录错误或处理损坏的数据
      print('加载设置时出错: $e');
    }
    // 如果加载失败或不存在设置，则返回默认设置
    return AppSettings();
  }

  /// 将给定的设置保存到 shared preferences。
  Future<void> saveSettings(AppSettings settings) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      // 将 AppSettings 对象用 toJson 转换为 JSON Map，然后编码为字符串
      final jsonString = jsonEncode(settings.toJson());
      // 将 JSON 字符串保存到 shared preferences
      await prefs.setString(_settingsKey, jsonString);
    } catch (e) {
      // 记录错误或处理保存失败
      print('保存设置时出错: $e');
    }
  }
}

### FILE: ./services/twitter_api_service.dart
import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final twitterApiServiceProvider = Provider((ref) => TwitterApiService());

class TwitterApiService {
  final Dio _dio;

  TwitterApiService() : _dio = Dio() {
    // 在这里可以为 Dio 设置一些基础配置，比如超时时间
    //_dio.options.connectTimeout = const Duration(seconds: 10);
    //_dio.options.receiveTimeout = const Duration(seconds: 10);
  }

  /// 从 Cookie 字符串中解析 'ct0' CSRF token。
  String? _parseCsrfToken(String cookie) {
    try {
      final parts = cookie.split(';');
      final csrfPart = parts.firstWhere(
        (part) => part.trim().startsWith('ct0='),
        orElse: () => '',
      );
      if (csrfPart.isNotEmpty) {
        final token = csrfPart.split('=')[1].trim();
        return token.isNotEmpty ? token : null;
      }
    } catch (e) {
      print("解析 ct0 token 失败: $e");
    }
    return null;
  }

  /// 通过 Rest ID (twid) 获取用户 Profile 信息
  ///
  /// 成功时返回解码后的 JSON Map，失败时抛出异常。
  Future<Map<String, dynamic>> getUserByRestId(
    String userId,
    String cookie,
  ) async {
    final csrfToken = _parseCsrfToken(cookie);
    if (csrfToken == null) {
      throw Exception("无法从 Cookie 中解析出 x-csrf-token (ct0)");
    }

    // 1. 准备 Query Parameters
    final variables = {
      "userId": userId,
      // "withSafetyModeUserFields": true // 可以根据需要添加
    };

    final features = {
      "hidden_profile_subscriptions_enabled": true,
      "responsive_web_graphql_exclude_directive_enabled": true,
      "verified_phone_label_enabled": false,
      "highlights_tweets_tab_ui_enabled": true,
      "creator_subscriptions_tweet_preview_api_enabled": true,
      "responsive_web_graphql_skip_user_profile_image_extensions_enabled":
          false,
      "responsive_web_graphql_timeline_navigation_enabled": true,
      "rweb_tipjar_consumption_enabled": false,
      "subscriptions_feature_can_gift_premium": false,
      "payments_enabled": false,
      "responsive_web_twitter_article_notes_tab_enabled": false,
      "profile_label_improvements_pcf_label_in_post_enabled": false,
      "responsive_web_profile_redirect_enabled": false,
      // ... 可以从您提供的 URL 中复制更多 feature flags
    };

    final queryParameters = {
      'variables': jsonEncode(variables),
      'features': jsonEncode(features),
    };

    // 2. 准备 Headers
    final headers = {
      'authorization':
          'Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA',
      'x-csrf-token': csrfToken,
      'Cookie': cookie,
      // --- 从您命令中复制的其他 Headers ---
      'x-twitter-active-user': 'yes',
      'x-twitter-auth-type': 'OAuth2Session',
      'x-twitter-client-language': 'en',
      // --- 推荐添加的浏览器 Headers ---
      'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36',
      'Referer': 'https://x.com/',
    };

    // 3. 定义 URL
    const String url =
        'https://x.com/i/api/graphql/q9yeu7UlEs2YVx_-Z8Ps7Q/UserByRestId';

    try {
      // 4. 发送 GET 请求
      final response = await _dio.get(
        url,
        queryParameters: queryParameters,
        options: Options(headers: headers),
      );

      // 5. 检查响应并返回数据
      if (response.statusCode == 200 && response.data != null) {
        print(response.data);
        return response.data as Map<String, dynamic>;
      } else {
        throw Exception('获取用户信息失败: Status ${response.statusCode}');
      }
    } on DioException catch (e) {
      print("Dio Error on getUserByRestId: ${e.response?.data}");
      throw Exception('网络请求失败: ${e.message}');
    } catch (e) {
      // 捕获其他未知错误
      print("Unknown error on getUserByRestId: $e");
      throw Exception('发生未知错误');
    }
  }
}


### FILE: ./services/twitter_api_v1_service.dart
import 'dart:convert';
import 'dart:io'; // Import for PlatformException check maybe needed later
import 'dart:async'; // Import for Timer/Future.delayed
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final twitterApiV1ServiceProvider = Provider((ref) => TwitterApiV1Service());

class UserListResult {
  final List<Map<String, dynamic>> users;
  final String? nextCursor;
  UserListResult({required this.users, this.nextCursor});
}

class TwitterApiV1Service {
  final Dio _dio;
  // --- 新增：重试相关常量 ---
  static const int _maxRetries = 10000; // 最多重试次数
  static const Duration _retryDelay = Duration(seconds: 2); // 每次重试间隔
  // --- 新增结束 ---

  TwitterApiV1Service() : _dio = Dio() {
    _dio.options.connectTimeout = const Duration(seconds: 15);
    _dio.options.receiveTimeout = const Duration(seconds: 15);
    // 阻止 Dio 因为 404 抛出异常，我们手动检查状态码
    _dio.options.validateStatus = (status) {
       return status != null && status < 500; // 只让 5xx 服务器错误触发 DioException
    };
  }

  String? _parseCsrfToken(String cookie) {
    try {
      final parts = cookie.split(';');
      final csrfPart = parts.firstWhere(
        (part) => part.trim().startsWith('ct0='),
        orElse: () => '',
      );
      if (csrfPart.isNotEmpty) {
        final token = csrfPart.split('=')[1].trim();
        return token.isNotEmpty ? token : null;
      }
    } catch (e) {
      print("TwitterApiV1Service: Failed to parse ct0 token: $e");
    }
    return null;
  }

  Future<UserListResult> _fetchList(
      String endpoint, String userId, String cookie, String? cursor, int count, String listTypeLogName) async {
    final Map<String, dynamic> queryParameters = {
      'include_profile_interstitial_type': 0, 'include_blocking': 0,
      'include_blocked_by': 0, 'include_followed_by': 1,
      'include_want_retweets': 0, 'include_mute_edge': 0,
      'include_can_dm': 1, 'include_can_media_tag': 1,
      'include_ext_is_blue_verified': 1, 'include_ext_verified_type': 1,
      'include_ext_profile_image_shape': 0, 'skip_status': 1,
      'user_id': userId, 'count': count,
      // 'with_total_count': true, // Removed based on previous step
    };
    if (cursor != null && cursor != '0') {
      queryParameters['cursor'] = cursor;
    } else if (cursor == null) {
      queryParameters['cursor'] = "-1";
    }

    final csrfToken = _parseCsrfToken(cookie);
    if (csrfToken == null) {
      print("TwitterApiV1Service: FATAL - ct0 token not found in cookie for $listTypeLogName.");
      throw Exception("Cannot get ct0 token from cookie (x-csrf-token)");
    }

    final headers = {
      'accept': '*/*',
      'authorization': 'Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA',
      'Cookie': cookie, 'dnt': '1', 'priority': 'u=1, i',
      'sec-ch-ua': '"Not)A;Brand";v="8", "Chromium";v="138", "Google Chrome";v="138"',
      'sec-ch-ua-mobile': '?0', 'sec-ch-ua-platform': '"Linux"',
      'sec-fetch-dest': 'empty', 'sec-fetch-mode': 'cors', 'sec-fetch-site': 'same-origin',
      'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36',
      'x-csrf-token': csrfToken, 'x-twitter-active-user': 'yes',
      'x-twitter-auth-type': 'OAuth2Session', 'x-twitter-client-language': 'en',
      'Referer': 'https://x.com/',
    };

    int attempt = 0;
    while (attempt <= _maxRetries) {
      attempt++;
      print("TwitterApiV1Service: Fetching $listTypeLogName for $userId with cursor ${queryParameters['cursor']} (Attempt $attempt/$_maxRetries)...");

      try {
        final response = await _dio.get(
          endpoint,
          queryParameters: queryParameters,
          options: Options(headers: headers),
        );

        // --- 手动检查状态码 ---
        if (response.statusCode == 200 && response.data != null) {
          if (response.data is Map<String, dynamic>) {
            final Map<String, dynamic> data = response.data;
            final List<dynamic> userList = data['users'] ?? [];
            final dynamic nextCursorValue = data['next_cursor'] ?? data['next_cursor_str'];
            final String? nextCursor = nextCursorValue?.toString();
            final List<Map<String, dynamic>> usersMapList = userList.map((user) => user as Map<String, dynamic>).toList();
            return UserListResult(users: usersMapList, nextCursor: nextCursor); // 成功，返回结果
          } else {
             _logAndThrow("Error fetching $listTypeLogName - Unexpected response format: ${response.data}");
          }
        } else if (response.statusCode == 404) {
           _log("Warning: Received 404 fetching $listTypeLogName (Attempt $attempt). Retrying in ${_retryDelay.inSeconds}s...");
           if (attempt >= _maxRetries) {
               _logAndThrow("Failed fetching $listTypeLogName after $_maxRetries attempts (404).");
           }
           await Future.delayed(_retryDelay); // 等待后重试
           continue; // 继续下一次循环尝试
        } else if (response.statusCode == 403) {
            _logAndThrow('Authorization failed (403). Headers or Cookie might be incorrect/expired.');
        } else if (response.statusCode == 429) {
             _logAndThrow('Rate limit exceeded (429). Please wait and try again.');
        } else {
           // 其他 4xx 错误通常不可重试
           _logAndThrow('Failed to fetch $listTypeLogName: Status ${response.statusCode}, Data: ${response.data}');
        }
        // --- 检查结束 ---

      } on DioException catch (e) {
        // DioException 现在主要捕获 5xx 服务器错误或连接超时等
        _log("DioError fetching $listTypeLogName (Attempt $attempt): ${e.message}. Retrying in ${_retryDelay.inSeconds}s...");
        if (attempt >= _maxRetries) {
          _logAndThrow("Failed fetching $listTypeLogName after $_maxRetries attempts (Network/Server Error): ${e.message}");
        }
        await Future.delayed(_retryDelay); // 等待后重试
        continue; // 继续下一次循环尝试
      } catch (e) {
        // 捕获其他未知错误 (例如 JSON 解析错误)
         _log("Unknown error fetching $listTypeLogName (Attempt $attempt): $e. Retrying in ${_retryDelay.inSeconds}s...");
         if (attempt >= _maxRetries) {
            _logAndThrow("Failed fetching $listTypeLogName after $_maxRetries attempts (Unknown Error): $e");
         }
         await Future.delayed(_retryDelay); // 等待后重试
         continue; // 继续下一次循环尝试
      }
    }
    // 如果循环结束还没有返回，说明发生意外情况
    throw Exception('Failed to fetch $listTypeLogName after multiple retries.');
  }

  // --- 辅助方法用于日志记录和抛出异常 ---
  void _log(String message) {
     print("TwitterApiV1Service: $message");
  }

  Never _logAndThrow(String errorMessage) {
     print("TwitterApiV1Service: $errorMessage");
     throw Exception(errorMessage); // 抛出异常中断执行
  }
  // --- 辅助方法结束 ---


  Future<UserListResult> getFollowers(
    String userId,
    String cookie, {
    String? cursor,
    int count = 200,
  }) async {
    return _fetchList(
      'https://x.com/i/api/1.1/followers/list.json',
      userId, cookie, cursor, count, 'followers'
    );
  }

  Future<UserListResult> getFollowing(
    String userId,
    String cookie, {
    String? cursor,
    int count = 200,
  }) async {
     return _fetchList(
      'https://x.com/i/api/1.1/friends/list.json',
      userId, cookie, cursor, count, 'following'
    );
  }
}

### FILE: ./ui/accounts_page.dart
import 'package:autonitor/ui/auth/webview_login_page.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/auth_provider.dart';
import '../l10n/app_localizations.dart';
import '../models/account.dart';
import 'package:flutter/services.dart';

class AccountsPage extends ConsumerStatefulWidget {
  const AccountsPage({super.key});

  @override
  ConsumerState<AccountsPage> createState() => _AccountsPageState();
}

class _AccountsPageState extends ConsumerState<AccountsPage> {
  bool _isRefreshing = false;

  Future<void> _navigateAndAddAccount(BuildContext context) async {
    final source = await _showLoginOptions(context);
    if (source == null) return;

    String? cookie;
    if (source == 'browser') {
      cookie = await Navigator.push<String>(
        context,
        MaterialPageRoute(builder: (_) => const WebViewLoginPage()),
      );
    } else if (source == 'manual') {
      cookie = await _showManualInputDialog(context);
    }

    if (cookie != null && cookie.isNotEmpty) {
      await _handleLogin(cookie);
    }
  }

  Future<void> _confirmAndDelete(Account account) async {
    final l10n = AppLocalizations.of(context)!;
    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.delete),
        content: Text(l10n.confirm_delete_account(account.id)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
            onPressed: () => Navigator.pop(context, true),
            child: Text(l10n.delete),
          ),
        ],
      ),
    );
    if (confirmed == true && mounted) {
      ref.read(accountsProvider.notifier).removeAccount(account.id);
    }
  }

  Future<String?> _showLoginOptions(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.choose_login_method),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, 'manual'),
            child: Text(l10n.manual_cookie),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, 'browser'),
            child: Text(l10n.browser_login),
          ),
        ],
      ),
    );
  }

  Future<String?> _showManualInputDialog(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final controller = TextEditingController();
    return showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.manual_cookie),
        content: TextField(controller: controller, maxLines: 5),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(l10n.cancel),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, controller.text),
            child: Text(l10n.ok),
          ),
        ],
      ),
    );
  }

  Future<void> _handleLogin(String cookie) async {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final currentContext = context;
    showDialog(
      context: currentContext,
      barrierDismissible: false,
      builder: (dialogContext) => PopScope(
        canPop: false,
        child: AlertDialog(
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text(l10n.saving_account),
            ],
          ),
        ),
      ),
    );
    try {
      await ref.read(accountsProvider.notifier).addAccount(cookie);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              l10n.account_added_successfully,
              style: TextStyle(color: theme.colorScheme.onPrimaryContainer),
            ),
            backgroundColor: theme.colorScheme.primaryContainer,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              "$e",
              style: TextStyle(color: theme.colorScheme.onError),
            ),
            backgroundColor: theme.colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        Navigator.pop(currentContext);
      }
    }
  }

  Future<void> _refreshAllAccounts() async {
    if (_isRefreshing) return;

    // --- 获取 Theme 和 l10n ---
    final theme = Theme.of(context);
    // final l10n = AppLocalizations.of(context)!; // Keep if you add l10n later

    setState(() => _isRefreshing = true);
    final currentContext = context;
    final scaffoldMessenger = ScaffoldMessenger.of(currentContext);

    // --- 新增：显示模态加载对话框 ---
    showDialog(
      context: currentContext,
      barrierDismissible: false,
      builder: (dialogContext) => PopScope(
        canPop: false,
        child: AlertDialog(
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text('Refreshing accounts...'), // Add l10n later
            ],
          ),
        ),
      ),
    );
    
    try {
      final accountsToRefresh = ref.read(accountsProvider);
      if (accountsToRefresh.isEmpty) {
        // --- 修改 SnackBar 样式 ---
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              'No accounts to refresh.', // Add l10n later
              style: TextStyle(
                color: theme.colorScheme.onSecondaryContainer,
              ), // 信息文本颜色
            ),
            backgroundColor: theme.colorScheme.secondaryContainer, // 信息背景颜色
          ),
        );
        // 注意：因为没有异步操作，需要在这里手动关闭对话框
        if (mounted) Navigator.pop(currentContext);
        setState(() => _isRefreshing = false); // 别忘了重置状态
        return;
      }

      final results = await ref
          .read(accountsProvider.notifier)
          .refreshAllAccountProfiles(accountsToRefresh);

      // 刷新完成后，先重新加载数据
      if (mounted) {
        await ref.read(accountsProvider.notifier).loadAccounts();
      }

      // 处理结果并显示总结 SnackBar
      int successCount = results.where((r) => r.success).length;
      int failureCount = results.length - successCount;
      String summary =
          'Refresh complete: $successCount succeeded'; // Add l10n later
      bool hasFailures = failureCount > 0;
      if (hasFailures) {
        summary += ', $failureCount failed.'; // Add l10n later
        results.where((r) => !r.success).forEach((failure) {
          print("Refresh failed for ${failure.accountId}: ${failure.error}");
        });
      }
      // --- 修改 SnackBar 样式 ---
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text(
            summary,
            // 根据是否有失败使用不同颜色
            style: TextStyle(
              color: hasFailures
                  ? theme.colorScheme.onErrorContainer
                  : theme.colorScheme.onSecondaryContainer,
            ),
          ),
          backgroundColor: hasFailures
              ? theme.colorScheme.errorContainer
              : theme.colorScheme.secondaryContainer,
        ),
      );
    } catch (e) {
      print("Error during _refreshAllAccounts UI call: $e");
      // --- 修改 SnackBar 样式 ---
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text(
            'An unexpected error occurred during refresh.', // Add l10n later
            style: TextStyle(color: theme.colorScheme.onError), // 错误文本颜色
          ),
          backgroundColor: theme.colorScheme.error, // 错误背景颜色
        ),
      );
    } finally {
      // 确保无论如何都重置状态并关闭对话框
      if (mounted) {
        // 关闭模态对话框
        Navigator.pop(currentContext);
        // 重置刷新状态
        setState(() => _isRefreshing = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final accounts = ref.watch(accountsProvider);
    final activeAccount = ref.watch(activeAccountProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.accounts),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            tooltip: 'Refresh All Profiles', // Add l10n later
            onPressed: _isRefreshing ? null : _refreshAllAccounts,
          ),
        ],
      ),
      body: ListView.builder(
        itemCount: accounts.length + 1,
        itemBuilder: (context, index) {
          if (index == 0) {
            return Card(
              margin: const EdgeInsets.all(8.0),
              child: ListTile(
                leading: const Icon(Icons.add_circle_outline),
                title: Text(l10n.new_account),
                onTap: () => _navigateAndAddAccount(context),
              ),
            );
          }
          final account = accounts[index - 1];

          return Card(
            margin: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
            child: ListTile(
              leading: CircleAvatar(
                radius: 24,
                backgroundColor: Colors.transparent,
                child: Stack(
                  alignment: Alignment.center,
                  children: [
                    const Icon(Icons.person, size: 24),
                    if (account.avatarUrl != null &&
                        account.avatarUrl!.isNotEmpty)
                      ClipOval(
                        child: CachedNetworkImage(
                          imageUrl: account.avatarUrl!,
                          fit: BoxFit.cover,
                          width: 48,
                          height: 48,
                          fadeInDuration: const Duration(milliseconds: 300),
                          fadeOutDuration: const Duration(milliseconds: 100),
                          errorWidget: (context, url, error) =>
                              const SizedBox(),
                        ),
                      ),
                  ],
                ),
              ),
              title: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    account.name ?? 'Unknown Name',
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    "@${account.screenName ?? account.id ?? '...'}",
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Colors.grey.shade600,
                    ),
                  ),
                  Text(
                    "ID: ${account.id ?? '...'}",
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Colors.grey.shade600,
                    ),
                  ),
                ],
              ),
              trailing: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  IconButton(
                    icon: const Icon(Icons.cookie_outlined),
                    tooltip: l10n.view_cookie,
                    onPressed: () {
                      final theme = Theme.of(context);
                      final l10n = AppLocalizations.of(context)!;
                      showDialog(
                        context: context,
                        builder: (dialogContext) => AlertDialog(
                          title: Text(l10n.cookie),
                          content: Container(
                            width: double.maxFinite,
                            constraints: BoxConstraints(
                              maxHeight:
                                  MediaQuery.of(context).size.height * 0.6,
                            ),
                            decoration: BoxDecoration(
                              color: theme.colorScheme.surfaceContainerHighest,
                              borderRadius: BorderRadius.circular(8.0),
                            ),
                            child: SingleChildScrollView(
                              padding: const EdgeInsets.all(8.0),
                              child: TextField(
                                controller: TextEditingController(
                                  text: account.cookie,
                                ),
                                readOnly: true,
                                maxLines: null,
                                decoration: InputDecoration.collapsed(
                                  hintText: null,
                                ),
                                style: TextStyle(
                                  fontFamily: 'monospace',
                                  fontSize: 12,
                                  color: theme.colorScheme.onSurfaceVariant,
                                ),
                              ),
                            ),
                          ),
                          actions: [
                            TextButton(
                              child: Text(l10n.copy),
                              onPressed: () {
                                Clipboard.setData(
                                  ClipboardData(text: account.cookie),
                                );
                                Navigator.pop(dialogContext);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      l10n.copied_to_clipboard,
                                      style: TextStyle(
                                        color: theme
                                            .colorScheme
                                            .onPrimaryContainer,
                                      ),
                                    ),
                                    backgroundColor:
                                        theme.colorScheme.primaryContainer,
                                  ),
                                );
                              },
                            ),
                            ElevatedButton(
                              onPressed: () => Navigator.pop(dialogContext),
                              child: Text(l10n.ok),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                  IconButton(
                    icon: Icon(
                      Icons.delete_outline,
                      color: Theme.of(context).colorScheme.error,
                    ),
                    tooltip: l10n.delete,
                    onPressed: () {
                      _confirmAndDelete(account);
                    },
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}


### FILE: ./ui/auth/package.flutter/material.dart
// TODO Implement this library.

### FILE: ./ui/auth/webview_login_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import '../../l10n/app_localizations.dart';

class WebViewLoginPage extends StatefulWidget {
  const WebViewLoginPage({super.key});

  @override
  State<WebViewLoginPage> createState() => _WebViewLoginPageState();
}

class _WebViewLoginPageState extends State<WebViewLoginPage> {
  final Uri _url = Uri.parse('https://x.com/login');
  final CookieManager _cookieManager = CookieManager.instance();

  bool _hasFoundAuthTokenInLastCheck = false;

  Future<void> _onLoginComplete() async {
    if (!mounted) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) =>
          const Center(child: CircularProgressIndicator(strokeWidth: 2)),
    );

    try {
      final WebUri targetUrl = WebUri("https://x.com");

      List<Cookie> gotCookies; // 将 gotCookies 提到 try 块之前

      try {
        // 尝试获取 cookie
        gotCookies = await _cookieManager.getCookies(url: targetUrl);
      } catch (e, s) { // --- 修改点 1：捕获所有 Error 和 Exception ---
        // [已修改] 捕获 *所有* 异常和错误 (StateError, PlatformException, Error, etc.)
        // 只要 getCookies 失败，就视为空列表，让后续逻辑处理 "No cookie found" 提示。
        debugPrint("Error during getCookies, treating as empty list: $e\n$s");
        gotCookies = []; // 手动设置为空列表
      }

      // 先关闭加载圈
      if (!mounted) return;
      // 这一行现在是安全的，因为内部的catch会捕获所有错误
      Navigator.pop(context);

      // 检查 cookie 是否存在 (现在的 gotCookies 可能是 [] 了)
      if (gotCookies.isEmpty) {
        if (!mounted) return;
        final l10n = AppLocalizations.of(context)!;
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text(l10n.no_cookie_found)));
        return;
      }

      // 是否有 auth_token
      final bool hasAuthToken = gotCookies.any((c) => c.name == 'auth_token');
      _hasFoundAuthTokenInLastCheck = hasAuthToken;

      if (!hasAuthToken) {
        if (!mounted) return;
        final l10n = AppLocalizations.of(context)!;
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text(l10n.no_auth_token_found)));
        return;
      }

      // 构造 cookie 字符串
      final String finalCookieString = gotCookies
          .map((c) => '${c.name}=${c.value}')
          .join('; ');

      // 弹出确认框
      final l10n = AppLocalizations.of(context)!;
      final bool? isConfirmed = await showDialog<bool>(
        context: context,
        builder: (context) {
          return AlertDialog(
            title: Text(l10n.cookie),
            content: SingleChildScrollView(
              child: SelectableText(
                finalCookieString,
                style: const TextStyle(fontSize: 12),
              ),
            ),
            actions: [
              TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.pop(context, false),
              ),
              ElevatedButton(
                child: Text(l10n.ok),
                onPressed: () => Navigator.pop(context, true),
              ),
            ],
          );
        },
      );

      if (isConfirmed == true && mounted) {
        Navigator.pop(context, finalCookieString);
      }
    } catch (e, s) { // --- 修改点 2：捕获所有 Error 和 Exception ---
      debugPrint("Unhandled error in _onLoginComplete: $e\n$s");
      if (mounted) Navigator.pop(context); // 关闭加载圈
      if (mounted) {
        // 其他未预料到的错误仍会在这里显示
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text("$e")));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.browser_login),
        actions: [
          if (_hasFoundAuthTokenInLastCheck)
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: Tooltip(
                message: l10n.found_auth_token_last_check,
                child: const Icon(Icons.check_circle, color: Colors.green),
              ),
            ),
          TextButton(
            onPressed: _onLoginComplete,
            child: Text(l10n.im_logged_in),
          ),
        ],
      ),
      body: InAppWebView(
        initialUrlRequest: URLRequest(url: WebUri.uri(_url)),
        initialSettings: InAppWebViewSettings(
          clearSessionCache: true,
          clearCache: true,
        ),
      ),
    );
  }
}



### FILE: ./ui/commits_page.dart
import 'package:flutter/material.dart';
import '../l10n/app_localizations.dart'; 
class CommitsPage extends StatelessWidget {
  const CommitsPage({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    
    return Scaffold(
      // 3. 添加 AppBar
      appBar: AppBar(
        title: Text(l10n.data),
      ),
      body: const Center(
        child: Text('Data Page - Coming Soon'),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // TODO: 在这里添加点击搜索按钮的逻辑
        },
        child: const Icon(Icons.search),
      ),
    );
  }
}

### FILE: ./ui/home_page.dart
import 'package:autonitor/ui/user_detail_page.dart';
import 'package:autonitor/models/twitter_user.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// Note: DataProcessor import might become unused if cacheProvider logic changes
// import 'package:autonitor/core/data_processor.dart';
import 'package:autonitor/models/cache_data.dart'; // Keep for now
import 'package:autonitor/providers/auth_provider.dart';
import 'package:autonitor/ui/user_list_page.dart';
import '../l10n/app_localizations.dart';
import 'package:cached_network_image/cached_network_image.dart';

// --- (Providers... keeping existing ones for now, might refactor later) ---
// TODO: Refactor userListProvider and cacheProvider to use ChangeReport data

final userListProvider = FutureProvider.family
    .autoDispose<List<TwitterUser>, String>((ref, category) async {
      // --- TEMPORARY MOCK LOGIC ---
      // This needs to be completely replaced with logic that queries ChangeReport
      // and then fetches user details from FollowUsers table based on the IDs.
      print(
        "userListProvider: MOCK - Returning empty list for category '$category'",
      );
      await Future.delayed(const Duration(milliseconds: 50)); // Simulate async
      return [];
      // --- END TEMP MOCK ---
    });

// dataProcessorProvider might become obsolete if logic moves entirely to AccountsNotifier
final dataProcessorProvider = Provider.autoDispose<dynamic /*DataProcessor?*/>((
  ref,
) {
  // final activeAccount = ref.watch(activeAccountProvider);
  // if (activeAccount == null) return null;
  // // Need to pass services and log callback here if DataProcessor is kept
  // return null; //DataProcessor(account: activeAccount);
  return null; // Temporarily disable
});

// cacheProvider needs complete refactoring to query ChangeReport counts
final cacheProvider = FutureProvider.autoDispose<CacheData?>((ref) async {
  // --- TEMPORARY MOCK LOGIC ---
  // This should query counts from ChangeReport table based on activeAccountProvider.
  final activeAccount = ref.watch(activeAccountProvider);
  if (activeAccount == null) return null;
  print("cacheProvider: MOCK - Returning placeholder CacheData");
  await Future.delayed(const Duration(milliseconds: 100)); // Simulate async
  return CacheData(
    accountId: activeAccount.id,
    accountName: activeAccount.name ?? 'Mock Name',
    lastUpdateTime: DateTime.now().toIso8601String(),
    followersCount: 10, // Mock count
    followingCount: 5, // Mock count
    unfollowedCount: 2, // Mock count (normal_unfollowed)
    mutualUnfollowedCount: 1, // Mock count
    singleUnfollowedCount: 1, // Mock count (oneway_unfollowed)
    frozenCount: 0, // Mock count (suspended)
    deactivatedCount: 0, // Mock count
    refollowedCount: 1, // Mock count (be_followed_back)
    newFollowersCount:
        3, // Mock count (new_followers_following - combine relevant types)
  );
  // --- END TEMP MOCK ---
});
// --- (Providers End) ---

// --- Converted to ConsumerStatefulWidget ---
class HomePage extends ConsumerStatefulWidget {
  final VoidCallback onNavigateToAccounts;

  const HomePage({super.key, required this.onNavigateToAccounts});

  @override
  ConsumerState<HomePage> createState() => _HomePageState();
}

class _HomePageState extends ConsumerState<HomePage> {
  // --- Helper methods moved inside State ---
  void _showAccountSwitcher(BuildContext context) {
    // Removed WidgetRef ref, use this.ref
    final l10n = AppLocalizations.of(context)!;
    final allAccounts = ref.read(accountsProvider);
    final activeAccount = ref.read(activeAccountProvider);

    showModalBottomSheet(
      context: context,
      builder: (context) {
        return ListView(
          shrinkWrap: true,
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Text(
                l10n.switch_account,
                style: Theme.of(context).textTheme.titleLarge,
              ),
            ),
            ...allAccounts.map((account) {
              return ListTile(
                leading: SizedBox(
                  width: 48,
                  height: 48,
                  child: Stack(
                    alignment: Alignment.center,
                    children: [
                      Container(
                        alignment: Alignment.center,
                        child: const Icon(Icons.person, size: 24),
                      ),
                      if (account.avatarUrl != null &&
                          account.avatarUrl!.isNotEmpty)
                        ClipOval(
                          child: CachedNetworkImage(
                            imageUrl: account.avatarUrl!,
                            fadeInDuration: const Duration(milliseconds: 300),
                            placeholder: (context, url) =>
                                const SizedBox.shrink(),
                            errorWidget: (context, url, error) =>
                                const SizedBox.shrink(),
                            imageBuilder: (context, imageProvider) {
                              return Container(
                                width: 48,
                                height: 48,
                                decoration: BoxDecoration(
                                  image: DecorationImage(
                                    image: imageProvider,
                                    fit: BoxFit.cover,
                                  ),
                                ),
                              );
                            },
                          ),
                        ),
                      if (account.id == activeAccount?.id)
                        Positioned(
                          right: 0,
                          bottom: 0,
                          child: Container(
                            width: 18,
                            height: 18,
                            decoration: const BoxDecoration(
                              color: Colors.white,
                              shape: BoxShape.circle,
                            ),
                            child: const Icon(
                              Icons.check_circle,
                              color: Colors.green,
                              size: 16,
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
                title: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      account.name ?? 'Unknown Name',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      "@${account.screenName ?? account.id ?? '...'}",
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Colors.grey.shade600,
                      ),
                    ),
                    Text(
                      "ID: ${account.id ?? '...'}",
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Colors.grey.shade600,
                      ),
                    ),
                  ],
                ),
                trailing: null,
                onTap: () {
                  ref.read(activeAccountProvider.notifier).setActive(account);
                  Navigator.pop(context);
                },
              );
            }),
          ],
        );
      },
    );
  }

  Future<void> _navigateToUserList(
    BuildContext context,
    // WidgetRef ref, // Use this.ref inside stateful widget
    String categoryKey,
  ) async {
    print(
      '--- HomePage: Navigating to UserListPage for category key: $categoryKey ---',
    );
    // TODO: Pass necessary info (like ownerId) for UserListPage to fetch data
    Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => UserListPage(title: categoryKey)),
    );
  }

  Widget _buildNoAccountState(BuildContext context, VoidCallback onNavigate) {
    final l10n = AppLocalizations.of(context)!;
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.group_outlined, size: 64, color: Colors.grey.shade400),
            const SizedBox(height: 24),
            Text(
              l10n.login_first,
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(l10n.login_first_description, textAlign: TextAlign.center),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              icon: const Icon(Icons.login),
              label: Text(l10n.log_in),
              onPressed: onNavigate, // Use the callback passed to the widget
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 12,
                ),
                textStyle: Theme.of(context).textTheme.titleMedium,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAccountView(BuildContext context) {
    // Removed WidgetRef ref
    final cacheAsyncValue = ref.watch(cacheProvider); // Use this.ref
    return cacheAsyncValue.when(
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('加载缓存失败: $err')),
      data: (cacheData) {
        if (cacheData == null) {
          return _buildEmptyCacheState(context); // Removed ref
        }
        return _buildDataDisplay(context, cacheData); // Removed ref
      },
    );
  }

  Widget _buildEmptyCacheState(BuildContext context) {
    // Removed WidgetRef ref
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Text("尚未生成分析数据"),
          const SizedBox(height: 20),
          ElevatedButton.icon(
            icon: const Icon(Icons.sync),
            onPressed: () => ref.invalidate(cacheProvider), // Use this.ref
            label: const Text("立即运行分析"),
          ),
        ],
      ),
    );
  }

  Widget _buildDataDisplay(
    BuildContext context,
    CacheData cache,
    // WidgetRef ref, // Use this.ref
  ) {
    final l10n = AppLocalizations.of(context)!;
    final activeAccount = ref.watch(activeAccountProvider); // Use this.ref

    return RefreshIndicator(
      onRefresh: () async => ref.invalidate(cacheProvider), // Use this.ref
      child: ListView(
        padding: const EdgeInsets.all(16.0),
        children: <Widget>[
          Card(
            clipBehavior: Clip.antiAlias,
            margin: EdgeInsets.zero,
            child: InkWell(
              onTap: () {
                if (activeAccount == null) return;
                final user = TwitterUser(
                  avatarUrl: activeAccount.avatarUrl ?? '',
                  name: activeAccount.name ?? 'Unknown',
                  id: activeAccount.screenName ?? activeAccount.id,
                  restId: activeAccount.id,
                  joinTime: activeAccount.joinTime ?? '',
                  bio: activeAccount.bio,
                  location: activeAccount.location,
                  bannerUrl: activeAccount.bannerUrl,
                  link: activeAccount.link,
                  followersCount: activeAccount.followersCount,
                  followingCount: activeAccount.followingCount,
                  statusesCount: activeAccount.statusesCount,
                  mediaCount: activeAccount.mediaCount,
                  favouritesCount: activeAccount.favouritesCount,
                  listedCount: activeAccount.listedCount,
                  latestRawJson: activeAccount.latestRawJson,
                );
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => UserDetailPage(user: user),
                  ),
                );
              },
              child: Column(
                children: [
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
                    child: Row(
                      children: [
                        Hero(
                          tag: 'avatar_${activeAccount?.id}',
                          child: CircleAvatar(
                            radius: 24,
                            backgroundColor: Colors.transparent,
                            child: Stack(
                              alignment: Alignment.center,
                              children: [
                                const Icon(Icons.person, size: 24),
                                if (activeAccount?.avatarUrl != null &&
                                    activeAccount!.avatarUrl!.isNotEmpty)
                                  ClipOval(
                                    child: CachedNetworkImage(
                                      imageUrl: activeAccount.avatarUrl!,
                                      fit: BoxFit.cover,
                                      width: 48,
                                      height: 48,
                                      fadeInDuration: const Duration(
                                        milliseconds: 300,
                                      ),
                                      fadeOutDuration: const Duration(
                                        milliseconds: 100,
                                      ),
                                      errorWidget: (context, url, error) =>
                                          const SizedBox(),
                                    ),
                                  ),
                              ],
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                activeAccount?.name ?? 'Unknown Name',
                                style: Theme.of(context).textTheme.titleMedium
                                    ?.copyWith(fontWeight: FontWeight.bold),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                              Text(
                                "@${activeAccount?.screenName ?? activeAccount?.id ?? '...'}",
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(color: Colors.grey.shade600),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                              Text(
                                "ID: ${activeAccount?.id ?? '...'}",
                                style: Theme.of(context).textTheme.bodySmall
                                    ?.copyWith(color: Colors.grey.shade600),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ],
                          ),
                        ),
                        IconButton(
                          icon: const Icon(Icons.swap_horiz),
                          tooltip: l10n.switch_account,
                          onPressed: () =>
                              _showAccountSwitcher(context), // Removed ref
                        ),
                      ],
                    ),
                  ),
                  const Divider(height: 1, indent: 0, endIndent: 0),
                  IntrinsicHeight(
                    child: Row(
                      children: [
                        Expanded(
                          child: InkWell(
                            onTap: () => _navigateToUserList(
                              context,
                              'following',
                            ), // Removed ref
                            child: Padding(
                              padding: const EdgeInsets.symmetric(
                                vertical: 12.0,
                              ),
                              child: Column(
                                children: [
                                  Text(
                                    cache.followingCount.toString(),
                                    style: Theme.of(context)
                                        .textTheme
                                        .titleMedium
                                        ?.copyWith(fontWeight: FontWeight.bold),
                                  ),
                                  const SizedBox(height: 2),
                                  Text(
                                    l10n.following,
                                    style: Theme.of(
                                      context,
                                    ).textTheme.bodySmall,
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                        const VerticalDivider(width: 1),
                        Expanded(
                          child: InkWell(
                            onTap: () => _navigateToUserList(
                              context,
                              'followers',
                            ), // Removed ref
                            child: Padding(
                              padding: const EdgeInsets.symmetric(
                                vertical: 12.0,
                              ),
                              child: Column(
                                children: [
                                  Text(
                                    cache.followersCount.toString(),
                                    style: Theme.of(context)
                                        .textTheme
                                        .titleMedium
                                        ?.copyWith(fontWeight: FontWeight.bold),
                                  ),
                                  const SizedBox(height: 2),
                                  Text(
                                    l10n.followers,
                                    style: Theme.of(
                                      context,
                                    ).textTheme.bodySmall,
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 24),
          Card(
            margin: EdgeInsets.zero,
            child: Column(
              children: [
                // TODO: Update these counts to query ChangeReport or similar
                _buildDetailListItem(
                  context,
                  'normal_unfollowed',
                  Icons.person_remove_outlined,
                  l10n.normal_unfollowed,
                  cache.unfollowedCount,
                ),
                _buildDetailListItem(
                  context,
                  'mutual_unfollowed',
                  Icons.group_off_rounded,
                  l10n.mutual_unfollowed,
                  cache.mutualUnfollowedCount,
                ),
                _buildDetailListItem(
                  context,
                  'oneway_unfollowed',
                  Icons.group_off_outlined,
                  l10n.oneway_unfollowed,
                  cache.singleUnfollowedCount,
                ),
                // Temporarily Restricted - Add new item
                _buildDetailListItem(
                  context,
                  'temporarily_restricted',
                  Icons.warning_amber_rounded,
                  'Temporarily Restricted',
                  0,
                ), // Add l10n later, count needs source
                _buildDetailListItem(
                  context,
                  'suspended',
                  Icons.lock_outline,
                  l10n.suspended,
                  cache.frozenCount,
                ),
                _buildDetailListItem(
                  context,
                  'deactivated',
                  Icons.no_accounts_outlined,
                  l10n.deactivated,
                  cache.deactivatedCount,
                ),
                _buildDetailListItem(
                  context,
                  'be_followed_back',
                  Icons.group_add_outlined,
                  l10n.be_followed_back,
                  cache.refollowedCount,
                ),
                _buildDetailListItem(
                  context,
                  'new_followers_following',
                  Icons.person_add_alt_1_outlined,
                  l10n.new_followers_following,
                  cache.newFollowersCount,
                  showDivider: false,
                ),
              ],
            ),
          ),
          const SizedBox(height: 80), // For FAB
        ],
      ),
    );
  }

  Widget _buildDetailListItem(
    BuildContext context,
    // WidgetRef ref, // Use this.ref
    String categoryKey,
    IconData icon,
    String label,
    int count, {
    bool showDivider = true,
  }) {
    return InkWell(
      onTap: () => _navigateToUserList(context, categoryKey), // Removed ref
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: 16.0,
              vertical: 12.0,
            ),
            child: Row(
              children: [
                Icon(icon, color: Theme.of(context).colorScheme.primary),
                const SizedBox(width: 16),
                Expanded(
                  child: Text(
                    label,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                ),
                Text(
                  count.toString(),
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: Theme.of(context).colorScheme.secondary,
                  ),
                ),
                const SizedBox(width: 8),
                const Icon(Icons.chevron_right, color: Colors.grey),
              ],
            ),
          ),
          if (showDivider) const Divider(height: 1, indent: 56),
        ],
      ),
    );
  }

  // --- build method moved to State ---
  @override
  Widget build(BuildContext context) {
    // Removed WidgetRef ref
    final l10n = AppLocalizations.of(context)!;
    final activeAccount = ref.watch(activeAccountProvider); // Use this.ref

    return Scaffold(
      appBar: AppBar(
        title: const Text('Autonitor'),
      ), // TODO: Use l10n.app_title
      body: activeAccount == null
          ? _buildNoAccountState(
              context,
              widget.onNavigateToAccounts,
            ) // Use widget.onNavigateToAccounts
          : _buildAccountView(context), // Removed ref

      floatingActionButton: activeAccount == null
          ? null
          : FloatingActionButton.extended(
              // --- Updated onPressed Logic ---
              onPressed: () async {
                final currentContext = context; // Save context before async gap
                final currentRef = ref; // Save ref before async gap
                final currentL10n = AppLocalizations.of(
                  currentContext,
                )!; // Save l10n
                final currentTheme = Theme.of(currentContext); // Save theme

                showDialog(
                  context: currentContext,
                  barrierDismissible: false,
                  builder: (dialogContext) => PopScope(
                    canPop: false,
                    child: AlertDialog(
                      title: Text('Analysis Log'), // TODO: Add l10n
                      content: SizedBox(
                        width: double.maxFinite,
                        height: MediaQuery.of(currentContext).size.height * 0.7,
                        child: Consumer(
                          // Use Consumer here to watch logs
                          builder: (context, ref, child) {
                            final logs = ref.watch(analysisLogProvider);
                            final ScrollController scrollController =
                                ScrollController();
                            WidgetsBinding.instance.addPostFrameCallback((_) {
                              if (scrollController.hasClients) {
                                scrollController.animateTo(
                                  scrollController.position.maxScrollExtent,
                                  duration: const Duration(milliseconds: 300),
                                  curve: Curves.easeOut,
                                );
                              }
                            });
                            return ListView.builder(
                              controller: scrollController,
                              itemCount: logs.length,
                              itemBuilder: (context, index) {
                                return Padding(
                                  padding: const EdgeInsets.symmetric(
                                    vertical: 2.0,
                                  ),
                                  child: Text(
                                    logs[index],
                                    style: TextStyle(fontSize: 10),
                                  ),
                                );
                              },
                            );
                          },
                        ),
                      ),
                      actions: [
                        TextButton(
                          child: Text(currentL10n.close),
                          onPressed: () {
                            // Consider adding logic to only allow closing when done
                            Navigator.pop(dialogContext);
                          },
                        ),
                      ],
                    ),
                  ),
                );

                try {
                  // 1. 读取当前的 activeAccount
                  final accountToProcess = currentRef.read(
                    activeAccountProvider,
                  );

                  // 2. 检查 activeAccount 是否存在
                  if (accountToProcess == null) {
                    throw Exception(
                      "Cannot run analysis: No account is active.",
                    );
                  }

                  // 3. 调用 notifier 方法并传递 account
                  await currentRef
                      .read(accountsProvider.notifier)
                      .runAnalysisProcess(accountToProcess);

                  // Optional Success SnackBar (...)
                } catch (e) {
                  // Error SnackBar (...)
                  // 可以在这里更具体地处理 "No account is active" 的错误
                  if (!currentContext.mounted) return;
                  ScaffoldMessenger.of(currentContext).showSnackBar(
                    SnackBar(
                      content: Text(
                        'Analysis failed: $e',
                        style: TextStyle(
                          color: currentTheme.colorScheme.onError,
                        ),
                      ),
                      backgroundColor: currentTheme.colorScheme.error,
                    ),
                  );
                } finally {
                  // Close Dialog (...)
                  // ... (finally 块内容保持不变) ...
                }
              },
              // --- End Updated onPressed ---
              label: Text(l10n.run),
              icon: const Icon(Icons.play_arrow),
            ),
    );
  }
} // <--- End _HomePageState


### FILE: ./ui/main_scaffold.dart
import 'package:flutter/material.dart';
import 'home_page.dart';
import 'commits_page.dart';
import 'accounts_page.dart';
import 'settings_page.dart';
import '../l10n/app_localizations.dart';

class MainScaffold extends StatefulWidget {
  const MainScaffold({super.key});

  @override
  State<MainScaffold> createState() => _MainScaffoldState();
}

class _MainScaffoldState extends State<MainScaffold> {
  int _selectedIndex = 0;

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    final List<Widget> pages = <Widget>[
      HomePage(onNavigateToAccounts: () => _onItemTapped(2)),
      CommitsPage(),
      AccountsPage(),
      SettingsPage(),
    ];

    final List<Widget> pagesWithVisibility = <Widget>[
      pages[0], // HomePage
      Visibility(
        visible: _selectedIndex == 1,
        maintainState: false,
        child: pages[1], // CommitsPage
      ),
      pages[2], // AccountsPage
      pages[3], // SettingsPage
    ];

    return Scaffold(
      body: IndexedStack(
        index: _selectedIndex,
        children: pagesWithVisibility,
      ),
      bottomNavigationBar: NavigationBar(
        selectedIndex: _selectedIndex,
        onDestinationSelected: _onItemTapped,
        labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        destinations: <NavigationDestination>[
          NavigationDestination(
            icon: const Icon(Icons.home_outlined),
            selectedIcon: const Icon(Icons.home),
            label: l10n.home,
          ),
          NavigationDestination(
            icon: const Icon(Icons.folder_outlined),
            selectedIcon: const Icon(Icons.folder_open_outlined),
            label: l10n.data,
          ),
          NavigationDestination(
            icon: const Icon(Icons.people_alt_outlined),
            selectedIcon: const Icon(Icons.people_alt),
            label: l10n.accounts,
          ),
          NavigationDestination(
            icon: const Icon(Icons.settings_outlined),
            selectedIcon: const Icon(Icons.settings),
            label: l10n.settings,
          ),
        ],
      ),
    );
  }
}


### FILE: ./ui/settings_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/settings_provider.dart';
import '../l10n/app_localizations.dart';

class SettingsPage extends ConsumerStatefulWidget {
  const SettingsPage({super.key});

  @override
  ConsumerState<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends ConsumerState<SettingsPage> {
  @override
  Widget build(BuildContext context) {
    // 1. 获取 l10n (您可能需要导入 'l10n/app_localizations.dart')
    final l10n = AppLocalizations.of(context)!;

    // 2. 监听 settingsProvider
    final settingsValue = ref.watch(settingsProvider);

    // 3. 返回一个 Scaffold
    return Scaffold(
      // 4. 添加 AppBar
      appBar: AppBar(title: Text(l10n.settings)),
      // 5. body 是之前的 .when() 逻辑
      body: settingsValue.when(
        // 加载中状态：显示一个加载指示器
        loading: () => const Center(child: CircularProgressIndicator()),
        // 错误状态：显示错误信息
        error: (error, stackTrace) => Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text('加载设置失败: $error'),
          ),
        ),
        // 数据加载成功状态
        data: (settings) {
          // 构建设置列表 UI
          return ListView(
            children: [
              Padding(
                padding: EdgeInsets.fromLTRB(16, 16, 16, 8),
                child: Text(
                  l10n.general,
                  style: TextStyle(fontSize: 12, color: Colors.grey),
                ),
              ),
              ListTile(
                title: Text(l10n.language),
                leading: Icon(Icons.language),
                trailing: DropdownButton<String>(
                  // 1. 当前选中的值：从 Provider 读取
                  value: settings.locale?.toLanguageTag() ?? 'Auto',

                  // 2. 下拉菜单的选项：创建一个包含所有可选语言的列表
                  items: const [
                    DropdownMenuItem<String>(
                      value: 'Auto',
                      child: Text('Auto'),
                    ),
                    DropdownMenuItem<String>(
                      value: 'en',
                      child: Text('English'),
                    ),
                    DropdownMenuItem<String>(
                      value: 'zh-CN',
                      child: Text('中文（中国）'),
                    ), // value 是 'zh-CN'
                    DropdownMenuItem<String>(
                      value: 'zh-TW',
                      child: Text('中文（台灣）'),
                    ), // value 是 'zh-TW'
                  ],

                  // 3. 当用户选择了新选项时的回调函数
                  onChanged: (String? newValue) {
                    if (newValue != null) {
                      Locale? newLocale; // 声明 newLocale
                      if (newValue == 'Auto') {
                        newLocale = null; // Auto 对应 null Locale
                      } else if (newValue == 'en') {
                        newLocale = const Locale('en');
                      } else if (newValue == 'zh-CN') {
                        newLocale = const Locale(
                          'zh',
                          'CN',
                        ); // 创建 Locale('zh', 'CN')
                      } else if (newValue == 'zh-TW') {
                        newLocale = const Locale('zh', 'TW');
                      }

                      // 调用 updateLocale 传入 Locale?
                      ref
                          .read(settingsProvider.notifier)
                          .updateLocale(newLocale);
                      // 更新提示文本（查找显示名称）
                      String displaySelected = 'Auto';
                      // Default
                      if (newValue == 'en') displaySelected = 'English';
                      if (newValue == 'zh-CN') displaySelected = '中文（中国）';
                      if (newValue == 'zh-TW') displaySelected = '中文（台灣）';
                    }
                  },

                  // 4. (可选) 移除下拉按钮下划线，让它更简洁
                  underline: Container(),
                ),
                // 从加载的设置中获取语言并显示
              ),
              // 未来可以在这里添加其他设置项...
            ],
          );
        },
      ),
    );
  }
}


### FILE: ./ui/user_detail_page.dart
import 'dart:math';
import 'package:cached_network_image/cached_network_image.dart';
import '../l10n/app_localizations.dart';
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';
import '../models/twitter_user.dart';
import 'dart:convert';
import 'package:flutter/services.dart';


class UserDetailPage extends StatelessWidget {
  final TwitterUser user;

  const UserDetailPage({super.key, required this.user});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    // 1024x341 的宽高比
    const double bannerAspectRatio = 1024 / 341;
    // 按钮高度(MD3 TonalButton 约 40) + 按钮与横幅间距(8)
    const double buttonOverhang = 48.0;
    // 头像半径(45) - 中心点距横幅底部的偏移(5) = 40
    const double avatarOverhang = 40.0;

    // 获取屏幕宽度
    final screenWidth = MediaQuery.of(context).size.width;
    // 计算动态的横幅高度
    final bannerHeight = screenWidth / bannerAspectRatio;
    // 计算 Stack 所需的总高度
    final stackTotalHeight = bannerHeight + max(avatarOverhang, buttonOverhang);

    return Scaffold(
      appBar: AppBar(
        title: Text(user.name),
        actions: [
          IconButton(
            icon: const Icon(Icons.history),
            tooltip: l10n.history,
            onPressed: () {
              // TODO: History 逻辑
            },
          ),
        ],
      ),
      body: ListView(
        padding: EdgeInsets.zero,
        children: [
          Stack(
            clipBehavior: Clip.none,
            // --- 修改 1: 设置对齐方式 ---
            alignment: Alignment.topCenter,
            children: [
              AspectRatio(
                aspectRatio: bannerAspectRatio,
                child: (user.bannerUrl ?? '').isNotEmpty
                    ? CachedNetworkImage(
                        imageUrl: user.bannerUrl!,
                        fit: BoxFit.cover,
                        // 添加一个占位符，保持灰色背景
                        placeholder: (context, url) =>
                            Container(color: Colors.grey.shade300),
                        // 加载失败时也显示灰色背景
                        errorWidget: (context, url, error) =>
                            Container(color: Colors.grey.shade300),
                      )
                    : Container(color: Colors.grey.shade300),
              ),
              Positioned(
                left: 16,
                bottom: -avatarOverhang,
                child: Hero(
                  tag: 'avatar_${user.restId}', // 使用与列表页相同的 tag
                  child: CircleAvatar(
                    radius: 45,
                    backgroundColor: Colors.white,
                    child: CircleAvatar(
                      radius: 42,
                      backgroundImage: user.avatarUrl.isNotEmpty
                          ? CachedNetworkImageProvider(user.avatarUrl)
                          : null,
                      child: user.avatarUrl.isEmpty
                          ? const Icon(Icons.person, size: 40)
                          : null,
                    ),
                  ),
                ),
              ),

              // --- 修改 2: 添加透明 SizedBox 撑开 Stack 点击区域 ---
            ],
          ),
          Padding(
            padding: const EdgeInsets.only(
              right: 16.0,
              top: 8.0,
            ), // top可调按钮垂直间距
            child: Align(
              alignment: Alignment.centerRight, // 靠右对齐
              child: FilledButton.tonalIcon(
                onPressed: () {
                  final rawJson = user.latestRawJson;
                  if (rawJson != null && rawJson.isNotEmpty) {
                    String formattedJson = rawJson; // 默认值
                    try {
                      // 尝试解码并重新编码以格式化
                      final dynamic jsonObj = jsonDecode(rawJson);
                      const encoder = JsonEncoder.withIndent('  '); // 2空格缩进
                      formattedJson = encoder.convert(jsonObj);
                    } catch (e) {
                      // 如果解码失败（理论上不应发生），则保持原始字符串
                      print("Error formatting JSON for display: $e");
                    }

                    showDialog(
                      context: context,
                      builder: (dialogContext) => AlertDialog(
                        // 使用硬编码标题或 l10n.json_title (如果添加了)
                        title: const Text('JSON'),
                        content: Container(
                          // 使用 Container 设置最大高度和背景色
                          width: double.maxFinite, // 尽可能宽
                          // 设置一个最大高度，防止 JSON 过长导致对话框无限高
                          // MediaQuery.of(context).size.height * 0.6 表示屏幕高度的 60%
                          constraints: BoxConstraints(
                            maxHeight: MediaQuery.of(context).size.height * 0.6,
                          ),
                          decoration: BoxDecoration(
                            // 使用 M3 风格的容器背景色
                            color: Theme.of(
                              context,
                            ).colorScheme.surfaceContainerHighest,
                            borderRadius: BorderRadius.circular(8.0), // 圆角
                          ),
                          child: SingleChildScrollView(
                            // 仍然需要滚动
                            padding: const EdgeInsets.all(
                              8.0,
                            ), // TextField 周围的内边距
                            child: TextField(
                              controller: TextEditingController(
                                text: formattedJson,
                              ), // 设置文本
                              readOnly: true, // 只读，不可编辑
                              maxLines: null, // 自动换行，显示所有内容
                              decoration: InputDecoration.collapsed(
                                // 移除边框和下划线
                                hintText: null, // 不需要提示文本
                              ),
                              style: TextStyle(
                                fontFamily: 'monospace', // 等宽字体
                                fontSize: 12,
                                // 使用 M3 风格的文本颜色
                                color: Theme.of(
                                  context,
                                ).colorScheme.onSurfaceVariant,
                              ),
                            ),
                          ),
                        ),
                        actions: <Widget>[
                          // 复制按钮
                          TextButton(
                            child: Text(l10n.copy), // 使用 l10n.copy
                            onPressed: () {
                              Clipboard.setData(
                                ClipboardData(text: formattedJson),
                              );
                              // 可选：显示一个 SnackBar 提示复制成功
                              Navigator.pop(dialogContext); // 关闭对话框
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(
                                    l10n.copied_to_clipboard,
                                    style: TextStyle(
                                      color: Theme.of(
                                        context,
                                      ).colorScheme.onPrimaryContainer,
                                    ),
                                  ),
                                  backgroundColor: Theme.of(
                                    context,
                                  ).colorScheme.primaryContainer,
                                ),
                              );
                            },
                          ),
                          // 确定按钮
                          ElevatedButton(
                            child: Text(l10n.ok), // 使用 l10n.ok
                            onPressed: () {
                              Navigator.pop(dialogContext); // 只关闭对话框
                            },
                          ),
                        ],
                      ),
                    );
                  } else {
                    // 如果没有 JSON 数据，可以显示一个提示
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text(l10n.no_json_data_available),
                      ), // 使用 l10n.no_json_data_available
                    );
                  }
                },
                style: FilledButton.styleFrom(
                  backgroundColor: Colors.pink.shade100,
                  foregroundColor: Colors.pink.shade800,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 18,
                    vertical: 8,
                  ), // 控制按钮大小
                ),
                icon: const Icon(Icons.description_outlined, size: 20),
                label: const Text('JSON'),
              ),
            ),
          ),

          // --- 修改 3: 移除之前多余的 SizedBox ---
          const SizedBox(height: 5),

          // --- 新增: 根据最大悬垂物添加必要的间距 ---
          // SizedBox(height: max(avatarOverhang, buttonOverhang) + 8), // 确保内容总是在头像/按钮下方（已减半间距）
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SelectableText(
                  user.name,
                  style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Text.rich(
                  TextSpan(
                    children: [
                      TextSpan(
                        text: '@',
                        style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                          color: Colors.grey.shade600,
                        ),
                      ),
                      WidgetSpan(
                        alignment: PlaceholderAlignment.baseline,
                        baseline: TextBaseline.alphabetic,
                        child: SelectableText(
                          user.id,
                          style: Theme.of(context).textTheme.bodyLarge
                              ?.copyWith(color: Colors.grey.shade600),
                        ),
                      ),
                    ],
                  ),
                ),

                const SizedBox(height: 4),
                SelectableText(
                  user.bio ?? '',
                  style: Theme.of(context).textTheme.bodyLarge,
                ),
              ],
            ),
          ),
          const SizedBox(height: 5),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Wrap(
              spacing: 16.0,
              runSpacing: 4.0,
              children: [
                if (user.location != null && user.location!.isNotEmpty)
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        Icons.location_on_outlined,
                        color: Colors.grey,
                        size: 16,
                      ),
                      const SizedBox(width: 4),
                      Flexible(
                        child: SelectableText(
                          user.location ?? '',
                          style: TextStyle(color: Colors.grey),
                        ),
                      ),
                    ],
                  ),
                if (user.link != null && user.link!.isNotEmpty)
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(Icons.link, color: Colors.grey, size: 16),
                      const SizedBox(width: 4),
                      Flexible(
                        child: InkWell(
                          onTap: () => _launchURL(context, user.link),
                          child: Text(
                            user.link ?? '',
                            style: TextStyle(
                              color: Colors.blue,
                              decoration: TextDecoration.underline,
                              decorationColor: Colors.blue,
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.calendar_month_outlined,
                      color: Colors.grey,
                      size: 16,
                    ),
                    const SizedBox(width: 4),
                    Flexible(
                      child: Text(
                        '${l10n.joined} ${user.joinTime ?? ''}',
                        style: TextStyle(color: Colors.grey),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: 16.0,
              vertical: 8.0,
            ),
            child: Wrap(
              spacing: 16.0,
              runSpacing: 4.0,
              children: [
                Text.rich(
                  TextSpan(
                    text: user.followingCount.toString(),
                    style: TextStyle(fontWeight: FontWeight.bold),
                    children: [
                      TextSpan(
                        text: ' ${l10n.following}',
                        style: TextStyle(
                          fontWeight: FontWeight.normal,
                          color: Colors.grey,
                        ),
                      ),
                    ],
                  ),
                ),
                Text.rich(
                  TextSpan(
                    text: user.followersCount.toString(),
                    style: TextStyle(fontWeight: FontWeight.bold),
                    children: [
                      TextSpan(
                        text: ' ${l10n.followers}',
                        style: TextStyle(
                          fontWeight: FontWeight.normal,
                          color: Colors.grey,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          // —— View on Twitter（两列、标签水平对齐、图标非灰色、链接最多两行） —— //
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 8, 16, 4),
            child: Text(
              l10n.view_on_twitter,
              style: TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start, // 顶部对齐，保证两个标签水平对齐
              children: [
                // 第一列：ByScreenName
                Expanded(
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Icon(
                        Icons.link,
                        color: Theme.of(context).colorScheme.primary, // 非灰色
                        size: 16,
                      ),
                      const SizedBox(width: 6),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'ByScreenName',
                              style: TextStyle(fontSize: 12),
                            ),
                            const SizedBox(height: 4),
                            InkWell(
                              onTap: () => _launchURL(
                                context,
                                'https://x.com/${user.id}',
                              ),
                              child: Text(
                                'https://x.com/${user.id}',
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                                style: const TextStyle(
                                  color: Colors.blue,
                                  decoration: TextDecoration.underline,
                                  decorationColor: Colors.blue,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),

                const SizedBox(width: 12),

                // 第二列：ByRestId
                Expanded(
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Icon(
                        Icons.link,
                        color: Theme.of(context).colorScheme.primary,
                        size: 16,
                      ),
                      const SizedBox(width: 6),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text('ByRestId', style: TextStyle(fontSize: 12)),
                            const SizedBox(height: 4),
                            InkWell(
                              onTap: () => _launchURL(
                                context,
                                'https://x.com/intent/user?user_id=${user.restId}',
                              ),
                              child: Text(
                                'https://x.com/intent/user?user_id=${user.restId}',
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                                style: const TextStyle(
                                  color: Colors.blue,
                                  decoration: TextDecoration.underline,
                                  decorationColor: Colors.blue,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),

          // —— 原有 Metadata 与指标 —— //
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 4, 1, 0),
            child: Text(
              l10n.metadata,
              style: TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ),
          _buildInfoTile(
            context,
            Icons.create,
            l10n.tweets,
            user.statusesCount.toString(),
          ),
          _buildInfoTile(
            context,
            Icons.image,
            l10n.media_count,
            user.mediaCount.toString(),
          ),
          _buildInfoTile(
            context,
            Icons.favorite,
            l10n.likes,
            user.favouritesCount.toString(),
          ),
          _buildInfoTile(
            context,
            Icons.list_alt,
            l10n.listed_count,
            user.listedCount.toString(),
          ),

          Padding(
            padding: const EdgeInsets.fromLTRB(16, 4, 1, 0),
            child: Text(
              l10n.identity,
              style: TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ),
          _buildInfoTile(context, Icons.fingerprint, "Rest ID", user.restId),
        ],
      ),
    );
  }

  void _launchURL(BuildContext context, String? urlString) async {
    if (urlString == null || urlString.isEmpty) {
      return;
    }
    final Uri? uri = Uri.tryParse(urlString);
    if (uri == null) {
      if (context.mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('无法打开链接: 格式错误')));
      }
      return;
    }
    try {
      await launchUrl(uri, mode: LaunchMode.platformDefault);
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('无法打开链接: $e')));
      }
    }
  }

  Widget _buildInfoTile(
    BuildContext context,
    IconData icon,
    String title,
    String subtitle, {
    bool isUrl = false,
  }) {
    return ListTile(
      leading: Icon(icon, color: Theme.of(context).colorScheme.primary),
      title: Text(title),
      subtitle: SelectableText(
        subtitle,
        style: TextStyle(color: isUrl ? Colors.blue : null),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16.0),
    );
  }
}


### FILE: ./ui/user_list_page.dart
import 'package:autonitor/ui/home_page.dart'; // 导入 home_page.dart (如果 Provider 在那里)
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart'; // 添加 riverpod 导入
import '../models/twitter_user.dart';
import '../l10n/app_localizations.dart';
import 'user_detail_page.dart';
// import '../providers/user_list_provider.dart'; // 如果单独创建了文件

// --- 修改：改为 ConsumerWidget ---
class UserListPage extends ConsumerWidget {
  final String title;
  // --- 修改：移除 users 参数 ---
  // final List<TwitterUser> users;

  // --- 修改：构造函数只接收 title ---
  const UserListPage({super.key, required this.title});

  @override
  // --- 修改：添加 WidgetRef ref ---
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    // --- 修改：监听 Provider 状态 ---
    final userListAsyncValue = ref.watch(userListProvider(title));

    return Scaffold(
      appBar: AppBar(title: Text(title)),
      // --- 修改：使用 AsyncValue.when 处理状态 ---
      body: userListAsyncValue.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stackTrace) => Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text('$error'),
          ),
        ),
        data: (users) {
          // 注意这里的 users 是从 data 中获取的
          if (users.isEmpty) {
            return Center(child: Text(l10n.empty_list_message));
          }
          // 列表有数据时，显示 ListView.builder
          return ListView.builder(
            itemCount: users.length,
            itemBuilder: (context, index) {
              final user = users[index];
              return ListTile(
                leading: Hero(
                  tag: 'avatar_${user.restId}',
                  child: CircleAvatar(
                    backgroundImage: user.avatarUrl.isNotEmpty
                        ? NetworkImage(user.avatarUrl)
                        : null,
                    child: user.avatarUrl.isEmpty
                        ? const Icon(Icons.person)
                        : null,
                  ),
                ),
                title: Text(user.name),
                subtitle: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text("@${user.id}"),
                    Text(
                      user.bio ?? '',
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
                trailing: const Icon(Icons.chevron_right),
                onTap: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => UserDetailPage(user: user),
                    ),
                  );
                },
              );
            },
          );
        },
      ),
    );
  }
}


### FILE: ./utils/diff_utils.dart
import 'dart:convert';

/// 特殊标记，用于表示一个键在新 JSON 中存在但在旧 JSON 中不存在，
/// 因此在反向补丁中需要被删除。
const _keyToBeRemovedMarker = '__KEY_TO_BE_REMOVED__';

/// 计算两个 JSON 字符串之间的反向差异。
/// 返回一个 JSON 字符串，表示从 newJsonString 变回 oldJsonString 所需的补丁。
/// 如果没有差异，则返回 null。
String? calculateReverseDiff(String? newJsonString, String? oldJsonString) {
  if (oldJsonString == null || oldJsonString.isEmpty) {
    // 如果没有旧版本，则无法计算差异
    return null;
  }
  if (newJsonString == null || newJsonString.isEmpty) {
    // 如果新版本为空，则反向补丁就是旧版本本身（理论上不应发生）
    return oldJsonString;
  }

  try {
    final newJson = jsonDecode(newJsonString);
    final oldJson = jsonDecode(oldJsonString);

    if (newJson is! Map<String, dynamic> || oldJson is! Map<String, dynamic>) {
      // 只处理 Map 类型的 JSON 对象
      if (newJsonString != oldJsonString) {
        // 如果顶层不是 Map 且内容不同，返回整个旧 JSON 作为补丁
        return oldJsonString;
      }
      return null; // 内容相同
    }

    final diff = _compareMaps(newJson, oldJson);

    if (diff.isEmpty) {
      return null; // 没有差异
    }

    return jsonEncode(diff);
  } catch (e) {
    print("Error calculating JSON diff: $e");
    // 发生错误时，保守起见不生成补丁
    return null;
  }
}

/// 递归比较两个 Map 并生成反向差异。
Map<String, dynamic> _compareMaps(Map<String, dynamic> newMap, Map<String, dynamic> oldMap) {
  final diff = <String, dynamic>{};
  final allKeys = {...newMap.keys, ...oldMap.keys}; // 获取所有键的并集

  for (final key in allKeys) {
    final newValue = newMap[key];
    final oldValue = oldMap[key];

    if (oldMap.containsKey(key) && !newMap.containsKey(key)) {
      // 键只在旧 Map 中存在 (在新 Map 中被删除) -> 反向补丁记录旧值
      diff[key] = oldValue;
    } else if (newMap.containsKey(key) && !oldMap.containsKey(key)) {
      // 键只在新 Map 中存在 (是新增的) -> 反向补丁记录删除标记
      diff[key] = _keyToBeRemovedMarker;
    } else if (newMap.containsKey(key) && oldMap.containsKey(key)) {
      // 键在两者中都存在
      if (newValue is Map<String, dynamic> && oldValue is Map<String, dynamic>) {
        // 如果值都是 Map，递归比较
        final nestedDiff = _compareMaps(newValue, oldValue);
        if (nestedDiff.isNotEmpty) {
          diff[key] = nestedDiff;
        }
      } else if (!_areEqual(newValue, oldValue)) {
         // 如果值不同 (且不是 Map)，反向补丁记录旧值
         diff[key] = oldValue;
      }
      // 如果值相同，则忽略，不加入 diff
    }
  }

  return diff;
}

/// 比较两个值是否相等 (考虑 List 和 Map 的深比较)
bool _areEqual(dynamic a, dynamic b) {
  if (a is Map && b is Map) {
    if (a.length != b.length) return false;
    for (final key in a.keys) {
      if (!b.containsKey(key) || !_areEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  } else if (a is List && b is List) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (!_areEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  return a == b;
}


/// 应用反向补丁到新的 JSON Map，以重建旧的 JSON Map。
Map<String, dynamic>? applyReversePatch(Map<String, dynamic>? newJson, String? patchString) {
  if (newJson == null) return null; // 无法在 null 上应用补丁
  if (patchString == null || patchString.isEmpty) return newJson; // 没有补丁，返回原样

  try {
    final patch = jsonDecode(patchString);
    if (patch is! Map<String, dynamic>) {
      // 如果补丁不是 Map，无法应用（理论上 calculateReverseDiff 不会生成这样的补丁）
       print("Error applying patch: Patch is not a Map.");
       return newJson;
    }
    
    // 创建一个新 Map 来存储结果，避免直接修改 newJson
    final reconstructedJson = Map<String, dynamic>.from(newJson);
    _applyPatchRecursive(reconstructedJson, patch);
    return reconstructedJson;

  } catch (e) {
    print("Error applying JSON patch: $e");
    // 发生错误时，返回原始 newJson
    return newJson;
  }
}

void _applyPatchRecursive(Map<String, dynamic> target, Map<String, dynamic> patch) {
  patch.forEach((key, patchValue) {
    if (patchValue == _keyToBeRemovedMarker) {
      // 如果补丁值是删除标记，则从目标中移除该键
      target.remove(key);
    } else if (patchValue is Map<String, dynamic> && target[key] is Map<String, dynamic>) {
      // 如果补丁值和目标值都是 Map，递归应用补丁
      // 需要确保 target[key] 不是 null
       final targetValueMap = target[key] as Map<String, dynamic>?;
       if(targetValueMap != null){
          _applyPatchRecursive(targetValueMap, patchValue);
       } else {
         // 如果目标值本来是 null 或不是 Map，则直接用补丁值覆盖（虽然理论上这不应发生）
         target[key] = patchValue;
       }
    } else {
      // 否则，直接用补丁值覆盖目标值（添加或修改）
      target[key] = patchValue;
    }
  });
}

