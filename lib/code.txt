### FILE: ./code.txt


### FILE: ./core/data_processor.dart
import 'dart:convert';
import 'package:async/async.dart';
import 'package:drift/drift.dart';
import '../models/account.dart';
import '../services/database.dart';
import '../services/twitter_api_service.dart';
import '../services/twitter_api_v1_service.dart';
import '../utils/diff_utils.dart';
import 'package:async_locks/async_locks.dart';
import '../models/app_settings.dart';
import '../services/image_history_service.dart';
import '../repositories/account_repository.dart';

typedef LogCallback = void Function(String message);

class DataProcessor {
  final AppDatabase _database;
  final TwitterApiService _apiServiceGql;
  final TwitterApiV1Service _apiServiceV1;
  final String _ownerId;
  final String _ownerCookie;
  final AccountRepository _accountRepository;
  final LogCallback _log;
  final AppSettings _settings;
  final ImageHistoryService _imageService;

  DataProcessor({
    required AppDatabase database,
    required TwitterApiService apiServiceGql,
    required TwitterApiV1Service apiServiceV1,
    required AccountRepository accountRepository,
    required Account ownerAccount,
    required AppSettings settings,
    required ImageHistoryService imageService,
    required LogCallback logCallback,
  }) : _database = database,
       _apiServiceGql = apiServiceGql,
       _apiServiceV1 = apiServiceV1,
       _accountRepository = accountRepository,
       _ownerId = ownerAccount.id,
       _ownerCookie = ownerAccount.cookie,
       _log = logCallback,
       _settings = settings,
       _imageService = imageService;

  Future<void> runFullProcess() async {
    _log("Starting analysis process for account ID: $_ownerId...");
    try {
      _log("Refreshing owner account profile ($_ownerId)...");
      // 我们需要一个 Account 对象，构造函数里已经有了
      final ownerAccount = Account(id: _ownerId, cookie: _ownerCookie);
      // _fetchAndSaveAccountProfile 会处理所有逻辑：
      // 1. GQL API 调用
      // 2. JSON Diff 计算
      // 3. 图像下载 (使用正确的 ownerId: _ownerId, userId: _ownerId)
      // 4. 数据库保存 (LoggedAccounts 和 AccountProfileHistory)
      await _accountRepository.refreshAccountProfile(ownerAccount);
      _log("Owner account profile refresh successful.");
    } catch (e) {
      // 如果只是 owner 刷新失败，我们记录错误但继续执行
      _log(
        "!!! WARNING: Failed to refresh owner account profile: $e. "
        "Continuing with follower/following analysis...",
      );
    }

    try {
      _log("Fetching old relationships from database...");
      final List<FollowUser> oldRelationsList = await _database
          .getNetworkRelationships(_ownerId);
      final Map<String, FollowUser> oldRelationsMap = {
        for (var relation in oldRelationsList) relation.userId: relation,
      };
      _log("Found ${oldRelationsMap.length} existing relationships.");

      _log("Fetching new followers from API...");
      final Map<String, Map<String, dynamic>> newUserJsons = {};
      final Set<String> newFollowerIds = {};
      final Set<String> newFollowingIds = {};

      String? nextFollowerCursor;
      do {
        final followerResult = await _apiServiceV1.getFollowers(
          _ownerId,
          _ownerCookie,
          cursor: nextFollowerCursor,
        );
        for (var userJson in followerResult.users) {
          final userId =
              userJson['id_str'] as String? ?? userJson['id']?.toString();
          if (userId != null) {
            newUserJsons[userId] = Map<String, dynamic>.from(userJson);
            newFollowerIds.add(userId);
          }
        }
        nextFollowerCursor = followerResult.nextCursor;
        _log(
          "Fetched ${followerResult.users.length} followers, next cursor: $nextFollowerCursor",
        );
      } while (nextFollowerCursor != null &&
          nextFollowerCursor != '0' &&
          nextFollowerCursor.isNotEmpty);

      _log(
        "Finished fetching followers. Total unique users so far: ${newUserJsons.length}",
      );

      _log("Fetching new following from API...");
      String? nextFollowingCursor;
      do {
        final followingResult = await _apiServiceV1.getFollowing(
          _ownerId,
          _ownerCookie,
          cursor: nextFollowingCursor,
        );
        for (var userJson in followingResult.users) {
          final userId =
              userJson['id_str'] as String? ?? userJson['id']?.toString();
          if (userId != null) {
            newFollowingIds.add(userId);
            if (!newUserJsons.containsKey(userId)) {
              newUserJsons[userId] = Map<String, dynamic>.from(userJson);
            }
          }
        }
        nextFollowingCursor = followingResult.nextCursor;
        _log(
          "Fetched ${followingResult.users.length} following, next cursor: $nextFollowingCursor",
        );
      } while (nextFollowingCursor != null &&
          nextFollowingCursor != '0' &&
          nextFollowingCursor.isNotEmpty);

      _log(
        "Finished fetching following. Total unique users in combined list: ${newUserJsons.length}",
      );

      final Set<String> newIds = newUserJsons.keys.toSet();
      final Set<String> oldIds = oldRelationsMap.keys.toSet();
      final Set<String> addedIds = newIds.difference(oldIds);
      final Set<String> removedIds = oldIds.difference(newIds);
      final Set<String> keptIds = newIds.intersection(oldIds);
      _log(
        "Calculated differences: ${addedIds.length} added, ${removedIds.length} removed, ${keptIds.length} kept.",
      );

      _log(
        "Processing ${removedIds.length} removed users to determine status...",
      );
      final Map<String, String> categorizedRemovals = {};
      if (removedIds.isNotEmpty) {
        final semaphore = Semaphore(5);
        final group = FutureGroup<void>();
        for (final removedId in removedIds) {
          group.add(
            Future(() async {
              await semaphore.acquire();
              String category = 'unknown_error';
              try {
                final Map<String, dynamic> gqlJson = await _apiServiceGql
                    .getUserByRestId(removedId, _ownerCookie);
                final result = gqlJson['data']?['user']?['result'];
                final typename = result?['__typename'];

                if (typename == 'User') {
                  final legacy = result?['legacy'];
                  final interstitial =
                      legacy?['profile_interstitial_type'] as String?;
                  if (interstitial != null && interstitial.isNotEmpty) {
                    category = 'temporarily_restricted';
                  } else {
                    final oldRel = oldRelationsMap[removedId];
                    final wasFollower = oldRel?.isFollower ?? false;
                    final wasFollowing = oldRel?.isFollowing ?? false;
                    if (wasFollower && wasFollowing) {
                      category = 'mutual_unfollowed';
                    } else if (wasFollower) {
                      category = 'normal_unfollowed';
                    } else if (wasFollowing) {
                      category = 'normal_unfollowed';
                    } else {
                      category = 'unknown_removed_state';
                    }
                  }
                } else if (typename == 'UserUnavailable') {
                  category = 'suspended';
                } else if (gqlJson['data']?['user'] == null ||
                    (gqlJson['data']?['user'] is Map &&
                        (gqlJson['data']['user'] as Map).isEmpty)) {
                  category = 'deactivated';
                } else {
                  _log(
                    "Warning: Unexpected GraphQL response for $removedId: $gqlJson",
                  );
                  category = 'unknown_gql_response';
                }
              } catch (e) {
                _log("Error fetching GraphQL for removed user $removedId: $e");
                category = 'unknown_error';
              } finally {
                categorizedRemovals[removedId] = category;
                semaphore.release();
              }
            }),
          );
        }
        group.close();
        await group.future;
        _log("Finished processing removed users.");
      }

      _log("Preparing data for database update...");

      final List<FollowUsersCompanion> companionsToUpsert = [];
      final List<FollowUsersHistoryCompanion> historyToInsert = [];

      final List<Map<String, dynamic>> downloadTasks = [];
      const String suffixRegex = r'_(normal|bigger|400x400)';

      for (final userId in newIds) {
        final userJson = newUserJsons[userId]!;
        final oldRelation = oldRelationsMap[userId];

        if (oldRelation != null) {
          final oldJsonString = oldRelation.latestRawJson;
          final newJsonString = jsonEncode(userJson);
          final diffString = calculateReverseDiff(newJsonString, oldJsonString);
          if (diffString != null && diffString.isNotEmpty) {
            historyToInsert.add(
              FollowUsersHistoryCompanion(
                ownerId: Value(_ownerId),
                userId: Value(userId),
                reverseDiffJson: Value(diffString),
                timestamp: Value(DateTime.now()),
              ),
            );
          }
        }

        final String? newAvatarUrl =
            (userJson['profile_image_url_https'] as String?);
        final String? oldAvatarUrl = oldRelation?.avatarUrl;

        String? effectiveNewUrl = newAvatarUrl;
        String? effectiveOldUrl = oldAvatarUrl;

        if (_settings.avatarQuality == AvatarQuality.low) {
          if (effectiveNewUrl != null) {
            effectiveNewUrl = effectiveNewUrl.replaceFirst(
              RegExp(suffixRegex),
              '_bigger',
            );
          }
          if (effectiveOldUrl != null) {
            effectiveOldUrl = effectiveOldUrl.replaceFirst(
              RegExp(suffixRegex),
              '_bigger',
            );
          }
        } else {
          if (effectiveNewUrl != null) {
            effectiveNewUrl = effectiveNewUrl.replaceFirst(
              RegExp(suffixRegex),
              '_400x400',
            );
          }
          if (effectiveOldUrl != null) {
            effectiveOldUrl = effectiveOldUrl.replaceFirst(
              RegExp(suffixRegex),
              '_400x400',
            );
          }
        }

        final bool shouldSave = _settings.saveAvatarHistory;
        final bool avatarUrlChanged = effectiveNewUrl != effectiveOldUrl;
        final bool localAvatarPathMissing =
            oldRelation == null ||
            oldRelation.avatarLocalPath == null ||
            oldRelation.avatarLocalPath!.isEmpty;

        if (shouldSave &&
            effectiveNewUrl != null &&
            effectiveNewUrl.isNotEmpty &&
            (avatarUrlChanged || localAvatarPathMissing)) {
          downloadTasks.add({
            'userId': userId,
            'newUrl': effectiveNewUrl,
            'oldUrl': oldAvatarUrl,
            'mediaType': MediaType.avatar,
          });
        }

        final String? newBannerUrl =
            (userJson['profile_banner_url'] as String?);
        final String? oldBannerUrl = oldRelation?.bannerUrl;

        final bool shouldSaveBanner = _settings.saveBannerHistory;
        final bool bannerUrlChanged = newBannerUrl != oldBannerUrl;
        final bool localBannerPathMissing =
            oldRelation == null ||
            oldRelation.bannerLocalPath == null ||
            oldRelation.bannerLocalPath == '' ||
            oldRelation.bannerLocalPath!.isEmpty;

        if (shouldSaveBanner &&
            newBannerUrl?.isNotEmpty == true &&
            (bannerUrlChanged || localBannerPathMissing)) {
          downloadTasks.add({
            'userId': userId,
            'newUrl': newBannerUrl,
            'oldUrl': oldBannerUrl,
            'mediaType': MediaType.banner,
          });
        }

        companionsToUpsert.add(
          FollowUsersCompanion(
            ownerId: Value(_ownerId),
            userId: Value(userId),
            name: Value(userJson['name'] as String?),
            screenName: Value(userJson['screen_name'] as String?),
            avatarUrl: Value(newAvatarUrl),
            bannerUrl: Value(newBannerUrl),
            bio: Value(userJson['description'] as String?),
            latestRawJson: Value(jsonEncode(userJson)),
            isFollower: Value(newFollowerIds.contains(userId)),
            isFollowing: Value(newFollowingIds.contains(userId)),
          ),
        );
      }

      final int totalToDownload = downloadTasks.length;
      _log(
        "Found $totalToDownload images to download (out of ${newIds.length} users checked).",
      );

      final group = FutureGroup<Map<String, dynamic>?>();
      final imageSemaphore = Semaphore(50);
      int completedDownloads = 0;
      final counterLock = Semaphore(1);

      for (final task in downloadTasks) {
        final userId = task['userId']! as String;
        final newUrl = task['newUrl']! as String;
        final oldUrl = task['oldUrl'] as String?;
        final mediaType = task['mediaType']! as MediaType;

        group.add(
          Future(() async {
            try {
              await imageSemaphore.acquire();
              final String? newLocalPath = await _imageService
                  .processMediaUpdate(
                    userId: userId,
                    ownerId: _ownerId,
                    mediaType: mediaType,
                    oldUrl: oldUrl,
                    newUrl: newUrl,
                    settings: _settings,
                  );

              if (newLocalPath != null) {
                await counterLock.acquire();
                completedDownloads++;
                _log(
                  "Image download progress: $completedDownloads / $totalToDownload",
                );
                counterLock.release();
                return {
                  'userId': userId,
                  'path': newLocalPath,
                  'type': mediaType,
                };
              }
            } catch (e) {
              _log("Warning: failed to process image for $userId: $e");
            } finally {
              imageSemaphore.release();
            }
            return null;
          }),
        );
      }

      _log("Starting concurrent download of $totalToDownload images");
      group.close();
      final downloadResults = await group.future;

      final Map<String, Map<MediaType, String>> downloadedPaths = {};
      for (final result in downloadResults) {
        if (result != null) {
          final String userId = result['userId'];
          final MediaType type = result['type'];
          final String path = result['path'];

          downloadedPaths.putIfAbsent(userId, () => {});
          downloadedPaths[userId]![type] = path;
        }
      }
      _log(
        "Finished downloading ${downloadResults.where((r) => r != null).length} images.",
      );

      final List<FollowUsersCompanion> finalCompanionsToUpsert = [];
      for (final companion in companionsToUpsert) {
        final userId = companion.userId.value;

        String? finalAvatarPath;
        final downloadedAvatar = downloadedPaths[userId]?[MediaType.avatar];
        if (downloadedAvatar != null) {
          finalAvatarPath = downloadedAvatar;
        } else if (oldRelationsMap.containsKey(userId) &&
            oldRelationsMap[userId]?.avatarUrl == companion.avatarUrl.value) {
          finalAvatarPath = oldRelationsMap[userId]?.avatarLocalPath;
        }

        String? finalBannerPath;
        final downloadedBanner = downloadedPaths[userId]?[MediaType.banner];
        if (downloadedBanner != null) {
          finalBannerPath = downloadedBanner;
        } else if (oldRelationsMap.containsKey(userId) &&
            oldRelationsMap[userId]?.bannerUrl == companion.bannerUrl.value) {
          finalBannerPath = oldRelationsMap[userId]?.bannerLocalPath;
        }

        finalCompanionsToUpsert.add(
          companion.copyWith(
            avatarLocalPath: finalAvatarPath == null
                ? const Value.absent()
                : Value(finalAvatarPath),
            bannerLocalPath: finalBannerPath == null
                ? const Value.absent()
                : Value(finalBannerPath),
          ),
        );
      }

      final List<ChangeReportsCompanion> reportCompanions = [];
      final now = DateTime.now();

      for (final addedId in addedIds) {
        reportCompanions.add(
          ChangeReportsCompanion(
            ownerId: Value(_ownerId),
            userId: Value(addedId),
            changeType: Value('new_followers_following'),
            timestamp: Value(now),
            userSnapshotJson: Value(jsonEncode(newUserJsons[addedId]!)),
          ),
        );
      }

      categorizedRemovals.forEach((userId, categoryKey) {
        reportCompanions.add(
          ChangeReportsCompanion(
            ownerId: Value(_ownerId),
            userId: Value(userId),
            changeType: Value(categoryKey),
            timestamp: Value(now),
            userSnapshotJson: Value(oldRelationsMap[userId]?.latestRawJson),
          ),
        );
      });

      for (final keptId in keptIds) {
        final oldRel = oldRelationsMap[keptId];
        final wasFollower = oldRel?.isFollower ?? false;
        final wasFollowing = oldRel?.isFollowing ?? false;
        final isNowFollower = newFollowerIds.contains(keptId);
        final isNowFollowing = newFollowingIds.contains(keptId);

        if (!wasFollower && wasFollowing && isNowFollower && isNowFollowing) {
          reportCompanions.add(
            ChangeReportsCompanion(
              ownerId: Value(_ownerId),
              userId: Value(keptId),
              changeType: Value('be_followed_back'),
              timestamp: Value(now),
              userSnapshotJson: Value(jsonEncode(newUserJsons[keptId]!)),
            ),
          );
        } else if (wasFollower &&
            wasFollowing &&
            isNowFollower &&
            !isNowFollowing) {
          reportCompanions.add(
            ChangeReportsCompanion(
              ownerId: Value(_ownerId),
              userId: Value(keptId),
              changeType: Value('oneway_unfollowed'),
              timestamp: Value(now),
              userSnapshotJson: Value(jsonEncode(newUserJsons[keptId]!)),
            ),
          );
        } else if (wasFollower &&
            wasFollowing &&
            !isNowFollower &&
            isNowFollowing) {
          reportCompanions.add(
            ChangeReportsCompanion(
              ownerId: Value(_ownerId),
              userId: Value(keptId),
              changeType: Value('oneway_unfollowed'),
              timestamp: Value(now),
              userSnapshotJson: Value(jsonEncode(newUserJsons[keptId]!)),
            ),
          );
        }
      }

      _log("Writing changes to database...");
      await _database.transaction(() async {
        if (removedIds.isNotEmpty) {
          await _database.deleteNetworkRelationships(
            _ownerId,
            removedIds.toList(),
          );
          _log(
            "Deleted ${removedIds.length} relationships from NetworkRelationships.",
          );
        }
        if (finalCompanionsToUpsert.isNotEmpty) {
          await _database.batchUpsertNetworkRelationships(
            finalCompanionsToUpsert,
          );
          _log(
            "Upserted ${finalCompanionsToUpsert.length} relationships into NetworkRelationships.",
          );
        }
        if (historyToInsert.isNotEmpty) {
          await _database.batchInsertFollowUsersHistory(historyToInsert);
          _log("Inserted ${historyToInsert.length} profile history records.");
        }
        await _database.replaceChangeReport(_ownerId, reportCompanions);
        _log(
          "Replaced ChangeReport with ${reportCompanions.length} new entries.",
        );
      });

      _log(
        "Analysis process completed successfully for account ID: $_ownerId.",
      );
    } catch (e, s) {
      _log(
        "!!! CRITICAL ERROR during analysis process for account ID: $_ownerId: $e",
      );
      _log("Stacktrace: $s");
      rethrow;
    }
  }
}


### FILE: ./l10n/app_en.arb
{
"@@locale": "en",
"language": "Language",
"@language": {
"description": "Label for the language setting"
},
"app_title": "Autonitor",
"@app_title": {},
"settings": "Settings",
"@settings": {},
"home": "Home",
"@home": {},
"data": "Data",
"@data": {},
"accounts": "Accounts",
"@accounts": {},
"switchAccount": "Switch Account",
"@switchAccount": {},
"followers": "Followers",
"@followers": {},
"following": "Following",
"@following": {},
"new_account": "Add/Update an account",
"@new_account": {},
"view_cookie": "View Cookie",
"@view_cookie": {},
"close": "Close",
"@close": {},
"view_on_twitter": "View on Twitter",
"@view_on_twitter": {},
"metadata": "Metadata",
"@metadata": {},
"tweets": "Tweets",
"@tweets": {},
"media_count": "Media Count",
"@media_count": {},
"likes": "Likes",
"@likes": {},
"listed_count": "Listed Count",
"@listed_count": {},
"identity": "Identity-related",
"@identity": {},
"back": "Back",
"@back": {},
"history": "History",
"@history": {},
"suspended": "Suspended",
"@suspended": {},
"deactivated": "Deactivated",
"@deactivated": {},
"normal_unfollowed": "Normal Unfollowed",
"@normal_unfollowed": {},
"be_followed_back": "Be Followed Back",
"@be_followed_back": {},
"mutual_unfollowed": "Mutual Unfollowed",
"@mutual_unfollowed": {},
"oneway_unfollowed": "One-way Unfollowed",
"@oneway_unfollowed": {},
"new_followers_following": "New Followers & Following",
"@new_followers_following": {},
"empty_list_message": "The list is empty",
"@empty_list_message": {},
"switch_account": "Switch Account",
"@switch_account": {},
"run": "Run",
"@run": {},
"choose_login_method": "Choose Login Method",
"@choose_login_method": {},
"browser_login": "Login via Browser",
"@browser_login": {},
"manual_cookie": "Manual Cookie Input",
"@manual_cookie": {},
"joined": "Joined",
"@joined": {},
"im_logged_in": "I've logged in",
"@im_logged_in": {},
"cancel": "Cancel",
"@cancel": {},
"ok": "OK",
"@ok": {},
"account_added_successfully": "Account added successfully!",
"@account_added_successfully": {},
"saving_account": "Saving account...",
"@saving_account": {},
"cookie": "Cookie",
"@cookie": {},
"no_cookie_found": "No cookie found",
"@no_cookie_found": {},
"no_auth_token_found": "No auth_token found",
"@no_auth_token_found": {},
"found_auth_token_last_check": "Auth Token found in last check",
"@found_auth_token_last_check": {},
"general": "General",
"@general": {},
"login_first": "Log in Needed",
"@login_first": {},
"login_first_description": "Add at least one account to continue",
"@login_first_description": {},
"log_in": "Log In",
"@log_in": {},
"delete": "Delete",
"@delete": {},
"confirm_delete_account": "Are you sure you want to delete account {accountId}? This action cannot be undone. Deleting an account will permanently remove all its associated data (history, follower/following lists etc.). If you only want to update the cookie, simply add the account again.",
"@confirm_delete_account": {
"placeholders": {
"accountId": {
"description": "The ID of the account to be deleted"
}
}
},
"copy": "Copy",
"@copy": {},
"copied_to_clipboard": "Copied to clipboard!",
"@copied_to_clipboard": {},
"no_json_data_available": "No JSON data available",
"@no_json_data_available": {},
"temporarily_restricted": "Temporarily Restricted",
"@temporarily_restricted": {},
"failed_to_load_user_list": "Failed to load user list",
"@failed_to_load_user_list": {},
"no_users_in_this_category": "Empty list",
"@no_users_in_this_category": {},
"analysis_log": "Analysis Log",
"@analysis_log": {},
"no_active_account_error": "Cannot run analysis: No account is active.",
"@no_active_account_error": {},
"analysis_failed_error": "Analysis failed",
"@analysis_failed_error": {},
"no_analysis_data": "No analysis data found",
"@no_analysis_data": {},
"run_analysis_now": "Run Analysis Now",
"@run_analysis_now": {},
"last_updated_at": "Last updated: {date}",
"@last_updated_at": {
"placeholders": {
"date": {
"type": "String"
}
}
},
"user_history_page_title": "Profile History",
"@user_history_page_title": {},
"storage_settings": "Storage Settings",
"@storage_settings": {},
"save_avatar_history": "Save Avatar",
"@save_avatar_history": {},
"save_banner_history": "Save Banner",
"@save_banner_history": {},
"avatar_quality": "Quality",
"@avatar_quality": {},
"quality_low": "Low",
"@quality_low": {
"description": "e.g. 48x48, _normal suffix"
},
"quality_high": "High",
"@quality_high": {
"description": "e.g. 400x400, _400x400 suffix"
},
"history_strategy": "History Avatar/Banner Storage Strategy",
"@history_strategy": {},
"strategy_save_all": "Never Delete",
"@strategy_save_all": {},
"strategy_save_latest": "Keep Latest Only",
"@strategy_save_latest": {},
"strategy_save_last_n": "Delete avatar/banner older than last",
"@strategy_save_last_n": {},
"strategy_save_last_n_suffix": "changes",
"@strategy_save_last_n_suffix": {},
"theme_mode": "Theme",
"@theme_mode": {},
"theme_mode_system": "Follow System",
"@theme_mode_system": {},
"theme_mode_light": "Light",
"@theme_mode_light": {},
"theme_mode_dark": "Dark",
"@theme_mode_dark": {},
"log": "Log",
"@log": {},
"view_log": "View Logs",
"@view_log": {},
"clear": "Clear",
"@clear": {}
}


### FILE: ./l10n/app_localizations.dart
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_en.dart';
import 'app_localizations_zh.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'l10n/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, you’ll need to edit this
/// file.
///
/// First, open your project’s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// project’s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
abstract class AppLocalizations {
  AppLocalizations(String locale)
    : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates =
      <LocalizationsDelegate<dynamic>>[
        delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
      ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('en'),
    Locale('zh'),
    Locale('zh', 'TW'),
  ];

  /// Label for the language setting
  ///
  /// In en, this message translates to:
  /// **'Language'**
  String get language;

  /// No description provided for @app_title.
  ///
  /// In en, this message translates to:
  /// **'Autonitor'**
  String get app_title;

  /// No description provided for @settings.
  ///
  /// In en, this message translates to:
  /// **'Settings'**
  String get settings;

  /// No description provided for @home.
  ///
  /// In en, this message translates to:
  /// **'Home'**
  String get home;

  /// No description provided for @data.
  ///
  /// In en, this message translates to:
  /// **'Data'**
  String get data;

  /// No description provided for @accounts.
  ///
  /// In en, this message translates to:
  /// **'Accounts'**
  String get accounts;

  /// No description provided for @switchAccount.
  ///
  /// In en, this message translates to:
  /// **'Switch Account'**
  String get switchAccount;

  /// No description provided for @followers.
  ///
  /// In en, this message translates to:
  /// **'Followers'**
  String get followers;

  /// No description provided for @following.
  ///
  /// In en, this message translates to:
  /// **'Following'**
  String get following;

  /// No description provided for @new_account.
  ///
  /// In en, this message translates to:
  /// **'Add/Update an account'**
  String get new_account;

  /// No description provided for @view_cookie.
  ///
  /// In en, this message translates to:
  /// **'View Cookie'**
  String get view_cookie;

  /// No description provided for @close.
  ///
  /// In en, this message translates to:
  /// **'Close'**
  String get close;

  /// No description provided for @view_on_twitter.
  ///
  /// In en, this message translates to:
  /// **'View on Twitter'**
  String get view_on_twitter;

  /// No description provided for @metadata.
  ///
  /// In en, this message translates to:
  /// **'Metadata'**
  String get metadata;

  /// No description provided for @tweets.
  ///
  /// In en, this message translates to:
  /// **'Tweets'**
  String get tweets;

  /// No description provided for @media_count.
  ///
  /// In en, this message translates to:
  /// **'Media Count'**
  String get media_count;

  /// No description provided for @likes.
  ///
  /// In en, this message translates to:
  /// **'Likes'**
  String get likes;

  /// No description provided for @listed_count.
  ///
  /// In en, this message translates to:
  /// **'Listed Count'**
  String get listed_count;

  /// No description provided for @identity.
  ///
  /// In en, this message translates to:
  /// **'Identity-related'**
  String get identity;

  /// No description provided for @back.
  ///
  /// In en, this message translates to:
  /// **'Back'**
  String get back;

  /// No description provided for @history.
  ///
  /// In en, this message translates to:
  /// **'History'**
  String get history;

  /// No description provided for @suspended.
  ///
  /// In en, this message translates to:
  /// **'Suspended'**
  String get suspended;

  /// No description provided for @deactivated.
  ///
  /// In en, this message translates to:
  /// **'Deactivated'**
  String get deactivated;

  /// No description provided for @normal_unfollowed.
  ///
  /// In en, this message translates to:
  /// **'Normal Unfollowed'**
  String get normal_unfollowed;

  /// No description provided for @be_followed_back.
  ///
  /// In en, this message translates to:
  /// **'Be Followed Back'**
  String get be_followed_back;

  /// No description provided for @mutual_unfollowed.
  ///
  /// In en, this message translates to:
  /// **'Mutual Unfollowed'**
  String get mutual_unfollowed;

  /// No description provided for @oneway_unfollowed.
  ///
  /// In en, this message translates to:
  /// **'One-way Unfollowed'**
  String get oneway_unfollowed;

  /// No description provided for @new_followers_following.
  ///
  /// In en, this message translates to:
  /// **'New Followers & Following'**
  String get new_followers_following;

  /// No description provided for @empty_list_message.
  ///
  /// In en, this message translates to:
  /// **'The list is empty'**
  String get empty_list_message;

  /// No description provided for @switch_account.
  ///
  /// In en, this message translates to:
  /// **'Switch Account'**
  String get switch_account;

  /// No description provided for @run.
  ///
  /// In en, this message translates to:
  /// **'Run'**
  String get run;

  /// No description provided for @choose_login_method.
  ///
  /// In en, this message translates to:
  /// **'Choose Login Method'**
  String get choose_login_method;

  /// No description provided for @browser_login.
  ///
  /// In en, this message translates to:
  /// **'Login via Browser'**
  String get browser_login;

  /// No description provided for @manual_cookie.
  ///
  /// In en, this message translates to:
  /// **'Manual Cookie Input'**
  String get manual_cookie;

  /// No description provided for @joined.
  ///
  /// In en, this message translates to:
  /// **'Joined'**
  String get joined;

  /// No description provided for @im_logged_in.
  ///
  /// In en, this message translates to:
  /// **'I\'ve logged in'**
  String get im_logged_in;

  /// No description provided for @cancel.
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get cancel;

  /// No description provided for @ok.
  ///
  /// In en, this message translates to:
  /// **'OK'**
  String get ok;

  /// No description provided for @account_added_successfully.
  ///
  /// In en, this message translates to:
  /// **'Account added successfully!'**
  String get account_added_successfully;

  /// No description provided for @saving_account.
  ///
  /// In en, this message translates to:
  /// **'Saving account...'**
  String get saving_account;

  /// No description provided for @cookie.
  ///
  /// In en, this message translates to:
  /// **'Cookie'**
  String get cookie;

  /// No description provided for @no_cookie_found.
  ///
  /// In en, this message translates to:
  /// **'No cookie found'**
  String get no_cookie_found;

  /// No description provided for @no_auth_token_found.
  ///
  /// In en, this message translates to:
  /// **'No auth_token found'**
  String get no_auth_token_found;

  /// No description provided for @found_auth_token_last_check.
  ///
  /// In en, this message translates to:
  /// **'Auth Token found in last check'**
  String get found_auth_token_last_check;

  /// No description provided for @general.
  ///
  /// In en, this message translates to:
  /// **'General'**
  String get general;

  /// No description provided for @login_first.
  ///
  /// In en, this message translates to:
  /// **'Log in Needed'**
  String get login_first;

  /// No description provided for @login_first_description.
  ///
  /// In en, this message translates to:
  /// **'Add at least one account to continue'**
  String get login_first_description;

  /// No description provided for @log_in.
  ///
  /// In en, this message translates to:
  /// **'Log In'**
  String get log_in;

  /// No description provided for @delete.
  ///
  /// In en, this message translates to:
  /// **'Delete'**
  String get delete;

  /// No description provided for @confirm_delete_account.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to delete account {accountId}? This action cannot be undone. Deleting an account will permanently remove all its associated data (history, follower/following lists etc.). If you only want to update the cookie, simply add the account again.'**
  String confirm_delete_account(Object accountId);

  /// No description provided for @copy.
  ///
  /// In en, this message translates to:
  /// **'Copy'**
  String get copy;

  /// No description provided for @copied_to_clipboard.
  ///
  /// In en, this message translates to:
  /// **'Copied to clipboard!'**
  String get copied_to_clipboard;

  /// No description provided for @no_json_data_available.
  ///
  /// In en, this message translates to:
  /// **'No JSON data available'**
  String get no_json_data_available;

  /// No description provided for @temporarily_restricted.
  ///
  /// In en, this message translates to:
  /// **'Temporarily Restricted'**
  String get temporarily_restricted;

  /// No description provided for @failed_to_load_user_list.
  ///
  /// In en, this message translates to:
  /// **'Failed to load user list'**
  String get failed_to_load_user_list;

  /// No description provided for @no_users_in_this_category.
  ///
  /// In en, this message translates to:
  /// **'Empty list'**
  String get no_users_in_this_category;

  /// No description provided for @analysis_log.
  ///
  /// In en, this message translates to:
  /// **'Analysis Log'**
  String get analysis_log;

  /// No description provided for @no_active_account_error.
  ///
  /// In en, this message translates to:
  /// **'Cannot run analysis: No account is active.'**
  String get no_active_account_error;

  /// No description provided for @analysis_failed_error.
  ///
  /// In en, this message translates to:
  /// **'Analysis failed'**
  String get analysis_failed_error;

  /// No description provided for @no_analysis_data.
  ///
  /// In en, this message translates to:
  /// **'No analysis data found'**
  String get no_analysis_data;

  /// No description provided for @run_analysis_now.
  ///
  /// In en, this message translates to:
  /// **'Run Analysis Now'**
  String get run_analysis_now;

  /// No description provided for @last_updated_at.
  ///
  /// In en, this message translates to:
  /// **'Last updated: {date}'**
  String last_updated_at(String date);

  /// No description provided for @user_history_page_title.
  ///
  /// In en, this message translates to:
  /// **'Profile History'**
  String get user_history_page_title;

  /// No description provided for @storage_settings.
  ///
  /// In en, this message translates to:
  /// **'Storage Settings'**
  String get storage_settings;

  /// No description provided for @save_avatar_history.
  ///
  /// In en, this message translates to:
  /// **'Save Avatar'**
  String get save_avatar_history;

  /// No description provided for @save_banner_history.
  ///
  /// In en, this message translates to:
  /// **'Save Banner'**
  String get save_banner_history;

  /// No description provided for @avatar_quality.
  ///
  /// In en, this message translates to:
  /// **'Quality'**
  String get avatar_quality;

  /// e.g. 48x48, _normal suffix
  ///
  /// In en, this message translates to:
  /// **'Low'**
  String get quality_low;

  /// e.g. 400x400, _400x400 suffix
  ///
  /// In en, this message translates to:
  /// **'High'**
  String get quality_high;

  /// No description provided for @history_strategy.
  ///
  /// In en, this message translates to:
  /// **'History Avatar/Banner Storage Strategy'**
  String get history_strategy;

  /// No description provided for @strategy_save_all.
  ///
  /// In en, this message translates to:
  /// **'Never Delete'**
  String get strategy_save_all;

  /// No description provided for @strategy_save_latest.
  ///
  /// In en, this message translates to:
  /// **'Keep Latest Only'**
  String get strategy_save_latest;

  /// No description provided for @strategy_save_last_n.
  ///
  /// In en, this message translates to:
  /// **'Delete avatar/banner older than last'**
  String get strategy_save_last_n;

  /// No description provided for @strategy_save_last_n_suffix.
  ///
  /// In en, this message translates to:
  /// **'changes'**
  String get strategy_save_last_n_suffix;

  /// No description provided for @theme_mode.
  ///
  /// In en, this message translates to:
  /// **'Theme'**
  String get theme_mode;

  /// No description provided for @theme_mode_system.
  ///
  /// In en, this message translates to:
  /// **'Follow System'**
  String get theme_mode_system;

  /// No description provided for @theme_mode_light.
  ///
  /// In en, this message translates to:
  /// **'Light'**
  String get theme_mode_light;

  /// No description provided for @theme_mode_dark.
  ///
  /// In en, this message translates to:
  /// **'Dark'**
  String get theme_mode_dark;

  /// No description provided for @log.
  ///
  /// In en, this message translates to:
  /// **'Log'**
  String get log;

  /// No description provided for @view_log.
  ///
  /// In en, this message translates to:
  /// **'View Logs'**
  String get view_log;

  /// No description provided for @clear.
  ///
  /// In en, this message translates to:
  /// **'Clear'**
  String get clear;
}

class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) =>
      <String>['en', 'zh'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {
  // Lookup logic when language+country codes are specified.
  switch (locale.languageCode) {
    case 'zh':
      {
        switch (locale.countryCode) {
          case 'TW':
            return AppLocalizationsZhTw();
        }
        break;
      }
  }

  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'en':
      return AppLocalizationsEn();
    case 'zh':
      return AppLocalizationsZh();
  }

  throw FlutterError(
    'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
    'an issue with the localizations generation tool. Please file an issue '
    'on GitHub with a reproducible sample app and the gen-l10n configuration '
    'that was used.',
  );
}


### FILE: ./l10n/app_localizations_en.dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get language => 'Language';

  @override
  String get app_title => 'Autonitor';

  @override
  String get settings => 'Settings';

  @override
  String get home => 'Home';

  @override
  String get data => 'Data';

  @override
  String get accounts => 'Accounts';

  @override
  String get switchAccount => 'Switch Account';

  @override
  String get followers => 'Followers';

  @override
  String get following => 'Following';

  @override
  String get new_account => 'Add/Update an account';

  @override
  String get view_cookie => 'View Cookie';

  @override
  String get close => 'Close';

  @override
  String get view_on_twitter => 'View on Twitter';

  @override
  String get metadata => 'Metadata';

  @override
  String get tweets => 'Tweets';

  @override
  String get media_count => 'Media Count';

  @override
  String get likes => 'Likes';

  @override
  String get listed_count => 'Listed Count';

  @override
  String get identity => 'Identity-related';

  @override
  String get back => 'Back';

  @override
  String get history => 'History';

  @override
  String get suspended => 'Suspended';

  @override
  String get deactivated => 'Deactivated';

  @override
  String get normal_unfollowed => 'Normal Unfollowed';

  @override
  String get be_followed_back => 'Be Followed Back';

  @override
  String get mutual_unfollowed => 'Mutual Unfollowed';

  @override
  String get oneway_unfollowed => 'One-way Unfollowed';

  @override
  String get new_followers_following => 'New Followers & Following';

  @override
  String get empty_list_message => 'The list is empty';

  @override
  String get switch_account => 'Switch Account';

  @override
  String get run => 'Run';

  @override
  String get choose_login_method => 'Choose Login Method';

  @override
  String get browser_login => 'Login via Browser';

  @override
  String get manual_cookie => 'Manual Cookie Input';

  @override
  String get joined => 'Joined';

  @override
  String get im_logged_in => 'I\'ve logged in';

  @override
  String get cancel => 'Cancel';

  @override
  String get ok => 'OK';

  @override
  String get account_added_successfully => 'Account added successfully!';

  @override
  String get saving_account => 'Saving account...';

  @override
  String get cookie => 'Cookie';

  @override
  String get no_cookie_found => 'No cookie found';

  @override
  String get no_auth_token_found => 'No auth_token found';

  @override
  String get found_auth_token_last_check => 'Auth Token found in last check';

  @override
  String get general => 'General';

  @override
  String get login_first => 'Log in Needed';

  @override
  String get login_first_description => 'Add at least one account to continue';

  @override
  String get log_in => 'Log In';

  @override
  String get delete => 'Delete';

  @override
  String confirm_delete_account(Object accountId) {
    return 'Are you sure you want to delete account $accountId? This action cannot be undone. Deleting an account will permanently remove all its associated data (history, follower/following lists etc.). If you only want to update the cookie, simply add the account again.';
  }

  @override
  String get copy => 'Copy';

  @override
  String get copied_to_clipboard => 'Copied to clipboard!';

  @override
  String get no_json_data_available => 'No JSON data available';

  @override
  String get temporarily_restricted => 'Temporarily Restricted';

  @override
  String get failed_to_load_user_list => 'Failed to load user list';

  @override
  String get no_users_in_this_category => 'Empty list';

  @override
  String get analysis_log => 'Analysis Log';

  @override
  String get no_active_account_error =>
      'Cannot run analysis: No account is active.';

  @override
  String get analysis_failed_error => 'Analysis failed';

  @override
  String get no_analysis_data => 'No analysis data found';

  @override
  String get run_analysis_now => 'Run Analysis Now';

  @override
  String last_updated_at(String date) {
    return 'Last updated: $date';
  }

  @override
  String get user_history_page_title => 'Profile History';

  @override
  String get storage_settings => 'Storage Settings';

  @override
  String get save_avatar_history => 'Save Avatar';

  @override
  String get save_banner_history => 'Save Banner';

  @override
  String get avatar_quality => 'Quality';

  @override
  String get quality_low => 'Low';

  @override
  String get quality_high => 'High';

  @override
  String get history_strategy => 'History Avatar/Banner Storage Strategy';

  @override
  String get strategy_save_all => 'Never Delete';

  @override
  String get strategy_save_latest => 'Keep Latest Only';

  @override
  String get strategy_save_last_n => 'Delete avatar/banner older than last';

  @override
  String get strategy_save_last_n_suffix => 'changes';

  @override
  String get theme_mode => 'Theme';

  @override
  String get theme_mode_system => 'Follow System';

  @override
  String get theme_mode_light => 'Light';

  @override
  String get theme_mode_dark => 'Dark';

  @override
  String get log => 'Log';

  @override
  String get view_log => 'View Logs';

  @override
  String get clear => 'Clear';
}


### FILE: ./l10n/app_localizations_zh.dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Chinese (`zh`).
class AppLocalizationsZh extends AppLocalizations {
  AppLocalizationsZh([String locale = 'zh']) : super(locale);

  @override
  String get language => '语言';

  @override
  String get app_title => 'Autonitor';

  @override
  String get settings => '设置';

  @override
  String get home => '首页';

  @override
  String get data => '数据';

  @override
  String get accounts => '账号';

  @override
  String get switchAccount => '切换账号';

  @override
  String get followers => '关注者';

  @override
  String get following => '正在关注';

  @override
  String get new_account => '添加/更新账号';

  @override
  String get view_cookie => '查看 Cookie';

  @override
  String get close => '关闭';

  @override
  String get view_on_twitter => '在 Twitter 上查看';

  @override
  String get metadata => '元数据';

  @override
  String get tweets => '推文';

  @override
  String get media_count => '媒体数量';

  @override
  String get likes => '点赞数量';

  @override
  String get listed_count => '被收录列表';

  @override
  String get identity => '身份相关';

  @override
  String get back => '返回';

  @override
  String get history => '历史';

  @override
  String get suspended => '被冻结';

  @override
  String get deactivated => '注销';

  @override
  String get normal_unfollowed => '普通取关';

  @override
  String get be_followed_back => '被回关';

  @override
  String get mutual_unfollowed => '互关双取';

  @override
  String get oneway_unfollowed => '互关单取';

  @override
  String get new_followers_following => '新增关注';

  @override
  String get empty_list_message => '列表为空';

  @override
  String get switch_account => '切换账号';

  @override
  String get run => '运行';

  @override
  String get choose_login_method => '选择登录方式';

  @override
  String get browser_login => '浏览器登录';

  @override
  String get manual_cookie => '输入Cookie';

  @override
  String get joined => '加入于';

  @override
  String get im_logged_in => '我已登录';

  @override
  String get cancel => '取消';

  @override
  String get ok => '确定';

  @override
  String get account_added_successfully => '账号添加成功！';

  @override
  String get saving_account => '正在保存账号...';

  @override
  String get cookie => 'Cookie';

  @override
  String get no_cookie_found => '未能找到 cookie';

  @override
  String get no_auth_token_found => '未能找到 auth_token';

  @override
  String get found_auth_token_last_check => '在上次检查中找到了 Auth Token';

  @override
  String get general => '通用';

  @override
  String get login_first => '需要登录';

  @override
  String get login_first_description => '请至少添加一个账号以继续';

  @override
  String get log_in => '登录';

  @override
  String get delete => '删除';

  @override
  String confirm_delete_account(Object accountId) {
    return '您确定要删除账号 $accountId 吗？此操作无法撤销。删除账号将永久移除其所有关联数据（历史记录、关注者/关注列表等）。如果您只想更新 Cookie，请直接重新添加该账号。';
  }

  @override
  String get copy => '复制';

  @override
  String get copied_to_clipboard => '已复制到剪贴板！';

  @override
  String get no_json_data_available => '无 JSON 数据';

  @override
  String get temporarily_restricted => '暂时受限';

  @override
  String get failed_to_load_user_list => '加载用户列表失败';

  @override
  String get no_users_in_this_category => '列表为空';

  @override
  String get analysis_log => '分析日志';

  @override
  String get no_active_account_error => '无法运行分析：没有活动的账号。';

  @override
  String get analysis_failed_error => '分析失败';

  @override
  String get no_analysis_data => '尚未生成分析数据';

  @override
  String get run_analysis_now => '立即运行分析';

  @override
  String last_updated_at(String date) {
    return '上次更新：$date';
  }

  @override
  String get user_history_page_title => '个人资料历史';

  @override
  String get storage_settings => '存储设置';

  @override
  String get save_avatar_history => '保存头像';

  @override
  String get save_banner_history => '保存横幅';

  @override
  String get avatar_quality => '质量';

  @override
  String get quality_low => '低';

  @override
  String get quality_high => '高';

  @override
  String get history_strategy => '历史头像/横幅存储策略';

  @override
  String get strategy_save_all => '从不删除';

  @override
  String get strategy_save_latest => '仅保留最新';

  @override
  String get strategy_save_last_n => '删除早于最近';

  @override
  String get strategy_save_last_n_suffix => '次更改的头像/横幅';

  @override
  String get theme_mode => '主题';

  @override
  String get theme_mode_system => '跟随系统';

  @override
  String get theme_mode_light => '浅色';

  @override
  String get theme_mode_dark => '深色';

  @override
  String get log => '日志';

  @override
  String get view_log => '查看日志';

  @override
  String get clear => '清除';
}

/// The translations for Chinese, as used in Taiwan (`zh_TW`).
class AppLocalizationsZhTw extends AppLocalizationsZh {
  AppLocalizationsZhTw() : super('zh_TW');

  @override
  String get language => '語言';

  @override
  String get app_title => 'Autonitor';

  @override
  String get settings => '設定';

  @override
  String get home => '首頁';

  @override
  String get data => '數據';

  @override
  String get accounts => '賬戶';

  @override
  String get switchAccount => '切換賬戶';

  @override
  String get followers => '跟隨者';

  @override
  String get following => '跟隨中';

  @override
  String get new_account => '添加/更新賬戶';

  @override
  String get view_cookie => '查看 Cookie';

  @override
  String get close => '關閉';

  @override
  String get view_on_twitter => '在 Twitter 上查看';

  @override
  String get metadata => '元數據';

  @override
  String get tweets => '推文';

  @override
  String get media_count => '媒體數量';

  @override
  String get likes => '讚數';

  @override
  String get listed_count => '被收錄列表';

  @override
  String get identity => '身份相關';

  @override
  String get back => '返回';

  @override
  String get history => '歷史';

  @override
  String get suspended => '遭停權';

  @override
  String get deactivated => '註銷';

  @override
  String get normal_unfollowed => '普通取跟';

  @override
  String get be_followed_back => '被回跟';

  @override
  String get mutual_unfollowed => '互跟雙取';

  @override
  String get oneway_unfollowed => '互跟單取';

  @override
  String get new_followers_following => '新增跟隨';

  @override
  String get empty_list_message => '空列表';

  @override
  String get switch_account => '切換賬戶';

  @override
  String get run => '運行';

  @override
  String get choose_login_method => '選擇登入方式';

  @override
  String get browser_login => '透過瀏覽器登入';

  @override
  String get manual_cookie => '鍵入Cookie';

  @override
  String get joined => '加入於';

  @override
  String get im_logged_in => '我已登入';

  @override
  String get cancel => '取消';

  @override
  String get ok => '確定';

  @override
  String get account_added_successfully => '賬戶添加成功！';

  @override
  String get saving_account => '正在保存賬戶...';

  @override
  String get cookie => 'Cookie';

  @override
  String get no_cookie_found => '未能找到 cookie';

  @override
  String get no_auth_token_found => '未能找到 auth_token';

  @override
  String get found_auth_token_last_check => '在上次檢查中找到了 Auth Token';

  @override
  String get general => '通用';

  @override
  String get login_first => '需要登入';

  @override
  String get login_first_description => '請至少添加一個帳戶以繼續';

  @override
  String get log_in => '登入';

  @override
  String get delete => '刪除';

  @override
  String confirm_delete_account(Object accountId) {
    return '您確定要刪除賬戶 $accountId 嗎？此操作無法撤銷。刪除賬戶將永久移除其所有關聯數據（歷史紀錄、跟隨者/跟隨列表等）。如果您只想更新 Cookie，請直接重新添加該賬戶。';
  }

  @override
  String get copy => '拷貝';

  @override
  String get copied_to_clipboard => '已拷貝到剪貼簿！';

  @override
  String get no_json_data_available => '無 JSON 數據';

  @override
  String get temporarily_restricted => '暫時受限';

  @override
  String get failed_to_load_user_list => '載入用戶列表失敗';

  @override
  String get no_users_in_this_category => '空列表';

  @override
  String get analysis_log => '分析日誌';

  @override
  String get no_active_account_error => '無法運行分析：沒有活動的賬戶。';

  @override
  String get analysis_failed_error => '分析失敗';

  @override
  String get no_analysis_data => '尚未生成分析數據';

  @override
  String get run_analysis_now => '立即運行分析';

  @override
  String last_updated_at(String date) {
    return '上次更新：$date';
  }

  @override
  String get user_history_page_title => '個人資料歷史';

  @override
  String get storage_settings => '儲存設定';

  @override
  String get save_avatar_history => '儲存頭像';

  @override
  String get save_banner_history => '儲存橫幅';

  @override
  String get avatar_quality => '品質';

  @override
  String get quality_low => '低';

  @override
  String get quality_high => '高';

  @override
  String get history_strategy => '歷史頭像/橫幅儲存策略';

  @override
  String get strategy_save_all => '從不刪除';

  @override
  String get strategy_save_latest => '僅保留最新';

  @override
  String get strategy_save_last_n => '刪除早於最近';

  @override
  String get strategy_save_last_n_suffix => '次更改的頭像/橫幅';

  @override
  String get theme_mode => '主題';

  @override
  String get theme_mode_system => '跟隨系統';

  @override
  String get theme_mode_light => '淺色';

  @override
  String get theme_mode_dark => '深色';

  @override
  String get log => '日誌';

  @override
  String get view_log => '查看日誌';

  @override
  String get clear => '清除';
}


### FILE: ./l10n/app_zh.arb
{
  "@@locale": "zh",
  "language": "语言",
  "app_title": "Autonitor",
  "settings": "设置",
  "home": "首页",
  "data": "数据",
  "accounts": "账号",
  "switchAccount": "切换账号",
  "followers": "关注者",
  "following": "正在关注",
  "new_account": "添加/更新账号",
  "view_cookie": "查看 Cookie",
  "close": "关闭",
  "view_on_twitter": "在 Twitter 上查看",
  "metadata": "元数据",
  "tweets": "推文",
  "media_count": "媒体数量",
  "likes": "点赞数量",
  "listed_count": "被收录列表",
  "identity": "身份相关",
  "back": "返回",
  "history": "历史",
  "suspended": "被冻结",
  "deactivated": "注销",
  "normal_unfollowed": "普通取关",
  "be_followed_back": "被回关",
  "mutual_unfollowed": "互关双取",
  "oneway_unfollowed": "互关单取",
  "new_followers_following": "新增关注",
  "empty_list_message": "列表为空",
  "switch_account": "切换账号",
  "run": "运行",
  "choose_login_method": "选择登录方式",
  "browser_login": "浏览器登录",
  "manual_cookie": "输入Cookie",
  "joined": "加入于",
  "im_logged_in": "我已登录",
  "cancel": "取消",
  "ok": "确定",
  "account_added_successfully": "账号添加成功！",
  "saving_account": "正在保存账号...",
  "cookie": "Cookie",
  "no_cookie_found": "未能找到 cookie",
  "no_auth_token_found": "未能找到 auth_token",
  "found_auth_token_last_check": "在上次检查中找到了 Auth Token",
  "general": "通用",
  "login_first": "需要登录",
  "login_first_description": "请至少添加一个账号以继续",
  "log_in": "登录",
  "delete": "删除",
  "confirm_delete_account": "您确定要删除账号 {accountId} 吗？此操作无法撤销。删除账号将永久移除其所有关联数据（历史记录、关注者/关注列表等）。如果您只想更新 Cookie，请直接重新添加该账号。",
  "@confirm_delete_account": {
    "placeholders": {
      "accountId": {
        "description": "The ID of the account to be deleted"
      }
    }
  },
  "copy": "复制",
  "copied_to_clipboard": "已复制到剪贴板！",
  "no_json_data_available": "无 JSON 数据",
  "temporarily_restricted": "暂时受限",
  "failed_to_load_user_list": "加载用户列表失败",
  "no_users_in_this_category": "列表为空",
  "analysis_log": "分析日志",
  "no_active_account_error": "无法运行分析：没有活动的账号。",
  "analysis_failed_error": "分析失败",
  "no_analysis_data": "尚未生成分析数据",
  "run_analysis_now": "立即运行分析",
  "last_updated_at": "上次更新：{date}",
  "@last_updated_at": {
    "placeholders": {
      "date": {
        "type": "String"
      }
    }
  },
  "user_history_page_title": "个人资料历史",
  "storage_settings": "存储设置",
  "save_avatar_history": "保存头像",
  "save_banner_history": "保存横幅",
  "avatar_quality": "质量",
  "quality_low": "低",
  "quality_high": "高",
  "history_strategy": "历史头像/横幅存储策略",
  "strategy_save_all": "从不删除",
  "strategy_save_latest": "仅保留最新",
  "strategy_save_last_n": "删除早于最近",
  "strategy_save_last_n_suffix": "次更改的头像/横幅",
  "theme_mode": "主题",
  "theme_mode_system": "跟随系统",
  "theme_mode_light": "浅色",
  "theme_mode_dark": "深色",
  "log": "日志",
  "view_log": "查看日志",
  "clear": "清除"
}

### FILE: ./l10n/app_zh_TW.arb
{
  "@@locale": "zh_TW",
  "language": "語言",
  "app_title": "Autonitor",
  "settings": "設定",
  "home": "首頁",
  "data": "數據",
  "accounts": "賬戶",
  "switchAccount": "切換賬戶",
  "followers": "跟隨者",
  "following": "跟隨中",
  "new_account": "添加/更新賬戶",
  "view_cookie": "查看 Cookie",
  "close": "關閉",
  "view_on_twitter": "在 Twitter 上查看",
  "metadata": "元數據",
  "tweets": "推文",
  "media_count": "媒體數量",
  "likes": "讚數",
  "listed_count": "被收錄列表",
  "identity": "身份相關",
  "back": "返回",
  "history": "歷史",
  "suspended": "遭停權",
  "deactivated": "註銷",
  "normal_unfollowed": "普通取跟",
  "be_followed_back": "被回跟",
  "mutual_unfollowed": "互跟雙取",
  "oneway_unfollowed": "互跟單取",
  "new_followers_following": "新增跟隨",
  "empty_list_message": "空列表",
  "switch_account": "切換賬戶",
  "run": "運行",
  "choose_login_method": "選擇登入方式",
  "browser_login": "透過瀏覽器登入",
  "manual_cookie": "鍵入Cookie",
  "joined": "加入於",
  "im_logged_in": "我已登入",
  "cancel": "取消",
  "ok": "確定",
  "account_added_successfully": "賬戶添加成功！",
  "saving_account": "正在保存賬戶...",
  "cookie": "Cookie",
  "no_cookie_found": "未能找到 cookie",
  "no_auth_token_found": "未能找到 auth_token",
  "found_auth_token_last_check": "在上次檢查中找到了 Auth Token",
  "general": "通用",
  "login_first": "需要登入",
  "login_first_description": "請至少添加一個帳戶以繼續",
  "log_in": "登入",
  "delete": "刪除",
  "confirm_delete_account": "您確定要刪除賬戶 {accountId} 嗎？此操作無法撤銷。刪除賬戶將永久移除其所有關聯數據（歷史紀錄、跟隨者/跟隨列表等）。如果您只想更新 Cookie，請直接重新添加該賬戶。",
  "@confirm_delete_account": {
    "placeholders": {
      "accountId": {
        "description": "The ID of the account to be deleted"
      }
    }
  },
  "copy": "拷貝",
  "copied_to_clipboard": "已拷貝到剪貼簿！",
  "no_json_data_available": "無 JSON 數據",
  "temporarily_restricted": "暫時受限",
  "failed_to_load_user_list": "載入用戶列表失敗",
  "no_users_in_this_category": "空列表",
  "analysis_log": "分析日誌",
  "no_active_account_error": "無法運行分析：沒有活動的賬戶。",
  "analysis_failed_error": "分析失敗",
  "no_analysis_data": "尚未生成分析數據",
  "run_analysis_now": "立即運行分析",
  "last_updated_at": "上次更新：{date}",
  "@last_updated_at": {
    "placeholders": {
      "date": {
        "type": "String"
      }
    }
  },
  "user_history_page_title": "個人資料歷史",
  "storage_settings": "儲存設定",
  "save_avatar_history": "儲存頭像",
  "save_banner_history": "儲存橫幅",
  "avatar_quality": "品質",
  "quality_low": "低",
  "quality_high": "高",
  "history_strategy": "歷史頭像/橫幅儲存策略",
  "strategy_save_all": "從不刪除",
  "strategy_save_latest": "僅保留最新",
  "strategy_save_last_n": "刪除早於最近",
  "strategy_save_last_n_suffix": "次更改的頭像/橫幅",
  "theme_mode": "主題",
  "theme_mode_system": "跟隨系統",
  "theme_mode_light": "淺色",
  "theme_mode_dark": "深色",
  "log": "日誌",
  "view_log": "查看日誌",
  "clear": "清除"
}

### FILE: ./main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:autonitor/ui/main_scaffold.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'l10n/app_localizations.dart';
import 'providers/settings_provider.dart';
import 'services/database.dart';

final databaseProvider = Provider<AppDatabase>((ref) {
  return AppDatabase();
});

void main() {
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  // 4. 添加 WidgetRef ref
  Widget build(BuildContext context, WidgetRef ref) {
    // 5. 监听设置
    final settingsValue = ref.watch(settingsProvider);

    return MaterialApp(
      onGenerateTitle: (context) {
        return AppLocalizations.of(context)?.app_title ?? 'Autonitor';
      },
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      darkTheme: ThemeData(
        brightness: Brightness.dark,
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      themeMode: settingsValue.when(
        loading: () => ThemeMode.system,
        error: (e, s) => ThemeMode.system,
        data: (settings) => settings.themeMode,
      ),
      home: const MainScaffold(),

      // --- 本地化配置 ---
      localizationsDelegates: const [
        AppLocalizations.delegate, // 你生成的 AppLocalizations 代理
        GlobalMaterialLocalizations.delegate, // Material 组件的默认本地化
        GlobalWidgetsLocalizations.delegate, // Widget 的默认本地化 (如文本方向)
        GlobalCupertinoLocalizations.delegate, // Cupertino 组件的本地化 (如果用到)
      ],
      // 6. 更新 supportedLocales
      supportedLocales: const [
        Locale('en'), // 英语
        Locale('zh', 'CN'), // 简体中文
        Locale('zh', 'TW'), // 繁體中文
        Locale('zh'), // 基础中文 (作为 fallback)
      ],

      // 7. 设置 locale 属性
      locale: settingsValue.when(
        loading: () => null, // 加载中，使用系统默认
        error: (e, s) => null, // 出错，使用系统默认
        data: (settings) =>
            settings.locale, // 使用 Provider 中的 Locale (null 表示 Auto/系统默认)
      ),
    );
  }
}


### FILE: ./models/account.dart
class Account {
  final String? latestRawJson;

  /// The unique Twitter User ID (Rest ID / twid).
  final String id;

  /// The full cookie string required for authentication.
  final String cookie;

  /// The user's display name (e.g., "Elon Musk"). Fetched from API.
  final String? name;

  /// The user's screen name / handle (e.g., "elonmusk"). Fetched from API.
  final String? screenName;

  /// The URL for the user's profile image. Fetched from API.
  final String? avatarUrl;

  final String? avatarLocalPath;

  /// The URL for the user's profile banner.
  final String? bannerUrl;

   final String? bannerLocalPath;

  /// The user's biography.
  final String? bio;

  /// The user's profile location.
  final String? location;

  /// The user's profile link (t.co).
  final String? link;

  /// The ISO 8601 string of when the account was created.
  final String? joinTime;

  /// The number of followers.
  final int followersCount;

  /// The number of accounts the user is following.
  final int followingCount;
  final int statusesCount;
  final int mediaCount;
  final int favouritesCount;
  final int listedCount;

  final bool isVerified;
  final bool isProtected;

  Account({
    required this.id,
    required this.cookie,
    this.name,
    this.screenName,
    this.avatarUrl,
    this.avatarLocalPath,
    this.bannerUrl,
    this.bannerLocalPath,
    this.bio,
    this.location,
    this.link,
    this.joinTime,
    this.followersCount = 0,
    this.followingCount = 0,
    this.statusesCount = 0,
    this.mediaCount = 0,
    this.favouritesCount = 0,
    this.listedCount = 0,
    this.latestRawJson,
    this.isVerified = false,
    this.isProtected = false,
  });

  /// Creates an Account instance from a JSON map.
  factory Account.fromJson(Map<String, dynamic> json) {
    return Account(
      id: json['id'] as String? ?? '', // Provide default empty string
      cookie: json['cookie'] as String? ?? '', // Provide default empty string
      name: json['name'] as String?,
      screenName: json['screenName'] as String?,
      avatarUrl: json['avatarUrl'] as String?,
      avatarLocalPath: json['avatarLocalPath'] as String?,
      bannerUrl: json['bannerUrl'] as String?,
      bannerLocalPath: json['bannerLocalPath'] as String?,
      bio: json['bio'] as String?,
      location: json['location'] as String?,
      link: json['link'] as String?,
      joinTime: json['joinTime'] as String?,
      followersCount: json['followersCount'] as int? ?? 0,
      followingCount: json['followingCount'] as int? ?? 0,
      statusesCount: json['statusesCount'] ?? 0,
      mediaCount: json['mediaCount'] ?? 0,
      favouritesCount: json['favouritesCount'] ?? 0,
      listedCount: json['listedCount'] ?? 0,
      latestRawJson: json['latestRawJson'] as String?,
      isVerified: json['verified'] as bool? ?? false,
      isProtected: json['protected'] as bool? ?? false,
    );
  }

  /// Converts the Account instance to a JSON map.
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'cookie': cookie,
      'name': name,
      'screenName': screenName,
      'avatarUrl': avatarUrl,
      'avatarLocalPath': avatarLocalPath,
      'bannerUrl': bannerUrl,
      'bannerLocalPath': bannerLocalPath,
      'bio': bio,
      'location': location,
      'link': link,
      'joinTime': joinTime,
      'followersCount': followersCount,
      'followingCount': followingCount,
      'statusesCount': statusesCount,
      'mediaCount': mediaCount,
      'favouritesCount': favouritesCount,
      'listedCount': listedCount,
      'latestRawJson': latestRawJson,
      'verified': isVerified,
      'protected': isProtected,
    };
  }

  // Optional: Add copyWith for easier updates
  Account copyWith({
    String? id,
    String? cookie,
    String? name,
    String? screenName,
    String? avatarUrl,
    String? avatarLocalPath,
    String? bannerUrl,
    String? bannerLocalPath,
    String? bio,
    String? location,
    String? link,
    String? joinTime,
    int? followersCount,
    int? followingCount,
    int? statusesCount,
    int? mediaCount,
    int? favouritesCount,
    int? listedCount,
    String? latestRawJson,
    bool? isProtected,
    bool? isVerified,
  }) {
    return Account(
      id: id ?? this.id,
      cookie: cookie ?? this.cookie,
      name: name ?? this.name,
      screenName: screenName ?? this.screenName,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      avatarLocalPath: avatarLocalPath ?? this.avatarLocalPath,
      bannerUrl: bannerUrl ?? this.bannerUrl,
      bannerLocalPath: bannerLocalPath ?? this.bannerLocalPath,
      bio: bio ?? this.bio,
      location: location ?? this.location,
      link: link ?? this.link,
      joinTime: joinTime ?? this.joinTime,
      followersCount: followersCount ?? this.followersCount,
      followingCount: followingCount ?? this.followingCount,
      statusesCount: statusesCount ?? this.statusesCount,
      mediaCount: mediaCount ?? this.mediaCount,
      favouritesCount: favouritesCount ?? this.favouritesCount,
      listedCount: listedCount ?? this.listedCount,
      latestRawJson: latestRawJson ?? this.latestRawJson,
      isVerified: isVerified ?? this.isVerified,
      isProtected: isProtected ?? this.isProtected,
    );
  }

  // Optional: Override toString for better debugging
  @override
  String toString() {
    return 'Account(id: $id, name: $name, screenName: $screenName, avatarUrl: $avatarUrl, cookie: ${cookie.length > 10 ? '${cookie.substring(0, 10)}...' : cookie})';
  }
}


### FILE: ./models/app_settings.dart
import 'package:flutter/material.dart';

enum AvatarQuality { low, high }

enum HistoryStrategy { saveAll, saveLatest, saveLastN }

extension _EnumParser on String? {
  T toEnum<T>(List<T> values, T defaultValue) {
    if (this == null) return defaultValue;
    return values.firstWhere(
      (e) => e.toString().split('.').last == this,
      orElse: () => defaultValue,
    );
  }
}

class AppSettings {
  final Locale? locale;
  final ThemeMode themeMode;
  final bool saveAvatarHistory;
  final bool saveBannerHistory;
  final AvatarQuality avatarQuality;
  final HistoryStrategy historyStrategy;
  final int historyLimitN;

  AppSettings({
    this.locale,
    this.themeMode = ThemeMode.system,
    this.saveAvatarHistory = true,
    this.saveBannerHistory = false,
    this.avatarQuality = AvatarQuality.low,
    this.historyStrategy = HistoryStrategy.saveAll,
    this.historyLimitN = 5,
  });

  AppSettings copyWith({
    ThemeMode? themeMode,
    bool? saveAvatarHistory,
    bool? saveBannerHistory,
    AvatarQuality? avatarQuality,
    HistoryStrategy? historyStrategy,
    int? historyLimitN,
  }) {
    return AppSettings(
      locale: locale,
      themeMode: themeMode ?? this.themeMode,
      saveAvatarHistory: saveAvatarHistory ?? this.saveAvatarHistory,
      saveBannerHistory: saveBannerHistory ?? this.saveBannerHistory,
      avatarQuality: avatarQuality ?? this.avatarQuality,
      historyStrategy: historyStrategy ?? this.historyStrategy,
      historyLimitN: historyLimitN ?? this.historyLimitN,
    );
  }

  Map<String, dynamic> toJson() => {
    'languageCode': locale?.languageCode,
    'countryCode': locale?.countryCode,
    'themeMode': themeMode.name,
    'saveAvatarHistory': saveAvatarHistory,
    'saveBannerHistory': saveBannerHistory,
    'avatarQuality': avatarQuality.toString().split('.').last,
    'historyStrategy': historyStrategy.toString().split('.').last,
    'historyLimitN': historyLimitN,
  };

  factory AppSettings.fromJson(Map<String, dynamic> json) {
    final defaultSettings = AppSettings();

    final languageCode = json['languageCode'] as String?;
    final countryCode = json['countryCode'] as String?;

    return AppSettings(
      locale: languageCode != null ? Locale(languageCode, countryCode) : null,
      themeMode: (json['themeMode'] as String?).toEnum(
        ThemeMode.values,
        defaultSettings.themeMode,
      ),
      saveAvatarHistory:
          json['saveAvatarHistory'] as bool? ??
          defaultSettings.saveAvatarHistory,
      saveBannerHistory:
          json['saveBannerHistory'] as bool? ??
          defaultSettings.saveBannerHistory,
      avatarQuality: (json['avatarQuality'] as String?).toEnum(
        AvatarQuality.values,
        defaultSettings.avatarQuality,
      ),
      historyStrategy: (json['historyStrategy'] as String?).toEnum(
        HistoryStrategy.values,
        defaultSettings.historyStrategy,
      ),
      historyLimitN:
          json['historyLimitN'] as int? ?? defaultSettings.historyLimitN,
    );
  }
}


### FILE: ./models/cache_data.dart
// [已更新]
// 核心改动：
// 1. 新增了 `toJson` 方法，用于将 CacheData 对象实例序列化为 Map<String, dynamic>。
// 2. 这是解决 `The method 'toJson' isn't defined` 编译错误所必需的。

class CacheData {
  final String accountId;
  final String accountName;
  final String lastUpdateTime;
  final int followersCount;
  final int followingCount;
  final int unfollowedCount;
  final int mutualUnfollowedCount;
  final int singleUnfollowedCount;
  final int frozenCount;
  final int deactivatedCount;
  final int refollowedCount;
  final int newFollowersCount;
  final int temporarilyRestrictedCount;

  CacheData({
    required this.accountId,
    required this.accountName,
    required this.lastUpdateTime,
    required this.followersCount,
    required this.followingCount,
    required this.unfollowedCount,
    required this.mutualUnfollowedCount,
    required this.singleUnfollowedCount,
    required this.frozenCount,
    required this.deactivatedCount,
    required this.refollowedCount,
    required this.newFollowersCount,
    required this.temporarilyRestrictedCount,
  });

  factory CacheData.fromJson(Map<String, dynamic> json) {
    return CacheData(
      accountId: json['accountId'] ?? '',
      accountName: json['accountName'] ?? 'Unknown',
      lastUpdateTime: json['lastUpdateTime'] ?? '',
      followersCount: json['followersCount'] ?? 0,
      followingCount: json['followingCount'] ?? 0,
      unfollowedCount: json['unfollowedCount'] ?? 0,
      mutualUnfollowedCount: json['mutualUnfollowedCount'] ?? 0,
      singleUnfollowedCount: json['singleUnfollowedCount'] ?? 0,
      frozenCount: json['frozenCount'] ?? 0,
      deactivatedCount: json['deactivatedCount'] ?? 0,
      refollowedCount: json['refollowedCount'] ?? 0,
      newFollowersCount: json['newFollowersCount'] ?? 0,
      temporarilyRestrictedCount: json['temporarilyRestrictedCount'] ?? 0,
    );
  }

  /// [新增] 将 CacheData 实例转换为 Map 的方法
  Map<String, dynamic> toJson() {
    return {
      'accountId': accountId,
      'accountName': accountName,
      'lastUpdateTime': lastUpdateTime,
      'followersCount': followersCount,
      'followingCount': followingCount,
      'unfollowedCount': unfollowedCount,
      'mutualUnfollowedCount': mutualUnfollowedCount,
      'singleUnfollowedCount': singleUnfollowedCount,
      'frozenCount': frozenCount,
      'deactivatedCount': deactivatedCount,
      'refollowedCount': refollowedCount,
      'newFollowersCount': newFollowersCount,
      'temporarilyRestrictedCount': temporarilyRestrictedCount,
    };
  }
}


### FILE: ./models/history_snapshot.dart
import 'package:autonitor/models/twitter_user.dart';
import 'package:autonitor/services/database.dart';

/// 1. 定义一个 Model 来封装列表项所需的数据
class HistorySnapshot {
  // 包含 ID 和 时间戳 的数据库原始条目
  final FollowUserHistoryEntry entry;
  // 重建后的、用于在列表项中显示的 TwitterUser 对象
  final TwitterUser user;
  // 重建后的、用于传递给详情页的 完整JSON字符串
  final String fullJson;

  HistorySnapshot({
    required this.entry,
    required this.user,
    required this.fullJson,
  });
}

### FILE: ./models/twitter_user.dart
// [已更新]
// 核心改动：
// 1. 添加了 `fromJson` 工厂构造函数，让这个类可以从一个Map(JSON)对象创建实例。
// 2. 添加了 `toJson` 方法，让这个类的实例可以被转换成一个Map(JSON)对象。
// 3. 这使得TwitterUser对象可以在应用中被序列化和反序列化，是数据持久化的基础。
class TwitterUser {
  final String avatarUrl;
  final String avatarLocalPath;
  final String name;
  final String id;
  final String restId;
  final String joinTime;
  final String? bio;
  final String? location;
  final String? bannerUrl;
  final String? bannerLocalPath;
  final String? link;
  final int followingCount;
  final int followersCount;
  final int statusesCount;
  final int mediaCount;
  final int favouritesCount;
  final int listedCount;
  final String? latestRawJson;
  final bool isProtected;
  final bool isVerified;

  const TwitterUser({
    required this.avatarUrl,
    required this.avatarLocalPath,
    required this.name,
    required this.id,
    required this.restId,
    required this.joinTime,
    required this.bio,
    required this.location,
    required this.bannerUrl,
    required this.bannerLocalPath,
    required this.link,
    required this.followersCount,
    required this.followingCount,
    required this.statusesCount,
    required this.mediaCount,
    required this.favouritesCount,
    required this.listedCount,
    required this.latestRawJson,
    required this.isProtected,
    required this.isVerified,
  });

  // 从Map(JSON)创建TwitterUser实例
  factory TwitterUser.fromJson(Map<String, dynamic> json) {
    return TwitterUser(
      avatarUrl: json['avatarUrl'] ?? '',
      avatarLocalPath: json['avatarLocalPath'] ?? '',
      name: json['name'] ?? 'Unknown Name',
      id: json['id'] ?? 'Unknown ID',
      restId: json['restId'] ?? '',
      bio: json['bio'],
      location: json['location'],
      joinTime: json['joinTime'],
      bannerUrl: json['bannerUrl'],
      bannerLocalPath: json['bannerLocalPath'],
      link: json['link'],
      followersCount: json['followersCount'] ?? 0,
      followingCount: json['followingCount'] ?? 0,
      statusesCount: json['statusesCount'] ?? 0,
      mediaCount: json['mediaCount'] ?? 0,
      favouritesCount: json['favouritesCount'] ?? 0,
      listedCount: json['listedCount'] ?? 0,
      latestRawJson: json['latestRawJson'] as String?,
      isProtected: (json['isProtected'] ?? 0) == 1,
      isVerified: (json['isVerified'] ?? 0) == 1,
    );
  }

  // 将TwitterUser实例转换为Map(JSON)
  Map<String, dynamic> toJson() {
    return {
      'avatarUrl': avatarUrl,
      'avatarLocalPath': avatarLocalPath,
      'name': name,
      'id': id,
      'restId': restId,
      'bio': bio,
      'location': location,
      'joinTime': joinTime,
      'bannerUrl': bannerUrl,
      'bannerLocalPath': bannerLocalPath,
      'statusesCount': statusesCount,
      'mediaCount': mediaCount,
      'favouritesCount': favouritesCount,
      'listedCount': listedCount,
      'latestRawJson': latestRawJson,
      'isProtected': isProtected,
      'isVerified': isVerified,
    };
  }
}


### FILE: ./providers/analysis_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:async';
import '../core/data_processor.dart';
import '../models/account.dart';
import '../services/database.dart';
import '../services/log_service.dart';
import '../services/twitter_api_service.dart';
import '../services/twitter_api_v1_service.dart';
import '../main.dart';
import 'auth_provider.dart';
import '../providers/settings_provider.dart';
import '../services/image_history_service.dart';
import '../models/app_settings.dart';
import '../repositories/account_repository.dart';

// --- 1. Define the state that this service will hold ---
class AnalysisState {
  final bool isRunning;
  final List<String> log;

  AnalysisState({this.isRunning = false, this.log = const []});

  AnalysisState copyWith({bool? isRunning, List<String>? log}) {
    return AnalysisState(
      isRunning: isRunning ?? this.isRunning,
      log: log ?? this.log,
    );
  }
}

// --- 2. Define the StateNotifier (the Service itself) ---
class AnalysisService extends StateNotifier<AnalysisState> {
  final Ref _ref;
  // The service needs all the tools DataProcessor needs
  late final AppDatabase _database;
  late final TwitterApiService _apiServiceGql;
  late final TwitterApiV1Service _apiServiceV1;

  AnalysisService(this._ref) : super(AnalysisState()) {
    // Get the tools
    _database = _ref.read(databaseProvider);
    _apiServiceGql = _ref.read(twitterApiServiceProvider);
    _apiServiceV1 = _ref.read(twitterApiV1ServiceProvider);
  }

  // --- We will move the logic from runAnalysisProcess here ---
  Future<void> runAnalysis(Account accountToProcess) async {
    // Logic will go here in the next step
    state = state.copyWith(isRunning: true, log: []);
    void logCallback(String message) {
      state = state.copyWith(log: [...state.log, message]);
    }

    logCallback('Initializing DataProcessor...');
    final AppSettings settings;
    final ImageHistoryService imageService;
    final AccountRepository accountRepository;
    try {
      settings = _ref.read(settingsProvider).asData!.value;
      imageService = _ref.read(imageHistoryServiceProvider);
      accountRepository = _ref.read(accountRepositoryProvider);
    } catch (e, s) {
      logCallback('!!! CRITICAL ERROR: Failed to load settings before analysis.');
      state = state.copyWith(isRunning: false);
      logger.e("Failed to load settings/imageService", error: e, stackTrace: s);
      return;
    }
    final dataProcessor = DataProcessor(
      database: _database,
      apiServiceGql: _apiServiceGql,
      apiServiceV1: _apiServiceV1,
      ownerAccount: accountToProcess,
      logCallback: logCallback,
      settings: settings, 
      imageService: imageService,
      accountRepository: accountRepository,
    );
    try {
      await dataProcessor.runFullProcess();
      await _ref.read(accountsProvider.notifier).loadAccounts();
      logCallback('Process finished successfully.');
    } catch (e, s) {
      logCallback('!!! PROCESS FAILED for account ${accountToProcess.id}: $e');
      logCallback('Stacktrace: $s');
      rethrow;
    } finally {
      state = state.copyWith(isRunning: false);
    }
  }
}

// --- 3. Define the provider for this service ---
final analysisServiceProvider =
    StateNotifierProvider<AnalysisService, AnalysisState>((ref) {
      return AnalysisService(ref);
    });

// --- 4. (Recommended) Providers for just the log/status ---
// This makes it easy for the UI to listen *only* to what it needs.
final analysisIsRunningProvider = Provider<bool>((ref) {
  // It derives its state from the main service provider
  return ref.watch(analysisServiceProvider).isRunning;
});

final analysisLogProvider = Provider<List<String>>((ref) {
  // It derives its state from the main service provider
  return ref.watch(analysisServiceProvider).log;
});


### FILE: ./providers/auth_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/account.dart';
import '../services/secure_storage_service.dart';
import '../repositories/account_repository.dart';
import 'package:async/async.dart';
import 'package:async_locks/async_locks.dart';
import 'package:autonitor/services/log_service.dart';

class RefreshResult {
  final String accountId;
  final bool success;
  final String? error;
  RefreshResult({required this.accountId, required this.success, this.error});
}

final accountsProvider = StateNotifierProvider<AccountsNotifier, List<Account>>(
  (ref) {
    return AccountsNotifier(ref);
  },
);

class ActiveAccountNotifier extends StateNotifier<Account?> {
  final Ref _ref;
  late final SecureStorageService _storageService;
  bool _isInitialized = false;

  ActiveAccountNotifier(this._ref) : super(null) {
    _storageService = _ref.read(secureStorageServiceProvider);
  }

  void initializeState(List<Account> accounts, String? activeId) {
    if (_isInitialized || state != null) {
      logger.i("ActiveAccountNotifier: Initialization skipped.");
      return;
    }
    logger.i(
      "ActiveAccountNotifier: Initializing state with ${accounts.length} accounts and activeId: $activeId",
    );
    if (activeId != null && accounts.isNotEmpty) {
      try {
        final initialAccount = accounts.firstWhere((acc) => acc.id == activeId);
        state = initialAccount;
        logger.i(
          "ActiveAccountNotifier: Initial state set to ID ${state?.id} from storage.",
        );
        _isInitialized = true;
      } catch (e) {
        logger.w(
          "ActiveAccountNotifier: Stored active ID $activeId not found. Resetting.",
        );
        _resetActiveAccountAndMarkInitialized(accounts);
      }
    } else if (accounts.isNotEmpty) {
      logger.i(
        "ActiveAccountNotifier: No active ID stored. Setting first account.",
      );
      _resetActiveAccountAndMarkInitialized(accounts);
    } else {
      logger.i("ActiveAccountNotifier: No accounts loaded. State remains null.");
      state = null;
      _isInitialized = true;
    }
  }

  Future<void> _resetActiveAccountAndMarkInitialized(
    List<Account> accounts,
  ) async {
    await _resetActiveAccount(accounts);
    _isInitialized = true;
    logger.i("ActiveAccountNotifier: Initialization completed after reset.");
  }

  Future<void> _resetActiveAccount(List<Account> accounts) async {
    if (accounts.isNotEmpty) {
      state = accounts.first;
      await _storageService.saveActiveAccountId(state!.id);
      logger.i(
        "ActiveAccountNotifier: Reset active account to first ID ${state?.id}.",
      );
    } else {
      state = null;
      await _storageService.deleteActiveAccountId();
      logger.i("ActiveAccountNotifier: Reset called but no accounts available.");
    }
  }

  Future<void> setActive(Account? account) async {
    state = account;
    if (account != null) {
      await _storageService.saveActiveAccountId(account.id);
      logger.i(
        "ActiveAccountNotifier: Set active account ID: ${account.id} and persisted.",
      );
    } else {
      await _storageService.deleteActiveAccountId();
      logger.i("ActiveAccountNotifier: Cleared active account ID and persisted.");
    }
  }

  Future<void> updateFromList(List<Account> newList) async {
    logger.i(
      "ActiveAccountNotifier: (Post-init) Account list updated. Current active ID: ${state?.id}. New list size: ${newList.length}",
    );
    if (state != null) {
      final bool stillExists = newList.any((acc) => acc.id == state!.id);
      if (!stillExists) {
        logger.i(
          "ActiveAccountNotifier: (Post-init) Active account ${state!.id} removed. Resetting.",
        );
        await _resetActiveAccount(newList);
      } else {
        final updatedAccountInstance = newList.firstWhere(
          (acc) => acc.id == state!.id,
        );
        if (state != updatedAccountInstance) {
          state = updatedAccountInstance;
          logger.i(
            "ActiveAccountNotifier: (Post-init) Updated active account instance for ID ${state!.id}.",
          );
        }
      }
    } else if (newList.isNotEmpty) {
      logger.i(
        "ActiveAccountNotifier: (Post-init) State was null, setting first account.",
      );
      await _resetActiveAccount(newList);
    }
  }

  bool get isInitialized => _isInitialized;
}

final activeAccountProvider =
    StateNotifierProvider<ActiveAccountNotifier, Account?>((ref) {
      final notifier = ActiveAccountNotifier(ref);
      ref.listen(accountsProvider, (previousList, newList) {
        if (notifier.isInitialized) {
          logger.i(
            "ActiveAccountNotifier Listen: Initialized, calling updateFromList.",
          );
          notifier.updateFromList(newList);
        } else {
          logger.i(
            "ActiveAccountNotifier Listen: Not initialized yet, skipping updateFromList.",
          );
        }
      });
      return notifier;
    });

class AccountsNotifier extends StateNotifier<List<Account>> {
  final Ref _ref;
  late final SecureStorageService _storageService;
  late final AccountRepository _accountRepository;

  AccountsNotifier(this._ref) : super([]) {
    _storageService = _ref.read(secureStorageServiceProvider);
    _accountRepository = _ref.read(accountRepositoryProvider);
    loadAccounts();
  }

  Future<void> loadAccounts() async {
    List<Account> loadedAccounts = [];
    String? storedActiveId;

    try {
      loadedAccounts = await _accountRepository.getAllAccounts();
      storedActiveId = await _storageService.readActiveAccountId();
    } catch (e, s) {
      logger.e("AccountsNotifier: Error loading accounts from repository: $e\n$s");
    }

    state = loadedAccounts;
    logger.i("AccountsNotifier: Loaded and assembled ${state.length} accounts.");

    _ref
        .read(activeAccountProvider.notifier)
        .initializeState(loadedAccounts, storedActiveId);
  }

  Future<void> addAccount(String cookie) async {
    try {
      await _accountRepository.addAccount(cookie);
      await loadAccounts();
    } catch (e) {
      logger.e("AccountsNotifier: Error adding account: $e");
      rethrow;
    }
  }

  Future<void> removeAccount(String id) async {
    try {
      await _accountRepository.removeAccount(id);
      await loadAccounts();
    } catch (e) {
      logger.e("AccountsNotifier: Error removing account: $e");
      rethrow;
    }
  }

  Future<List<RefreshResult>> refreshAllAccountProfiles(
    List<Account> accounts,
  ) async {
    final semaphore = Semaphore(5);
    final group = FutureGroup<RefreshResult>();
    logger.i(
      "AccountsNotifier: Starting refresh for ${accounts.length} accounts with concurrency limit 5...",
    );
    for (final account in accounts) {
      group.add(
        Future(() async {
          await semaphore.acquire();
          try {
            logger.i("AccountsNotifier: Refreshing profile for ${account.id}...");
            await _refreshSingleAccountProfile(account);
            logger.i("AccountsNotifier: Refresh successful for ${account.id}.");
            return RefreshResult(accountId: account.id, success: true);
          } catch (e) {
            logger.e("AccountsNotifier: Refresh failed for ${account.id}: $e");
            return RefreshResult(
              accountId: account.id,
              success: false,
              error: e.toString(),
            );
          } finally {
            semaphore.release();
          }
        }),
      );
    }
    group.close();
    final results = await group.future;
    logger.i("AccountsNotifier: Refresh process completed.");
    return results;
  }

  Future<void> _refreshSingleAccountProfile(Account account) async {
    try {
      await _accountRepository.refreshAccountProfile(account);
    } catch (e) {
      logger.e("AccountsNotifier: _refreshSingleAccountProfile failed.");
      rethrow;
    }
  }
}


### FILE: ./providers/history_provider.dart
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:autonitor/models/history_snapshot.dart';
import 'package:autonitor/providers/settings_provider.dart';
import 'package:autonitor/repositories/history_repository.dart'; // <-- 1. 导入 Repository

/// 1. 定义 Provider 的参数 (FamilyProvider 仍需要它)
@immutable
class ProfileHistoryParams {
  final String ownerId;
  final String userId;

  const ProfileHistoryParams({required this.ownerId, required this.userId});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProfileHistoryParams &&
          runtimeType == other.runtimeType &&
          ownerId == other.ownerId &&
          userId == other.userId;

  @override
  int get hashCode => ownerId.hashCode ^ userId.hashCode;
}

/// 2. 创建 History Provider (现在它非常简单)
final profileHistoryProvider = AsyncNotifierProvider.family<
    ProfileHistoryNotifier,
    List<HistorySnapshot>,
    ProfileHistoryParams>(() {
  return ProfileHistoryNotifier();
});

class ProfileHistoryNotifier extends FamilyAsyncNotifier<List<HistorySnapshot>, ProfileHistoryParams> {
  
  @override
  Future<List<HistorySnapshot>> build(ProfileHistoryParams arg) async {
    // 3. Provider 的职责：
    
    // a. 监听它依赖的 Provider (设置)
    final settings = ref.watch(settingsProvider).valueOrNull;
    if (settings == null) {
      return []; // 如果设置未加载，不执行
    }

    // b. 获取它需要的 Repository
    final repository = ref.read(historyRepositoryProvider);

    // c. 调用 Repository 的方法并返回结果
    return repository.getFilteredHistory(
      arg.ownerId,
      arg.userId,
      settings,
    );
  }
}

### FILE: ./providers/log_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// --- 1. The Notifier to hold the log history ---
class LogHistoryNotifier extends StateNotifier<List<String>> {
  static const _maxLogLines = 500;
  LogHistoryNotifier() : super([]);

  void addLog(String logEntry) {
    Future(() {
      if (!mounted) return;

      final newState = [...state, logEntry];
      if (newState.length > _maxLogLines) {
        state = newState.sublist(newState.length - _maxLogLines);
      } else {
        state = newState;
      }
    });
  }

  void clearLog() {
    state = [];
  }
}

// --- 2. MODIFICATION: Create a global instance ---
// (修改：创建一个全局实例)
final globalLogHistoryNotifier = LogHistoryNotifier();
// --- END MODIFICATION ---

// --- 3. The Provider for the Notifier ---
final logHistoryNotifierProvider =
    StateNotifierProvider<LogHistoryNotifier, List<String>>((ref) {
      // (Provide the global instance)
      // (提供这个全局实例)
      return globalLogHistoryNotifier;
    });

// --- 4. A simple Provider for just the List<String> ---
final logHistoryProvider = Provider<List<String>>((ref) {
  return ref.watch(logHistoryNotifierProvider);
});


### FILE: ./providers/media_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path_provider/path_provider.dart';

/// 提供 Application Support Directory 的绝对路径
/// UI 层将 watch 这个 Provider
final appSupportDirProvider = FutureProvider<String>((ref) async {
  final supportDir = await getApplicationSupportDirectory();
  return supportDir.path;
});


### FILE: ./providers/report_providers.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:drift/drift.dart' as drift;
import '../models/cache_data.dart';
import '../models/twitter_user.dart';
import '../main.dart';
import 'auth_provider.dart';
import '../repositories/analysis_report_repository.dart';
import 'package:autonitor/services/log_service.dart';

@immutable
class UserListParam {
  final String ownerId;
  final String categoryKey;
  const UserListParam({required this.ownerId, required this.categoryKey});
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserListParam &&
          runtimeType == other.runtimeType &&
          ownerId == other.ownerId &&
          categoryKey == other.categoryKey;
  @override
  int get hashCode => ownerId.hashCode ^ categoryKey.hashCode;
}

final cacheProvider = FutureProvider.autoDispose<CacheData?>((ref) async {
  final database = ref.watch(databaseProvider);
  final activeAccount = ref.watch(activeAccountProvider);

  if (activeAccount == null) {
    logger.i("cacheProvider: No active account, returning null.");
    return null;
  }

  try {
    final changeTypeCol = database.changeReports.changeType;
    final countExp = changeTypeCol.count();

    final query = database.selectOnly(database.changeReports)
      ..addColumns([changeTypeCol, countExp])
      ..where(database.changeReports.ownerId.equals(activeAccount.id));

    query.groupBy([changeTypeCol]);

    final countsResult = await query.get();
    logger.i(
      "cacheProvider: Fetching counts from database for account ${activeAccount.id}...",
    );

    final Map<String, int> categoryCounts = {
      for (var row in countsResult)
        row.read(changeTypeCol)!: row.read(countExp)!,
    };

    logger.i("cacheProvider: Fetched category counts: $categoryCounts");

    final accountDetails = await (database.select(
      database.loggedAccounts,
    )..where((tbl) => tbl.id.equals(activeAccount.id))).getSingleOrNull();

    return CacheData(
      accountId: activeAccount.id,
      accountName: activeAccount.name ?? 'N/A',
      lastUpdateTime: DateTime.now().toIso8601String(),
      followersCount: accountDetails?.followersCount ?? 0,
      followingCount: accountDetails?.followingCount ?? 0,
      unfollowedCount: categoryCounts['normal_unfollowed'] ?? 0,
      mutualUnfollowedCount: categoryCounts['mutual_unfollowed'] ?? 0,
      singleUnfollowedCount: categoryCounts['oneway_unfollowed'] ?? 0,
      frozenCount: categoryCounts['suspended'] ?? 0,
      deactivatedCount: categoryCounts['deactivated'] ?? 0,
      refollowedCount: categoryCounts['be_followed_back'] ?? 0,
      newFollowersCount: categoryCounts['new_followers_following'] ?? 0,
      temporarilyRestrictedCount: categoryCounts['temporarily_restricted'] ?? 0,
    );
  } catch (e, s) {
    logger.e("cacheProvider: Error fetching counts from database: $e\n$s");
    return null;
  }
});

const int _kUserListPageSize = 30;

class UserListNotifier
    extends FamilyAsyncNotifier<List<TwitterUser>, UserListParam> {
  final List<TwitterUser> _users = [];
  bool _hasMore = true;

  @override
  Future<List<TwitterUser>> build(UserListParam arg) async {
    _users.clear();
    _hasMore = true;

    final repository = ref.read(analysisReportRepositoryProvider);
    final newUsers = await repository.getUsersForCategory(
      arg.ownerId,
      arg.categoryKey,
      limit: _kUserListPageSize,
      offset: 0,
    );
    logger.i(
      "UserListNotifier: build() called for owner ${arg.ownerId}, category ${arg.categoryKey}",
    );
    _users.addAll(newUsers);

    if (newUsers.length < _kUserListPageSize) {
      _hasMore = false;
    }

    logger.i(
      "UserListNotifier: build() completed, loaded ${_users.length} users, hasMore=$_hasMore",
    );

    return _users;
  }

  Future<void> fetchMore() async {
    if (state.isLoading || !_hasMore) {
      logger.i(
        "UserListNotifier: fetchMore() skipped, isLoading=${state.isLoading}, hasMore=$_hasMore",
      );
      return;
    }

    logger.i(
      "UserListNotifier: fetchMore() started, current users=${_users.length}",
    );

    state = const AsyncLoading<List<TwitterUser>>().copyWithPrevious(state);

    final repository = ref.read(analysisReportRepositoryProvider);
    final arg = this.arg;

    try {
      final offset = _users.length;

      final newUsers = await repository.getUsersForCategory(
        arg.ownerId,
        arg.categoryKey,
        limit: _kUserListPageSize,
        offset: offset,
      );

      if (newUsers.isEmpty || newUsers.length < _kUserListPageSize) {
        _hasMore = false;
        logger.i(
          "UserListNotifier: fetchMore() fetched less than page size, setting hasMore=false",
        );
      }

      _users.addAll(newUsers);

      state = AsyncData(_users);
      logger.i(
        "UserListNotifier: fetchMore() completed, total users=${_users.length}",
      );
    } catch (e, s) {
      state = AsyncValue<List<TwitterUser>>.error(e, s).copyWithPrevious(state);
      logger.e(
        "UserListNotifier: fetchMore() failed: $e",
        error: e,
        stackTrace: s,
      );
    }
  }

  bool hasMore() {
    return _hasMore;
  }
}

final userListProvider =
    AsyncNotifierProvider.family<
      UserListNotifier,
      List<TwitterUser>,
      UserListParam
    >(() {
      return UserListNotifier();
    });


### FILE: ./providers/settings_provider.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import 'package:autonitor/services/log_service.dart';
import '../models/app_settings.dart';
import '../services/settings_service.dart';

final settingsServiceProvider = Provider((ref) => SettingsService());

final settingsProvider =
    StateNotifierProvider<SettingsNotifier, AsyncValue<AppSettings>>((ref) {
      final service = ref.watch(settingsServiceProvider);
      final log = ref.watch(loggerProvider);
      return SettingsNotifier(service, log);
    });

class SettingsNotifier extends StateNotifier<AsyncValue<AppSettings>> {
  final SettingsService _settingsService;
  final Logger _log;

  SettingsNotifier(this._settingsService, this._log) : super(const AsyncValue.loading()) {
    _load();
  }

  Future<void> _load() async {
    state = const AsyncValue.loading();
    try {
      final settings = await _settingsService.loadSettings();
      state = AsyncValue.data(settings);
    } catch (e, s) {
      state = AsyncValue.error(e, s);
      _log.e('加载设置失败', error: e, stackTrace: s);
    }
  }

  // In: class SettingsNotifier ...
  Future<void> updateLocale(Locale? newLocale) async {
    final currentSettings = state.value ?? AppSettings();
    final newState = AppSettings(
      locale: newLocale,
      themeMode: currentSettings.themeMode,
      saveAvatarHistory: currentSettings.saveAvatarHistory,
      saveBannerHistory: currentSettings.saveBannerHistory,
      avatarQuality: currentSettings.avatarQuality,
      historyStrategy: currentSettings.historyStrategy,
      historyLimitN: currentSettings.historyLimitN,
    );

    state = AsyncValue.data(newState);

    try {
      await _settingsService.saveSettings(newState);
    } catch (e, s) {
      state = AsyncValue.error('保存语言设置失败: $e', s);
      _log.e('保存语言设置失败', error: e, stackTrace: s);
    }
  }

  Future<void> updateSaveAvatarHistory(bool saveAvatar) async {
    final currentState = state;
    if (currentState is! AsyncData<AppSettings>) {
      return;
    }
    final currentSettings = currentState.value;
    final newState = currentSettings.copyWith(saveAvatarHistory: saveAvatar);
    state = AsyncValue.data(newState);
    await _settingsService.saveSettings(newState);
  }

  Future<void> updateSaveBannerHistory(bool saveBanner) async {
    final currentState = state;
    if (currentState is! AsyncData<AppSettings>) {
      return;
    }
    final currentSettings = currentState.value;
    final newState = currentSettings.copyWith(saveBannerHistory: saveBanner);
    state = AsyncValue.data(newState);
    await _settingsService.saveSettings(newState);
  }

  Future<void> updateAvatarQuality(AvatarQuality avatarQuality) async {
    final currentState = state;
    if (currentState is! AsyncData<AppSettings>) {
      return;
    }
    final currentSettings = currentState.value;
    final newState = currentSettings.copyWith(avatarQuality: avatarQuality);
    state = AsyncValue.data(newState);
    await _settingsService.saveSettings(newState);
  }

  Future<void> updateHistoryStrategy(HistoryStrategy historyStrategy) async {
    final currentState = state;
    if (currentState is! AsyncData<AppSettings>) {
      return;
    }
    final currentSettings = currentState.value;
    final newState = currentSettings.copyWith(historyStrategy: historyStrategy);
    state = AsyncValue.data(newState);
    await _settingsService.saveSettings(newState);
  }

  Future<void> updateHistoryLimitN(int historyLimitN) async {
    final currentState = state;
    if (currentState is! AsyncData<AppSettings>) {
      return;
    }
    final currentSettings = currentState.value;
    final newState = currentSettings.copyWith(historyLimitN: historyLimitN);
    state = AsyncValue.data(newState);
    await _settingsService.saveSettings(newState);
  }

  Future<void> updateThemeMode(ThemeMode newMode) async {
    final currentSettings = state.value ?? AppSettings();
    final newState = currentSettings.copyWith(themeMode: newMode);

    state = AsyncValue.data(newState);

    try {
      await _settingsService.saveSettings(newState);
    } catch (e, s) {
      state = AsyncValue.error('Failed to save theme: $e', s);
      _log.e('Failed to save themeMode setting', error: e, stackTrace: s);
    }
  }
}


### FILE: ./repositories/account_repository.dart
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:drift/drift.dart';
import 'dart:convert';
import '../models/account.dart';
import '../services/database.dart';
import '../services/twitter_api_service.dart';
import '../services/secure_storage_service.dart';
import '../main.dart';
import '../utils/diff_utils.dart';
import 'package:autonitor/services/log_service.dart';
import '../models/app_settings.dart';
import '../providers/settings_provider.dart';
import '../services/image_history_service.dart';

final accountRepositoryProvider = Provider<AccountRepository>((ref) {
  final db = ref.watch(databaseProvider);
  final apiService = ref.watch(twitterApiServiceProvider);
  final secureStorage = ref.watch(secureStorageServiceProvider);
  return AccountRepository(db, apiService, secureStorage, ref);
});

class AccountRepository {
  final AppDatabase _database;
  final TwitterApiService _apiService;
  final SecureStorageService _secureStorage;
  final Ref _ref;

  AccountRepository(
    this._database,
    this._apiService,
    this._secureStorage,
    this._ref,
  );

  String? _parseidFromCookie(String cookie) {
    try {
      final parts = cookie.split(';');
      final idPart = parts.firstWhere(
        (part) => part.trim().startsWith('twid='),
        orElse: () => '',
      );
      if (idPart.isNotEmpty) {
        var valuePart = idPart.split('=')[1].trim();
        valuePart = Uri.decodeComponent(valuePart);
        if (valuePart.startsWith('u=')) {
          final id = valuePart.substring(2);
          return id.isNotEmpty ? id : null;
        } else if (valuePart.startsWith('u_')) {
          final id = valuePart.substring(2);
          return id.isNotEmpty ? id : null;
        } else {
          logger.w("解析 id 失败: id value ($valuePart) 不以 'u=' 或 'u_' 开头");
          return null;
        }
      }
      return null;
    } catch (e, s) {
      logger.e("Error parsing id from cookie", error: e, stackTrace: s);
      return null;
    }
  }

  Future<Account> addAccount(String cookie) async {
    final id = _parseidFromCookie(cookie);
    if (id == null) {
      throw Exception('Unable to parse ID from Cookie');
    }
    await _secureStorage.saveCookie(id, cookie);
    logger.i("addAccount: Saved cookie to SecureStorage for ID: $id");
    return await _fetchAndSaveAccountProfile(id, cookie);
  }

  Future<void> removeAccount(String id) async {
    try {
      await _secureStorage.deleteCookie(id);
      logger.i(
        "AccountRepository: Deleted cookie from SecureStorage for ID $id.",
      );

      final deletedRows = await (_database.delete(
        _database.loggedAccounts,
      )..where((tbl) => tbl.id.equals(id))).go();

      if (deletedRows > 0) {
        logger.i(
          "AccountRepository: Deleted profile from database for ID $id.",
        );
      } else {
        logger.w(
          "AccountRepository: Tried to delete profile for ID $id, but it was not found.",
        );
      }
    } catch (e, s) {
      logger.e(
        "AccountRepository: Error removing account ID $id",
        error: e,
        stackTrace: s,
      );
      throw Exception('Failed to remove account: $e');
    }
  }

  Future<List<Account>> getAllAccounts() async {
    try {
      final profiles = await _database.select(_database.loggedAccounts).get();
      final cookies = await _secureStorage.getAllCookies();
      final List<Account> loadedAccounts = [];
      for (final profile in profiles) {
        final cookie = cookies[profile.id];
        if (cookie != null) {
          loadedAccounts.add(
            Account(
              id: profile.id,
              cookie: cookie,
              name: profile.name,
              screenName: profile.screenName,
              avatarUrl: profile.avatarUrl,
              bannerUrl: profile.bannerUrl,
              bio: profile.bio,
              location: profile.location,
              link: profile.link,
              joinTime: profile.joinTime,
              followersCount: profile.followersCount,
              followingCount: profile.followingCount,
              statusesCount: profile.statusesCount,
              mediaCount: profile.mediaCount,
              favouritesCount: profile.favouritesCount,
              listedCount: profile.listedCount,
              latestRawJson: profile.latestRawJson,
              isVerified: profile.isVerified ?? false,
              isProtected: profile.isProtected ?? false,
            ),
          );
        } else {
          logger.w(
            "AccountRepository: Profile found for ID ${profile.id} but no cookie in SecureStorage. Skipping.",
          );
        }
      }
      return loadedAccounts;
    } catch (e, s) {
      logger.e(
        "AccountRepository: Error getting all accounts",
        error: e,
        stackTrace: s,
      );
      rethrow;
    }
  }

  Future<Account> refreshAccountProfile(Account account) async {
    return await _fetchAndSaveAccountProfile(account.id, account.cookie);
  }

  Future<Account> _fetchAndSaveAccountProfile(String id, String cookie) async {
    String? name;
    String? screenName;
    String? avatarUrl;
    String? bannerUrl;
    String? bio;
    String? location;
    String? link;
    String? joinTime;
    int followersCount = 0;
    int followingCount = 0;
    int statusesCount = 0;
    int mediaCount = 0;
    int favouritesCount = 0;
    int listedCount = 0;
    String rawJsonString = '{}';
    bool isVerified = false;
    bool isProtected = false;
    try {
      final Map<String, dynamic> userProfileJson = await _apiService
          .getUserByRestId(id, cookie);
      rawJsonString = jsonEncode(userProfileJson);
      final result = userProfileJson['data']?['user']?['result'];
      if (result != null &&
          result is Map<String, dynamic> &&
          result['__typename'] == 'User') {
        final core = result['core'];
        final legacy = result['legacy'];
        if (core != null && core is Map<String, dynamic>) {
          name = core['name'] as String?;
          screenName = core['screen_name'] as String?;
          avatarUrl = (result['avatar']['image_url'] as String?);
          joinTime = core['created_at'] as String?;
          logger.i(
            "addAccount: Profile fetched - Name: $name, ScreenName: $screenName, Avatar: $avatarUrl",
          );
        } else {
          logger.w("addAccount: API 返回成功，但 core 数据缺失或格式不正确。");
        }
        if (legacy != null && legacy is Map<String, dynamic>) {
          bio = legacy['description'] as String?;
          followersCount = legacy['followers_count'] as int? ?? 0;
          followingCount = legacy['friends_count'] as int? ?? 0;
          final String? tcoUrl = legacy['url'] as String?;
          String? finalLink = tcoUrl;
          try {
            final entities = legacy['entities'] as Map<String, dynamic>?;
            final urlBlock = entities?['url'] as Map<String, dynamic>?;
            final urlsList = urlBlock?['urls'] as List<dynamic>?;
            if (tcoUrl != null && urlsList != null) {
              for (final item in urlsList) {
                final urlMap = item as Map<String, dynamic>?;
                if (urlMap != null && urlMap['url'] == tcoUrl) {
                  finalLink = urlMap['expanded_url'] as String?;
                  break;
                }
              }
            }
          } catch (e, s) {
            logger.w(
              "addAccount: Failed to parse URL entities",
              error: e,
              stackTrace: s,
            );
          }
          link = finalLink;
          bannerUrl = legacy['profile_banner_url'] as String?;
          statusesCount = legacy['statuses_count'] as int? ?? 0;
          mediaCount = legacy['media_count'] as int? ?? 0;
          favouritesCount = legacy['favourites_count'] as int? ?? 0;
          listedCount = legacy['listed_count'] as int? ?? 0;
          isVerified = result['verification']['verified'] as bool? ?? false;
          isProtected = result['privacy']['protected'] as bool? ?? false;
        }
        final locationMap = result['location'] as Map<String, dynamic>?;
        location = locationMap?['location'] as String?;
      } else {
        logger.w(
          "addAccount: The API call succeeded, but the result field is either missing or malformed.",
        );
      }
    } catch (e, s) {
      logger.e(
        "addAccount: Failed to call the API or parse the Profile.",
        error: e,
        stackTrace: s,
      );
      rethrow;
    }
    try {
      final settingsValue = _ref.read(settingsProvider);
      final imageService = _ref.read(imageHistoryServiceProvider);

      final AppSettings settings;
      if (settingsValue is AsyncData<AppSettings>) {
        settings = settingsValue.value;
      } else {
        logger.e("在 AccountRepository 中读取设置失败，状态为: $settingsValue");
        throw Exception("无法执行操作，因为设置未准备好: $settingsValue");
      }
      await _database.transaction(() async {
        final oldProfile = await (_database.select(
          _database.loggedAccounts,
        )..where((tbl) => tbl.id.equals(id))).getSingleOrNull();
        final oldJsonString = oldProfile?.latestRawJson;
        final diffString = calculateReverseDiff(rawJsonString, oldJsonString);
        logger.i(
          "addAccount: Calculated reverse diff (length: ${diffString?.length ?? 'null'}) for ID: $id",
        );
        final String? newAvatarLocalPath = await imageService
            .processMediaUpdate(
              ownerId: id,
              userId: id,
              mediaType: MediaType.avatar,
              oldUrl: oldProfile?.avatarUrl,
              newUrl: avatarUrl, // (这是你从 API 获取的 avatarUrl)
              settings: settings, // 使用我们从 read 读到的 settings
            );

        // 11. (新) 处理横幅下载
        final String? newBannerLocalPath = await imageService
            .processMediaUpdate(
              ownerId: id,
              userId: id,
              mediaType: MediaType.banner,
              oldUrl: oldProfile?.bannerUrl,
              newUrl: bannerUrl, // (这是你从 API 获取的 bannerUrl)
              settings: settings, // 使用我们从 read 读到的 settings
            );
        final companion = LoggedAccountsCompanion(
          id: Value(id),
          name: name == null ? const Value.absent() : Value(name),
          screenName: screenName == null
              ? const Value.absent()
              : Value(screenName),
          avatarUrl: avatarUrl == null
              ? const Value.absent()
              : Value(avatarUrl),
          bannerUrl: bannerUrl == null
              ? const Value.absent()
              : Value(bannerUrl),
          bio: bio == null ? const Value.absent() : Value(bio),
          location: location == null ? const Value.absent() : Value(location),
          link: link == null ? const Value.absent() : Value(link),
          joinTime: joinTime == null ? const Value.absent() : Value(joinTime),
          followersCount: Value(followersCount),
          followingCount: Value(followingCount),
          statusesCount: Value(statusesCount),
          mediaCount: Value(mediaCount),
          favouritesCount: Value(favouritesCount),
          listedCount: Value(listedCount),
          isVerified: Value(isVerified),
          isProtected: Value(isProtected),
          latestRawJson: Value(rawJsonString),
          avatarLocalPath: newAvatarLocalPath != null
              ? Value(newAvatarLocalPath)
              : (avatarUrl == oldProfile?.avatarUrl
                    ? Value(oldProfile?.avatarLocalPath)
                    : const Value.absent()),

          bannerLocalPath: newBannerLocalPath != null
              ? Value(newBannerLocalPath)
              : (bannerUrl == oldProfile?.bannerUrl
                    ? Value(oldProfile?.bannerLocalPath)
                    : const Value.absent()),
        );
        await _database
            .into(_database.loggedAccounts)
            .insert(companion, mode: InsertMode.replace);
        logger.i(
          "addAccount: Inserted/Replaced profile in LoggedAccounts for ID: $id",
        );
        if (diffString != null && diffString.isNotEmpty) {
          final historyCompanion = AccountProfileHistoryCompanion(
            ownerId: Value(id),
            reverseDiffJson: Value(diffString),
            timestamp: Value(DateTime.now()),
          );
          await _database
              .into(_database.accountProfileHistory)
              .insert(historyCompanion);
          logger.i(
            "addAccount: Inserted profile history into AccountProfileHistory for ID: $id",
          );
        }
      });
      return Account(
        id: id,
        cookie: cookie,
        name: name,
        screenName: screenName,
        avatarUrl: avatarUrl,
        bannerUrl: bannerUrl,
        bio: bio,
        location: location,
        link: link,
        joinTime: joinTime,
        followersCount: followersCount,
        followingCount: followingCount,
        statusesCount: statusesCount,
        mediaCount: mediaCount,
        favouritesCount: favouritesCount,
        isVerified: isVerified,
        isProtected: isProtected,
        listedCount: listedCount,
        latestRawJson: rawJsonString,
      );
    } catch (e, s) {
      logger.e(
        "addAccount: Error during database transaction for ID $id",
        error: e,
        stackTrace: s,
      );
      throw Exception('Failed to save account data: $e');
    }
  }

  // --- 稍后我们会把 AccountsNotifier 中的方法逻辑搬到这里 ---
  // 比如：
  // Future<Account> addNewAccount(String cookie) async { ... }
  // Future<void> removeAccount(String id) async { ... }
  // Future<List<Account>> getAllAccounts() async { ... }
}


### FILE: ./repositories/analysis_report_repository.dart
// lib/repositories/analysis_report_repository.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:drift/drift.dart';
import '../services/database.dart';
import '../models/twitter_user.dart';
import '../main.dart';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:autonitor/services/log_service.dart';

final analysisReportRepositoryProvider = Provider<AnalysisReportRepository>((
  ref,
) {
  final db = ref.watch(databaseProvider);
  return AnalysisReportRepository(db);
});

class AnalysisReportRepository {
  final AppDatabase _database;

  AnalysisReportRepository(this._database);

  Future<List<TwitterUser>> getUsersForCategory(
    String ownerId,
    String categoryKey, {
    required int limit,
    required int offset,
  }) async {
    logger.i(
      "AnalysisReportRepository: Getting users for category '$categoryKey' for owner '$ownerId' (Limit: $limit, Offset: $offset)...",
    );
    try {
      List<ParseParams> paramsList = [];

      if (categoryKey == 'followers' || categoryKey == 'following') {
        final bool isFollower = (categoryKey == 'followers');
        final query = _database.select(_database.followUsers)
          ..where(
            (tbl) =>
                tbl.ownerId.equals(ownerId) &
                (isFollower
                    ? tbl.isFollower.equals(true)
                    : tbl.isFollowing.equals(true)),
          );

        // --- 修改：应用分页 ---
        final followUsers = await (query..limit(limit, offset: offset)).get();

        logger.i(
          "AnalysisReportRepository: Fetched ${followUsers.length} users.",
        );

        paramsList = followUsers
            .map(
              (user) => ParseParams(
                userId: user.userId,
                dbScreenName: user.screenName,
                dbName: user.name,
                dbAvatarUrl: user.avatarUrl,
                dbAvatarLocalPath: user.avatarLocalPath,
                dbBannerLocalPath: user.bannerLocalPath,
                dbBio: user.bio,
                jsonString: user.latestRawJson,
              ),
            )
            .toList();
      }
      // 逻辑 2: 获取所有其他差异列表 (历史快照)
      else {
        final reportQuery = _database.select(_database.changeReports)
          ..where(
            (tbl) =>
                tbl.ownerId.equals(ownerId) &
                tbl.changeType.equals(categoryKey),
          );

        // --- 修改：应用分页 ---
        final reportResults = await (reportQuery..limit(limit, offset: offset))
            .get();

        logger.i(
          "AnalysisReportRepository: Fetched ${reportResults.length} user snapshots from ChangeReport for '$categoryKey'.",
        );

        if (reportResults.isEmpty) {
          return [];
        }

        paramsList = reportResults
            .map(
              (report) => ParseParams(
                userId: report.userId,
                jsonString: report.userSnapshotJson,
              ),
            )
            .toList();
      }

      return await compute(parseListInCompute, paramsList);
    } catch (e, s) {
      logger.e(
        "AnalysisReportRepository: Error in getUsersForCategory '$categoryKey'",
        error: e,
        stackTrace: s,
      );
      throw Exception('Failed to load user list: $e');
    }
  }
}

// --- 顶层辅助类和函数 (保持不变) ---

class ParseParams {
  final String userId;
  final String? dbScreenName;
  final String? dbName;
  final String? dbAvatarUrl;
  final String? dbAvatarLocalPath;
  final String? dbBannerLocalPath;
  final String? dbBio;
  final String? jsonString;

  ParseParams({
    required this.userId,
    this.dbScreenName,
    this.dbName,
    this.dbAvatarUrl,
    this.dbAvatarLocalPath,
    this.dbBannerLocalPath,
    this.dbBio,
    this.jsonString,
  });
}

List<TwitterUser> parseListInCompute(List<ParseParams> paramsList) {
  return paramsList
      .map((params) => parseFollowUserToTwitterUser(params))
      .toList();
}

TwitterUser parseFollowUserToTwitterUser(ParseParams params) {
  String? screenName = params.dbScreenName;
  String? name = params.dbName;
  String? avatarUrl = params.dbAvatarUrl;
  String? avatarLocalPath = params.dbAvatarLocalPath;
  String? bio = params.dbBio;
  String? location, link, joinTime, bannerUrl;
  int followersCount = 0,
      followingCount = 0,
      statusesCount = 0,
      mediaCount = 0,
      favouritesCount = 0,
      listedCount = 0;
  bool isVerified = false;
  bool isProtected = false;

  if (params.jsonString != null && params.jsonString!.isNotEmpty) {
    try {
      final parsedJson = jsonDecode(params.jsonString!) as Map<String, dynamic>;

      name = parsedJson['name'] as String? ?? name;
      screenName = parsedJson['screen_name'] as String? ?? screenName;
      avatarUrl = parsedJson['profile_image_url_https'] as String? ?? avatarUrl;
      avatarLocalPath = parsedJson['avatar_local_path'] as String? ??
          avatarLocalPath;
      bio = parsedJson['description'] as String? ?? bio;
      location = parsedJson['location'] as String?;
      joinTime = parsedJson['created_at'] as String?;
      bannerUrl = parsedJson['profile_banner_url'] as String?;
      followersCount = parsedJson['followers_count'] as int? ?? 0;
      followingCount =
          parsedJson['friends_count'] as int? ?? 0; // API 1.1 使用 friends_count
      statusesCount = parsedJson['statuses_count'] as int? ?? 0;
      mediaCount = parsedJson['media_count'] as int? ?? 0;
      favouritesCount = parsedJson['favourites_count'] as int? ?? 0;
      listedCount = parsedJson['listed_count'] as int? ?? 0;
      isProtected = parsedJson['protected'] as bool? ?? false;
      isVerified = parsedJson['ext_is_blue_verified'] as bool? ?? false;

      link = parsedJson['url'] as String?; // 默认 t.co 链接
      final entities = parsedJson['entities'] as Map<String, dynamic>?;
      final urlBlock = entities?['url'] as Map<String, dynamic>?;
      final urlsList = urlBlock?['urls'] as List<dynamic>?;
      if (link != null && urlsList != null && urlsList.isNotEmpty) {
        for (final item in urlsList) {
          final urlMap = item as Map<String, dynamic>?;
          if (urlMap != null && urlMap['url'] == link) {
            link = urlMap['expanded_url'] as String?; // 替换为 expanded_url
            break;
          }
        }
      }
    } catch (e, s) {
      logger.e(
        "AnalysisReportRepository (compute): Error parsing rawJson for user ${params.userId}",
        error: e,
        stackTrace: s,
      );
    }
  }

  return TwitterUser(
    restId: params.userId,
    id: screenName ?? params.userId, // handle
    name: name ?? 'Unknown Name',
    avatarUrl: avatarUrl ?? '',
    avatarLocalPath: avatarLocalPath ?? '',
    bannerLocalPath: params.dbBannerLocalPath,
    bio: bio,
    location: location,
    link: link,
    joinTime: joinTime ?? '',
    bannerUrl: bannerUrl,
    followersCount: followersCount,
    followingCount: followingCount,
    statusesCount: statusesCount,
    mediaCount: mediaCount,
    favouritesCount: favouritesCount,
    listedCount: listedCount,
    latestRawJson: params.jsonString,
    isVerified: isVerified,
    isProtected: isProtected,
  );
}


### FILE: ./repositories/history_repository.dart
// [文件: lib/repositories/history_repository.dart]

import 'dart:convert';
import 'package:autonitor/main.dart'; // (这个可能不再需要，但留着无妨)
import 'package:autonitor/models/app_settings.dart';
import 'package:autonitor/models/history_snapshot.dart';
import 'package:autonitor/repositories/analysis_report_repository.dart';
import 'package:autonitor/services/database.dart';
import 'package:autonitor/utils/diff_utils.dart';
import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// (Provider 定义不变)
final historyRepositoryProvider = Provider<HistoryRepository>((ref) {
  final db = ref.watch(databaseProvider);
  return HistoryRepository(db);
});

/// (Repository 类定义不变)
class HistoryRepository {
  final AppDatabase _db; // <-- 这个字段现在会被使用了
  HistoryRepository(this._db);

  // (常量定义不变)
  static const Set<String> _textKeys = {
    "name",
    "screen_name",
    "description",
    "url",
    "location"
  };
  static const Set<String> _imageKeys = {
    "profile_image_url_https",
    "profile_banner_url"
  };
  static final Set<String> _relevantKeys = _textKeys.union(_imageKeys);

  /// 4. 这是 Provider 将调用的公共方法
  Future<List<HistorySnapshot>> getFilteredHistory(
    String ownerId,
    String userId,
    AppSettings settings,
  ) async {
    // --- 核心修改：在主线程中查询数据库 ---

    // 1. 获取最新数据 (我们的起点)
    final currentUser = await (_db.select(_db.followUsers)
          ..where(
            (tbl) => tbl.ownerId.equals(ownerId) & tbl.userId.equals(userId),
          ))
        .getSingleOrNull();

    if (currentUser == null || currentUser.latestRawJson == null) {
      return []; // 没有当前数据，无法重建
    }

    // 2. 获取所有历史补丁 (从新到旧)
    final historyEntries = await (_db.select(_db.followUsersHistory)
          ..where(
            (tbl) => tbl.ownerId.equals(ownerId) & tbl.userId.equals(userId),
          )
          ..orderBy([
            (tbl) =>
                OrderingTerm(expression: tbl.timestamp, mode: OrderingMode.desc),
          ]))
        .get();
    
    // --- 修改结束 ---

    // 5. 将 *纯数据*（可发送）传递给 compute 块
    return await compute(
      _reconstructAndFilterHistory,
      {
        // 我们不再发送 'db'
        'settings': settings,
        'userId': userId,
        'latestRawJson': currentUser.latestRawJson!, // 传入 String
        'historyEntries': historyEntries, // 传入 List<FollowUserHistoryEntry>
      },
    );
  }
}

/// 6. 这是在独立 Isolate 中运行的重建和过滤函数
///    (它现在只接收纯数据，不再需要 AppDatabase)
Future<List<HistorySnapshot>> _reconstructAndFilterHistory(
    Map<String, dynamic> context) async {
  // --- 核心修改：从 context 中解包纯数据 ---
  // (不再创建 AppDatabase)
  final AppSettings settings = context['settings'];
  final String userId = context['userId'];
  final String latestRawJson = context['latestRawJson'];
  final List<FollowUserHistoryEntry> historyEntries = context['historyEntries'];
  // --- 修改结束 ---

  // (从 HistoryRepository 访问常量)
  final Set<String> textKeys = HistoryRepository._textKeys;
  // --- 修复警告：移除未使用的 'imageKeys' 变量 ---
  // final Set<String> imageKeys = HistoryRepository._imageKeys; // <-- 移除
  final Set<String> relevantKeys = HistoryRepository._relevantKeys;

  // (数据库查询已在主线程完成，这里直接使用数据)

  final List<HistorySnapshot> filteredSnapshots = [];
  Map<String, dynamic> currentJsonMap;
  try {
    currentJsonMap = jsonDecode(latestRawJson);
  } catch (e) {
    return []; // JSON 损坏，无法继续
  }

  // (所有剩余的循环、过滤、重建逻辑... 均保持不变)
  for (final entry in historyEntries) {
    final Map<String, dynamic> patchMap;
    try {
      patchMap = jsonDecode(entry.reverseDiffJson) as Map<String, dynamic>;
    } catch (e) {
      continue;
    }

    final jsonForThisSnapshot = Map<String, dynamic>.from(currentJsonMap);
    applyReversePatch(currentJsonMap, entry.reverseDiffJson);
    final patchKeys = patchMap.keys.toSet();

    final bool hasRelevantChange =
        patchKeys.any((k) => relevantKeys.contains(k));
    if (!hasRelevantChange) {
      continue;
    }

    final bool hasTextChange = patchKeys.any((k) => textKeys.contains(k));
    final bool onlyImageChange = !hasTextChange;

    if (onlyImageChange) {
      final bool hadAvatarChange =
          patchKeys.contains("profile_image_url_https");
      final bool hadBannerChange = patchKeys.contains("profile_banner_url");

      if (hadAvatarChange && !settings.saveAvatarHistory) {
        continue;
      }
      if (hadBannerChange && !settings.saveBannerHistory) {
        continue;
      }
    }

    final params = ParseParams(
      userId: userId,
      jsonString: jsonEncode(jsonForThisSnapshot),
    );
    final reconstructedUser = parseFollowUserToTwitterUser(params);

    filteredSnapshots.add(HistorySnapshot(
      entry: entry,
      user: reconstructedUser,
      fullJson: jsonEncode(jsonForThisSnapshot),
    ));
  }

  return filteredSnapshots;
}

### FILE: ./services/database.dart
import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

part 'database.g.dart';

@DataClassName('LoggedAccount')
class LoggedAccounts extends Table {
  TextColumn get id => text()();
  TextColumn get name => text().nullable()();
  TextColumn get screenName => text().nullable()();
  TextColumn get bio => text().nullable()();
  TextColumn get location => text().nullable()();
  TextColumn get link => text().nullable()();
  TextColumn get joinTime => text().nullable()();
  BoolColumn get isVerified =>
      boolean().nullable().withDefault(const Constant(false))();
  BoolColumn get isProtected =>
      boolean().nullable().withDefault(const Constant(false))();
  IntColumn get followersCount => integer().withDefault(const Constant(0))();
  IntColumn get followingCount => integer().withDefault(const Constant(0))();
  IntColumn get statusesCount => integer().withDefault(const Constant(0))();
  IntColumn get mediaCount => integer().withDefault(const Constant(0))();
  IntColumn get favouritesCount => integer().withDefault(const Constant(0))();
  IntColumn get listedCount => integer().withDefault(const Constant(0))();
  TextColumn get latestRawJson => text().named('latest_raw_json').nullable()();
  TextColumn get avatarUrl => text().nullable()();
  TextColumn get bannerUrl => text().nullable()();
  TextColumn get avatarLocalPath =>
      text().named('avatar_local_path').nullable()();
  TextColumn get bannerLocalPath =>
      text().named('banner_local_path').nullable()();
  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('AccountProfileHistoryEntry')
class AccountProfileHistory extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get ownerId => text()
      .named('owner_id')
      .references(LoggedAccounts, #id, onDelete: KeyAction.cascade)();
  TextColumn get reverseDiffJson => text().named('reverse_diff_json')();
  DateTimeColumn get timestamp => dateTime()();
}

@DataClassName('FollowUser')
class FollowUsers extends Table {
  TextColumn get ownerId => text()
      .named('owner_id')
      .references(LoggedAccounts, #id, onDelete: KeyAction.cascade)();
  TextColumn get userId => text().named('user_id')();
  TextColumn get latestRawJson => text().named('latest_raw_json').nullable()();
  TextColumn get name => text().nullable()();
  TextColumn get screenName => text().nullable()();
  TextColumn get avatarUrl => text().nullable()();
  TextColumn get bannerUrl => text().nullable()();
  TextColumn get bio => text().nullable()();
  TextColumn get avatarLocalPath =>
      text().named('avatar_local_path').nullable()();
  TextColumn get bannerLocalPath =>
      text().named('banner_local_path').nullable()();
  BoolColumn get isFollower => boolean().withDefault(const Constant(false))();
  BoolColumn get isFollowing => boolean().withDefault(const Constant(false))();
  @override
  Set<Column> get primaryKey => {ownerId, userId};
}

@DataClassName('FollowUserHistoryEntry')
class FollowUsersHistory extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get ownerId => text().named('owner_id')();
  TextColumn get userId => text().named('user_id')();
  TextColumn get reverseDiffJson => text().named('reverse_diff_json')();
  DateTimeColumn get timestamp => dateTime()();
  @override
  List<String> get customConstraints => [
    'FOREIGN KEY(owner_id, user_id) REFERENCES follow_users(owner_id, user_id) ON DELETE CASCADE',
  ];
}

@DataClassName('ChangeReportEntry')
class ChangeReports extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get ownerId => text()
      .named('owner_id')
      .references(LoggedAccounts, #id, onDelete: KeyAction.cascade)();
  TextColumn get userId => text().named('user_id')();
  TextColumn get changeType => text().named('change_type')();
  DateTimeColumn get timestamp => dateTime()();
  TextColumn get userSnapshotJson =>
      text().named('user_snapshot_json').nullable()();
}

@DataClassName('MediaHistoryEntry')
class MediaHistory extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get userId => text().named('user_id')();
  TextColumn get mediaType => text().named('media_type')();
  TextColumn get localFilePath => text().named('local_file_path')();
  TextColumn get remoteUrl => text().named('remote_url')();
  DateTimeColumn get timestamp => dateTime()();
}

@DriftDatabase(
  tables: [
    LoggedAccounts,
    AccountProfileHistory,
    FollowUsers,
    FollowUsersHistory,
    ChangeReports,
    MediaHistory,
  ],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 1;

  Future<List<FollowUser>> getNetworkRelationships(String ownerId) async {
    return (select(
      followUsers,
    )..where((tbl) => tbl.ownerId.equals(ownerId))).get();
  }

  Future<void> batchUpsertNetworkRelationships(
    List<FollowUsersCompanion> companions,
  ) async {
    await batch((batch) {
      batch.insertAll(followUsers, companions, mode: InsertMode.replace);
    });
  }

  Future<void> deleteNetworkRelationships(
    String ownerId,
    List<String> userIdsToRemove,
  ) async {
    await (delete(followUsers)..where(
          (tbl) =>
              tbl.ownerId.equals(ownerId) & tbl.userId.isIn(userIdsToRemove),
        ))
        .go();
  }

  Future<void> batchInsertFollowUsersHistory(
    List<FollowUsersHistoryCompanion> historyCompanions,
  ) async {
    await batch((batch) {
      batch.insertAll(followUsersHistory, historyCompanions);
    });
  }

  Future<void> replaceChangeReport(
    String ownerId,
    List<ChangeReportsCompanion> reportCompanions,
  ) async {
    await transaction(() async {
      await (delete(
        changeReports,
      )..where((tbl) => tbl.ownerId.equals(ownerId))).go();

      await batch((batch) {
        batch.insertAll(changeReports, reportCompanions);
      });
    });
  }

  Future<int> insertMediaHistory(MediaHistoryCompanion companion) {
    return into(mediaHistory).insert(companion);
  }

  Future<void> updateFollowUserLocalPath({
    required String ownerId,
    required String userId,
    String? avatarPath,
    String? bannerPath,
  }) {
    final companion = FollowUsersCompanion(
      avatarLocalPath: avatarPath == null
          ? const Value.absent()
          : Value(avatarPath),
      bannerLocalPath: bannerPath == null
          ? const Value.absent()
          : Value(bannerPath), bannerUrl: const Value.absent(),
    );

    return (update(followUsers)..where(
          (tbl) => tbl.ownerId.equals(ownerId) & tbl.userId.equals(userId),
        ))
        .write(companion);
  }

  Future<void> updateLoggedAccountLocalPath({
    required String accountId,
    String? avatarPath,
    String? bannerPath,
  }) {
    final companion = LoggedAccountsCompanion(
      avatarLocalPath: avatarPath == null
          ? const Value.absent()
          : Value(avatarPath),
      bannerLocalPath: bannerPath == null
          ? const Value.absent()
          : Value(bannerPath),
    );

    return (update(
      loggedAccounts,
    )..where((tbl) => tbl.id.equals(accountId))).write(companion);
  }
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationSupportDirectory();
    await Directory(dbFolder.path).create(recursive: true);
    final file = File(p.join(dbFolder.path, 'autonitor_data.db'));
    return NativeDatabase(file);
  });
}


### FILE: ./services/database.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $LoggedAccountsTable extends LoggedAccounts
    with TableInfo<$LoggedAccountsTable, LoggedAccount> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LoggedAccountsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _screenNameMeta = const VerificationMeta(
    'screenName',
  );
  @override
  late final GeneratedColumn<String> screenName = GeneratedColumn<String>(
    'screen_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bioMeta = const VerificationMeta('bio');
  @override
  late final GeneratedColumn<String> bio = GeneratedColumn<String>(
    'bio',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _locationMeta = const VerificationMeta(
    'location',
  );
  @override
  late final GeneratedColumn<String> location = GeneratedColumn<String>(
    'location',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _linkMeta = const VerificationMeta('link');
  @override
  late final GeneratedColumn<String> link = GeneratedColumn<String>(
    'link',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _joinTimeMeta = const VerificationMeta(
    'joinTime',
  );
  @override
  late final GeneratedColumn<String> joinTime = GeneratedColumn<String>(
    'join_time',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isVerifiedMeta = const VerificationMeta(
    'isVerified',
  );
  @override
  late final GeneratedColumn<bool> isVerified = GeneratedColumn<bool>(
    'is_verified',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_verified" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isProtectedMeta = const VerificationMeta(
    'isProtected',
  );
  @override
  late final GeneratedColumn<bool> isProtected = GeneratedColumn<bool>(
    'is_protected',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_protected" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _followersCountMeta = const VerificationMeta(
    'followersCount',
  );
  @override
  late final GeneratedColumn<int> followersCount = GeneratedColumn<int>(
    'followers_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _followingCountMeta = const VerificationMeta(
    'followingCount',
  );
  @override
  late final GeneratedColumn<int> followingCount = GeneratedColumn<int>(
    'following_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _statusesCountMeta = const VerificationMeta(
    'statusesCount',
  );
  @override
  late final GeneratedColumn<int> statusesCount = GeneratedColumn<int>(
    'statuses_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _mediaCountMeta = const VerificationMeta(
    'mediaCount',
  );
  @override
  late final GeneratedColumn<int> mediaCount = GeneratedColumn<int>(
    'media_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _favouritesCountMeta = const VerificationMeta(
    'favouritesCount',
  );
  @override
  late final GeneratedColumn<int> favouritesCount = GeneratedColumn<int>(
    'favourites_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _listedCountMeta = const VerificationMeta(
    'listedCount',
  );
  @override
  late final GeneratedColumn<int> listedCount = GeneratedColumn<int>(
    'listed_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _latestRawJsonMeta = const VerificationMeta(
    'latestRawJson',
  );
  @override
  late final GeneratedColumn<String> latestRawJson = GeneratedColumn<String>(
    'latest_raw_json',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarUrlMeta = const VerificationMeta(
    'avatarUrl',
  );
  @override
  late final GeneratedColumn<String> avatarUrl = GeneratedColumn<String>(
    'avatar_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bannerUrlMeta = const VerificationMeta(
    'bannerUrl',
  );
  @override
  late final GeneratedColumn<String> bannerUrl = GeneratedColumn<String>(
    'banner_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarLocalPathMeta = const VerificationMeta(
    'avatarLocalPath',
  );
  @override
  late final GeneratedColumn<String> avatarLocalPath = GeneratedColumn<String>(
    'avatar_local_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bannerLocalPathMeta = const VerificationMeta(
    'bannerLocalPath',
  );
  @override
  late final GeneratedColumn<String> bannerLocalPath = GeneratedColumn<String>(
    'banner_local_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    screenName,
    bio,
    location,
    link,
    joinTime,
    isVerified,
    isProtected,
    followersCount,
    followingCount,
    statusesCount,
    mediaCount,
    favouritesCount,
    listedCount,
    latestRawJson,
    avatarUrl,
    bannerUrl,
    avatarLocalPath,
    bannerLocalPath,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'logged_accounts';
  @override
  VerificationContext validateIntegrity(
    Insertable<LoggedAccount> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('screen_name')) {
      context.handle(
        _screenNameMeta,
        screenName.isAcceptableOrUnknown(data['screen_name']!, _screenNameMeta),
      );
    }
    if (data.containsKey('bio')) {
      context.handle(
        _bioMeta,
        bio.isAcceptableOrUnknown(data['bio']!, _bioMeta),
      );
    }
    if (data.containsKey('location')) {
      context.handle(
        _locationMeta,
        location.isAcceptableOrUnknown(data['location']!, _locationMeta),
      );
    }
    if (data.containsKey('link')) {
      context.handle(
        _linkMeta,
        link.isAcceptableOrUnknown(data['link']!, _linkMeta),
      );
    }
    if (data.containsKey('join_time')) {
      context.handle(
        _joinTimeMeta,
        joinTime.isAcceptableOrUnknown(data['join_time']!, _joinTimeMeta),
      );
    }
    if (data.containsKey('is_verified')) {
      context.handle(
        _isVerifiedMeta,
        isVerified.isAcceptableOrUnknown(data['is_verified']!, _isVerifiedMeta),
      );
    }
    if (data.containsKey('is_protected')) {
      context.handle(
        _isProtectedMeta,
        isProtected.isAcceptableOrUnknown(
          data['is_protected']!,
          _isProtectedMeta,
        ),
      );
    }
    if (data.containsKey('followers_count')) {
      context.handle(
        _followersCountMeta,
        followersCount.isAcceptableOrUnknown(
          data['followers_count']!,
          _followersCountMeta,
        ),
      );
    }
    if (data.containsKey('following_count')) {
      context.handle(
        _followingCountMeta,
        followingCount.isAcceptableOrUnknown(
          data['following_count']!,
          _followingCountMeta,
        ),
      );
    }
    if (data.containsKey('statuses_count')) {
      context.handle(
        _statusesCountMeta,
        statusesCount.isAcceptableOrUnknown(
          data['statuses_count']!,
          _statusesCountMeta,
        ),
      );
    }
    if (data.containsKey('media_count')) {
      context.handle(
        _mediaCountMeta,
        mediaCount.isAcceptableOrUnknown(data['media_count']!, _mediaCountMeta),
      );
    }
    if (data.containsKey('favourites_count')) {
      context.handle(
        _favouritesCountMeta,
        favouritesCount.isAcceptableOrUnknown(
          data['favourites_count']!,
          _favouritesCountMeta,
        ),
      );
    }
    if (data.containsKey('listed_count')) {
      context.handle(
        _listedCountMeta,
        listedCount.isAcceptableOrUnknown(
          data['listed_count']!,
          _listedCountMeta,
        ),
      );
    }
    if (data.containsKey('latest_raw_json')) {
      context.handle(
        _latestRawJsonMeta,
        latestRawJson.isAcceptableOrUnknown(
          data['latest_raw_json']!,
          _latestRawJsonMeta,
        ),
      );
    }
    if (data.containsKey('avatar_url')) {
      context.handle(
        _avatarUrlMeta,
        avatarUrl.isAcceptableOrUnknown(data['avatar_url']!, _avatarUrlMeta),
      );
    }
    if (data.containsKey('banner_url')) {
      context.handle(
        _bannerUrlMeta,
        bannerUrl.isAcceptableOrUnknown(data['banner_url']!, _bannerUrlMeta),
      );
    }
    if (data.containsKey('avatar_local_path')) {
      context.handle(
        _avatarLocalPathMeta,
        avatarLocalPath.isAcceptableOrUnknown(
          data['avatar_local_path']!,
          _avatarLocalPathMeta,
        ),
      );
    }
    if (data.containsKey('banner_local_path')) {
      context.handle(
        _bannerLocalPathMeta,
        bannerLocalPath.isAcceptableOrUnknown(
          data['banner_local_path']!,
          _bannerLocalPathMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  LoggedAccount map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LoggedAccount(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      screenName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}screen_name'],
      ),
      bio: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bio'],
      ),
      location: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location'],
      ),
      link: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}link'],
      ),
      joinTime: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}join_time'],
      ),
      isVerified: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_verified'],
      ),
      isProtected: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_protected'],
      ),
      followersCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}followers_count'],
      )!,
      followingCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}following_count'],
      )!,
      statusesCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}statuses_count'],
      )!,
      mediaCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}media_count'],
      )!,
      favouritesCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}favourites_count'],
      )!,
      listedCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}listed_count'],
      )!,
      latestRawJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}latest_raw_json'],
      ),
      avatarUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_url'],
      ),
      bannerUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}banner_url'],
      ),
      avatarLocalPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_local_path'],
      ),
      bannerLocalPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}banner_local_path'],
      ),
    );
  }

  @override
  $LoggedAccountsTable createAlias(String alias) {
    return $LoggedAccountsTable(attachedDatabase, alias);
  }
}

class LoggedAccount extends DataClass implements Insertable<LoggedAccount> {
  final String id;
  final String? name;
  final String? screenName;
  final String? bio;
  final String? location;
  final String? link;
  final String? joinTime;
  final bool? isVerified;
  final bool? isProtected;
  final int followersCount;
  final int followingCount;
  final int statusesCount;
  final int mediaCount;
  final int favouritesCount;
  final int listedCount;
  final String? latestRawJson;
  final String? avatarUrl;
  final String? bannerUrl;
  final String? avatarLocalPath;
  final String? bannerLocalPath;
  const LoggedAccount({
    required this.id,
    this.name,
    this.screenName,
    this.bio,
    this.location,
    this.link,
    this.joinTime,
    this.isVerified,
    this.isProtected,
    required this.followersCount,
    required this.followingCount,
    required this.statusesCount,
    required this.mediaCount,
    required this.favouritesCount,
    required this.listedCount,
    this.latestRawJson,
    this.avatarUrl,
    this.bannerUrl,
    this.avatarLocalPath,
    this.bannerLocalPath,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || screenName != null) {
      map['screen_name'] = Variable<String>(screenName);
    }
    if (!nullToAbsent || bio != null) {
      map['bio'] = Variable<String>(bio);
    }
    if (!nullToAbsent || location != null) {
      map['location'] = Variable<String>(location);
    }
    if (!nullToAbsent || link != null) {
      map['link'] = Variable<String>(link);
    }
    if (!nullToAbsent || joinTime != null) {
      map['join_time'] = Variable<String>(joinTime);
    }
    if (!nullToAbsent || isVerified != null) {
      map['is_verified'] = Variable<bool>(isVerified);
    }
    if (!nullToAbsent || isProtected != null) {
      map['is_protected'] = Variable<bool>(isProtected);
    }
    map['followers_count'] = Variable<int>(followersCount);
    map['following_count'] = Variable<int>(followingCount);
    map['statuses_count'] = Variable<int>(statusesCount);
    map['media_count'] = Variable<int>(mediaCount);
    map['favourites_count'] = Variable<int>(favouritesCount);
    map['listed_count'] = Variable<int>(listedCount);
    if (!nullToAbsent || latestRawJson != null) {
      map['latest_raw_json'] = Variable<String>(latestRawJson);
    }
    if (!nullToAbsent || avatarUrl != null) {
      map['avatar_url'] = Variable<String>(avatarUrl);
    }
    if (!nullToAbsent || bannerUrl != null) {
      map['banner_url'] = Variable<String>(bannerUrl);
    }
    if (!nullToAbsent || avatarLocalPath != null) {
      map['avatar_local_path'] = Variable<String>(avatarLocalPath);
    }
    if (!nullToAbsent || bannerLocalPath != null) {
      map['banner_local_path'] = Variable<String>(bannerLocalPath);
    }
    return map;
  }

  LoggedAccountsCompanion toCompanion(bool nullToAbsent) {
    return LoggedAccountsCompanion(
      id: Value(id),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      screenName: screenName == null && nullToAbsent
          ? const Value.absent()
          : Value(screenName),
      bio: bio == null && nullToAbsent ? const Value.absent() : Value(bio),
      location: location == null && nullToAbsent
          ? const Value.absent()
          : Value(location),
      link: link == null && nullToAbsent ? const Value.absent() : Value(link),
      joinTime: joinTime == null && nullToAbsent
          ? const Value.absent()
          : Value(joinTime),
      isVerified: isVerified == null && nullToAbsent
          ? const Value.absent()
          : Value(isVerified),
      isProtected: isProtected == null && nullToAbsent
          ? const Value.absent()
          : Value(isProtected),
      followersCount: Value(followersCount),
      followingCount: Value(followingCount),
      statusesCount: Value(statusesCount),
      mediaCount: Value(mediaCount),
      favouritesCount: Value(favouritesCount),
      listedCount: Value(listedCount),
      latestRawJson: latestRawJson == null && nullToAbsent
          ? const Value.absent()
          : Value(latestRawJson),
      avatarUrl: avatarUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarUrl),
      bannerUrl: bannerUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(bannerUrl),
      avatarLocalPath: avatarLocalPath == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarLocalPath),
      bannerLocalPath: bannerLocalPath == null && nullToAbsent
          ? const Value.absent()
          : Value(bannerLocalPath),
    );
  }

  factory LoggedAccount.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LoggedAccount(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String?>(json['name']),
      screenName: serializer.fromJson<String?>(json['screenName']),
      bio: serializer.fromJson<String?>(json['bio']),
      location: serializer.fromJson<String?>(json['location']),
      link: serializer.fromJson<String?>(json['link']),
      joinTime: serializer.fromJson<String?>(json['joinTime']),
      isVerified: serializer.fromJson<bool?>(json['isVerified']),
      isProtected: serializer.fromJson<bool?>(json['isProtected']),
      followersCount: serializer.fromJson<int>(json['followersCount']),
      followingCount: serializer.fromJson<int>(json['followingCount']),
      statusesCount: serializer.fromJson<int>(json['statusesCount']),
      mediaCount: serializer.fromJson<int>(json['mediaCount']),
      favouritesCount: serializer.fromJson<int>(json['favouritesCount']),
      listedCount: serializer.fromJson<int>(json['listedCount']),
      latestRawJson: serializer.fromJson<String?>(json['latestRawJson']),
      avatarUrl: serializer.fromJson<String?>(json['avatarUrl']),
      bannerUrl: serializer.fromJson<String?>(json['bannerUrl']),
      avatarLocalPath: serializer.fromJson<String?>(json['avatarLocalPath']),
      bannerLocalPath: serializer.fromJson<String?>(json['bannerLocalPath']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String?>(name),
      'screenName': serializer.toJson<String?>(screenName),
      'bio': serializer.toJson<String?>(bio),
      'location': serializer.toJson<String?>(location),
      'link': serializer.toJson<String?>(link),
      'joinTime': serializer.toJson<String?>(joinTime),
      'isVerified': serializer.toJson<bool?>(isVerified),
      'isProtected': serializer.toJson<bool?>(isProtected),
      'followersCount': serializer.toJson<int>(followersCount),
      'followingCount': serializer.toJson<int>(followingCount),
      'statusesCount': serializer.toJson<int>(statusesCount),
      'mediaCount': serializer.toJson<int>(mediaCount),
      'favouritesCount': serializer.toJson<int>(favouritesCount),
      'listedCount': serializer.toJson<int>(listedCount),
      'latestRawJson': serializer.toJson<String?>(latestRawJson),
      'avatarUrl': serializer.toJson<String?>(avatarUrl),
      'bannerUrl': serializer.toJson<String?>(bannerUrl),
      'avatarLocalPath': serializer.toJson<String?>(avatarLocalPath),
      'bannerLocalPath': serializer.toJson<String?>(bannerLocalPath),
    };
  }

  LoggedAccount copyWith({
    String? id,
    Value<String?> name = const Value.absent(),
    Value<String?> screenName = const Value.absent(),
    Value<String?> bio = const Value.absent(),
    Value<String?> location = const Value.absent(),
    Value<String?> link = const Value.absent(),
    Value<String?> joinTime = const Value.absent(),
    Value<bool?> isVerified = const Value.absent(),
    Value<bool?> isProtected = const Value.absent(),
    int? followersCount,
    int? followingCount,
    int? statusesCount,
    int? mediaCount,
    int? favouritesCount,
    int? listedCount,
    Value<String?> latestRawJson = const Value.absent(),
    Value<String?> avatarUrl = const Value.absent(),
    Value<String?> bannerUrl = const Value.absent(),
    Value<String?> avatarLocalPath = const Value.absent(),
    Value<String?> bannerLocalPath = const Value.absent(),
  }) => LoggedAccount(
    id: id ?? this.id,
    name: name.present ? name.value : this.name,
    screenName: screenName.present ? screenName.value : this.screenName,
    bio: bio.present ? bio.value : this.bio,
    location: location.present ? location.value : this.location,
    link: link.present ? link.value : this.link,
    joinTime: joinTime.present ? joinTime.value : this.joinTime,
    isVerified: isVerified.present ? isVerified.value : this.isVerified,
    isProtected: isProtected.present ? isProtected.value : this.isProtected,
    followersCount: followersCount ?? this.followersCount,
    followingCount: followingCount ?? this.followingCount,
    statusesCount: statusesCount ?? this.statusesCount,
    mediaCount: mediaCount ?? this.mediaCount,
    favouritesCount: favouritesCount ?? this.favouritesCount,
    listedCount: listedCount ?? this.listedCount,
    latestRawJson: latestRawJson.present
        ? latestRawJson.value
        : this.latestRawJson,
    avatarUrl: avatarUrl.present ? avatarUrl.value : this.avatarUrl,
    bannerUrl: bannerUrl.present ? bannerUrl.value : this.bannerUrl,
    avatarLocalPath: avatarLocalPath.present
        ? avatarLocalPath.value
        : this.avatarLocalPath,
    bannerLocalPath: bannerLocalPath.present
        ? bannerLocalPath.value
        : this.bannerLocalPath,
  );
  LoggedAccount copyWithCompanion(LoggedAccountsCompanion data) {
    return LoggedAccount(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      screenName: data.screenName.present
          ? data.screenName.value
          : this.screenName,
      bio: data.bio.present ? data.bio.value : this.bio,
      location: data.location.present ? data.location.value : this.location,
      link: data.link.present ? data.link.value : this.link,
      joinTime: data.joinTime.present ? data.joinTime.value : this.joinTime,
      isVerified: data.isVerified.present
          ? data.isVerified.value
          : this.isVerified,
      isProtected: data.isProtected.present
          ? data.isProtected.value
          : this.isProtected,
      followersCount: data.followersCount.present
          ? data.followersCount.value
          : this.followersCount,
      followingCount: data.followingCount.present
          ? data.followingCount.value
          : this.followingCount,
      statusesCount: data.statusesCount.present
          ? data.statusesCount.value
          : this.statusesCount,
      mediaCount: data.mediaCount.present
          ? data.mediaCount.value
          : this.mediaCount,
      favouritesCount: data.favouritesCount.present
          ? data.favouritesCount.value
          : this.favouritesCount,
      listedCount: data.listedCount.present
          ? data.listedCount.value
          : this.listedCount,
      latestRawJson: data.latestRawJson.present
          ? data.latestRawJson.value
          : this.latestRawJson,
      avatarUrl: data.avatarUrl.present ? data.avatarUrl.value : this.avatarUrl,
      bannerUrl: data.bannerUrl.present ? data.bannerUrl.value : this.bannerUrl,
      avatarLocalPath: data.avatarLocalPath.present
          ? data.avatarLocalPath.value
          : this.avatarLocalPath,
      bannerLocalPath: data.bannerLocalPath.present
          ? data.bannerLocalPath.value
          : this.bannerLocalPath,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LoggedAccount(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('screenName: $screenName, ')
          ..write('bio: $bio, ')
          ..write('location: $location, ')
          ..write('link: $link, ')
          ..write('joinTime: $joinTime, ')
          ..write('isVerified: $isVerified, ')
          ..write('isProtected: $isProtected, ')
          ..write('followersCount: $followersCount, ')
          ..write('followingCount: $followingCount, ')
          ..write('statusesCount: $statusesCount, ')
          ..write('mediaCount: $mediaCount, ')
          ..write('favouritesCount: $favouritesCount, ')
          ..write('listedCount: $listedCount, ')
          ..write('latestRawJson: $latestRawJson, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('bannerUrl: $bannerUrl, ')
          ..write('avatarLocalPath: $avatarLocalPath, ')
          ..write('bannerLocalPath: $bannerLocalPath')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    screenName,
    bio,
    location,
    link,
    joinTime,
    isVerified,
    isProtected,
    followersCount,
    followingCount,
    statusesCount,
    mediaCount,
    favouritesCount,
    listedCount,
    latestRawJson,
    avatarUrl,
    bannerUrl,
    avatarLocalPath,
    bannerLocalPath,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LoggedAccount &&
          other.id == this.id &&
          other.name == this.name &&
          other.screenName == this.screenName &&
          other.bio == this.bio &&
          other.location == this.location &&
          other.link == this.link &&
          other.joinTime == this.joinTime &&
          other.isVerified == this.isVerified &&
          other.isProtected == this.isProtected &&
          other.followersCount == this.followersCount &&
          other.followingCount == this.followingCount &&
          other.statusesCount == this.statusesCount &&
          other.mediaCount == this.mediaCount &&
          other.favouritesCount == this.favouritesCount &&
          other.listedCount == this.listedCount &&
          other.latestRawJson == this.latestRawJson &&
          other.avatarUrl == this.avatarUrl &&
          other.bannerUrl == this.bannerUrl &&
          other.avatarLocalPath == this.avatarLocalPath &&
          other.bannerLocalPath == this.bannerLocalPath);
}

class LoggedAccountsCompanion extends UpdateCompanion<LoggedAccount> {
  final Value<String> id;
  final Value<String?> name;
  final Value<String?> screenName;
  final Value<String?> bio;
  final Value<String?> location;
  final Value<String?> link;
  final Value<String?> joinTime;
  final Value<bool?> isVerified;
  final Value<bool?> isProtected;
  final Value<int> followersCount;
  final Value<int> followingCount;
  final Value<int> statusesCount;
  final Value<int> mediaCount;
  final Value<int> favouritesCount;
  final Value<int> listedCount;
  final Value<String?> latestRawJson;
  final Value<String?> avatarUrl;
  final Value<String?> bannerUrl;
  final Value<String?> avatarLocalPath;
  final Value<String?> bannerLocalPath;
  final Value<int> rowid;
  const LoggedAccountsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.screenName = const Value.absent(),
    this.bio = const Value.absent(),
    this.location = const Value.absent(),
    this.link = const Value.absent(),
    this.joinTime = const Value.absent(),
    this.isVerified = const Value.absent(),
    this.isProtected = const Value.absent(),
    this.followersCount = const Value.absent(),
    this.followingCount = const Value.absent(),
    this.statusesCount = const Value.absent(),
    this.mediaCount = const Value.absent(),
    this.favouritesCount = const Value.absent(),
    this.listedCount = const Value.absent(),
    this.latestRawJson = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.bannerUrl = const Value.absent(),
    this.avatarLocalPath = const Value.absent(),
    this.bannerLocalPath = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LoggedAccountsCompanion.insert({
    required String id,
    this.name = const Value.absent(),
    this.screenName = const Value.absent(),
    this.bio = const Value.absent(),
    this.location = const Value.absent(),
    this.link = const Value.absent(),
    this.joinTime = const Value.absent(),
    this.isVerified = const Value.absent(),
    this.isProtected = const Value.absent(),
    this.followersCount = const Value.absent(),
    this.followingCount = const Value.absent(),
    this.statusesCount = const Value.absent(),
    this.mediaCount = const Value.absent(),
    this.favouritesCount = const Value.absent(),
    this.listedCount = const Value.absent(),
    this.latestRawJson = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.bannerUrl = const Value.absent(),
    this.avatarLocalPath = const Value.absent(),
    this.bannerLocalPath = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<LoggedAccount> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? screenName,
    Expression<String>? bio,
    Expression<String>? location,
    Expression<String>? link,
    Expression<String>? joinTime,
    Expression<bool>? isVerified,
    Expression<bool>? isProtected,
    Expression<int>? followersCount,
    Expression<int>? followingCount,
    Expression<int>? statusesCount,
    Expression<int>? mediaCount,
    Expression<int>? favouritesCount,
    Expression<int>? listedCount,
    Expression<String>? latestRawJson,
    Expression<String>? avatarUrl,
    Expression<String>? bannerUrl,
    Expression<String>? avatarLocalPath,
    Expression<String>? bannerLocalPath,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (screenName != null) 'screen_name': screenName,
      if (bio != null) 'bio': bio,
      if (location != null) 'location': location,
      if (link != null) 'link': link,
      if (joinTime != null) 'join_time': joinTime,
      if (isVerified != null) 'is_verified': isVerified,
      if (isProtected != null) 'is_protected': isProtected,
      if (followersCount != null) 'followers_count': followersCount,
      if (followingCount != null) 'following_count': followingCount,
      if (statusesCount != null) 'statuses_count': statusesCount,
      if (mediaCount != null) 'media_count': mediaCount,
      if (favouritesCount != null) 'favourites_count': favouritesCount,
      if (listedCount != null) 'listed_count': listedCount,
      if (latestRawJson != null) 'latest_raw_json': latestRawJson,
      if (avatarUrl != null) 'avatar_url': avatarUrl,
      if (bannerUrl != null) 'banner_url': bannerUrl,
      if (avatarLocalPath != null) 'avatar_local_path': avatarLocalPath,
      if (bannerLocalPath != null) 'banner_local_path': bannerLocalPath,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LoggedAccountsCompanion copyWith({
    Value<String>? id,
    Value<String?>? name,
    Value<String?>? screenName,
    Value<String?>? bio,
    Value<String?>? location,
    Value<String?>? link,
    Value<String?>? joinTime,
    Value<bool?>? isVerified,
    Value<bool?>? isProtected,
    Value<int>? followersCount,
    Value<int>? followingCount,
    Value<int>? statusesCount,
    Value<int>? mediaCount,
    Value<int>? favouritesCount,
    Value<int>? listedCount,
    Value<String?>? latestRawJson,
    Value<String?>? avatarUrl,
    Value<String?>? bannerUrl,
    Value<String?>? avatarLocalPath,
    Value<String?>? bannerLocalPath,
    Value<int>? rowid,
  }) {
    return LoggedAccountsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      screenName: screenName ?? this.screenName,
      bio: bio ?? this.bio,
      location: location ?? this.location,
      link: link ?? this.link,
      joinTime: joinTime ?? this.joinTime,
      isVerified: isVerified ?? this.isVerified,
      isProtected: isProtected ?? this.isProtected,
      followersCount: followersCount ?? this.followersCount,
      followingCount: followingCount ?? this.followingCount,
      statusesCount: statusesCount ?? this.statusesCount,
      mediaCount: mediaCount ?? this.mediaCount,
      favouritesCount: favouritesCount ?? this.favouritesCount,
      listedCount: listedCount ?? this.listedCount,
      latestRawJson: latestRawJson ?? this.latestRawJson,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      bannerUrl: bannerUrl ?? this.bannerUrl,
      avatarLocalPath: avatarLocalPath ?? this.avatarLocalPath,
      bannerLocalPath: bannerLocalPath ?? this.bannerLocalPath,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (screenName.present) {
      map['screen_name'] = Variable<String>(screenName.value);
    }
    if (bio.present) {
      map['bio'] = Variable<String>(bio.value);
    }
    if (location.present) {
      map['location'] = Variable<String>(location.value);
    }
    if (link.present) {
      map['link'] = Variable<String>(link.value);
    }
    if (joinTime.present) {
      map['join_time'] = Variable<String>(joinTime.value);
    }
    if (isVerified.present) {
      map['is_verified'] = Variable<bool>(isVerified.value);
    }
    if (isProtected.present) {
      map['is_protected'] = Variable<bool>(isProtected.value);
    }
    if (followersCount.present) {
      map['followers_count'] = Variable<int>(followersCount.value);
    }
    if (followingCount.present) {
      map['following_count'] = Variable<int>(followingCount.value);
    }
    if (statusesCount.present) {
      map['statuses_count'] = Variable<int>(statusesCount.value);
    }
    if (mediaCount.present) {
      map['media_count'] = Variable<int>(mediaCount.value);
    }
    if (favouritesCount.present) {
      map['favourites_count'] = Variable<int>(favouritesCount.value);
    }
    if (listedCount.present) {
      map['listed_count'] = Variable<int>(listedCount.value);
    }
    if (latestRawJson.present) {
      map['latest_raw_json'] = Variable<String>(latestRawJson.value);
    }
    if (avatarUrl.present) {
      map['avatar_url'] = Variable<String>(avatarUrl.value);
    }
    if (bannerUrl.present) {
      map['banner_url'] = Variable<String>(bannerUrl.value);
    }
    if (avatarLocalPath.present) {
      map['avatar_local_path'] = Variable<String>(avatarLocalPath.value);
    }
    if (bannerLocalPath.present) {
      map['banner_local_path'] = Variable<String>(bannerLocalPath.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LoggedAccountsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('screenName: $screenName, ')
          ..write('bio: $bio, ')
          ..write('location: $location, ')
          ..write('link: $link, ')
          ..write('joinTime: $joinTime, ')
          ..write('isVerified: $isVerified, ')
          ..write('isProtected: $isProtected, ')
          ..write('followersCount: $followersCount, ')
          ..write('followingCount: $followingCount, ')
          ..write('statusesCount: $statusesCount, ')
          ..write('mediaCount: $mediaCount, ')
          ..write('favouritesCount: $favouritesCount, ')
          ..write('listedCount: $listedCount, ')
          ..write('latestRawJson: $latestRawJson, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('bannerUrl: $bannerUrl, ')
          ..write('avatarLocalPath: $avatarLocalPath, ')
          ..write('bannerLocalPath: $bannerLocalPath, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AccountProfileHistoryTable extends AccountProfileHistory
    with TableInfo<$AccountProfileHistoryTable, AccountProfileHistoryEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AccountProfileHistoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES logged_accounts (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _reverseDiffJsonMeta = const VerificationMeta(
    'reverseDiffJson',
  );
  @override
  late final GeneratedColumn<String> reverseDiffJson = GeneratedColumn<String>(
    'reverse_diff_json',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    ownerId,
    reverseDiffJson,
    timestamp,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'account_profile_history';
  @override
  VerificationContext validateIntegrity(
    Insertable<AccountProfileHistoryEntry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('reverse_diff_json')) {
      context.handle(
        _reverseDiffJsonMeta,
        reverseDiffJson.isAcceptableOrUnknown(
          data['reverse_diff_json']!,
          _reverseDiffJsonMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_reverseDiffJsonMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AccountProfileHistoryEntry map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AccountProfileHistoryEntry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      reverseDiffJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reverse_diff_json'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
    );
  }

  @override
  $AccountProfileHistoryTable createAlias(String alias) {
    return $AccountProfileHistoryTable(attachedDatabase, alias);
  }
}

class AccountProfileHistoryEntry extends DataClass
    implements Insertable<AccountProfileHistoryEntry> {
  final int id;
  final String ownerId;
  final String reverseDiffJson;
  final DateTime timestamp;
  const AccountProfileHistoryEntry({
    required this.id,
    required this.ownerId,
    required this.reverseDiffJson,
    required this.timestamp,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['owner_id'] = Variable<String>(ownerId);
    map['reverse_diff_json'] = Variable<String>(reverseDiffJson);
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  AccountProfileHistoryCompanion toCompanion(bool nullToAbsent) {
    return AccountProfileHistoryCompanion(
      id: Value(id),
      ownerId: Value(ownerId),
      reverseDiffJson: Value(reverseDiffJson),
      timestamp: Value(timestamp),
    );
  }

  factory AccountProfileHistoryEntry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccountProfileHistoryEntry(
      id: serializer.fromJson<int>(json['id']),
      ownerId: serializer.fromJson<String>(json['ownerId']),
      reverseDiffJson: serializer.fromJson<String>(json['reverseDiffJson']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ownerId': serializer.toJson<String>(ownerId),
      'reverseDiffJson': serializer.toJson<String>(reverseDiffJson),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  AccountProfileHistoryEntry copyWith({
    int? id,
    String? ownerId,
    String? reverseDiffJson,
    DateTime? timestamp,
  }) => AccountProfileHistoryEntry(
    id: id ?? this.id,
    ownerId: ownerId ?? this.ownerId,
    reverseDiffJson: reverseDiffJson ?? this.reverseDiffJson,
    timestamp: timestamp ?? this.timestamp,
  );
  AccountProfileHistoryEntry copyWithCompanion(
    AccountProfileHistoryCompanion data,
  ) {
    return AccountProfileHistoryEntry(
      id: data.id.present ? data.id.value : this.id,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      reverseDiffJson: data.reverseDiffJson.present
          ? data.reverseDiffJson.value
          : this.reverseDiffJson,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AccountProfileHistoryEntry(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('reverseDiffJson: $reverseDiffJson, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, ownerId, reverseDiffJson, timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccountProfileHistoryEntry &&
          other.id == this.id &&
          other.ownerId == this.ownerId &&
          other.reverseDiffJson == this.reverseDiffJson &&
          other.timestamp == this.timestamp);
}

class AccountProfileHistoryCompanion
    extends UpdateCompanion<AccountProfileHistoryEntry> {
  final Value<int> id;
  final Value<String> ownerId;
  final Value<String> reverseDiffJson;
  final Value<DateTime> timestamp;
  const AccountProfileHistoryCompanion({
    this.id = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.reverseDiffJson = const Value.absent(),
    this.timestamp = const Value.absent(),
  });
  AccountProfileHistoryCompanion.insert({
    this.id = const Value.absent(),
    required String ownerId,
    required String reverseDiffJson,
    required DateTime timestamp,
  }) : ownerId = Value(ownerId),
       reverseDiffJson = Value(reverseDiffJson),
       timestamp = Value(timestamp);
  static Insertable<AccountProfileHistoryEntry> custom({
    Expression<int>? id,
    Expression<String>? ownerId,
    Expression<String>? reverseDiffJson,
    Expression<DateTime>? timestamp,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (ownerId != null) 'owner_id': ownerId,
      if (reverseDiffJson != null) 'reverse_diff_json': reverseDiffJson,
      if (timestamp != null) 'timestamp': timestamp,
    });
  }

  AccountProfileHistoryCompanion copyWith({
    Value<int>? id,
    Value<String>? ownerId,
    Value<String>? reverseDiffJson,
    Value<DateTime>? timestamp,
  }) {
    return AccountProfileHistoryCompanion(
      id: id ?? this.id,
      ownerId: ownerId ?? this.ownerId,
      reverseDiffJson: reverseDiffJson ?? this.reverseDiffJson,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (reverseDiffJson.present) {
      map['reverse_diff_json'] = Variable<String>(reverseDiffJson.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccountProfileHistoryCompanion(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('reverseDiffJson: $reverseDiffJson, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }
}

class $FollowUsersTable extends FollowUsers
    with TableInfo<$FollowUsersTable, FollowUser> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FollowUsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES logged_accounts (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _latestRawJsonMeta = const VerificationMeta(
    'latestRawJson',
  );
  @override
  late final GeneratedColumn<String> latestRawJson = GeneratedColumn<String>(
    'latest_raw_json',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _screenNameMeta = const VerificationMeta(
    'screenName',
  );
  @override
  late final GeneratedColumn<String> screenName = GeneratedColumn<String>(
    'screen_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarUrlMeta = const VerificationMeta(
    'avatarUrl',
  );
  @override
  late final GeneratedColumn<String> avatarUrl = GeneratedColumn<String>(
    'avatar_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bannerUrlMeta = const VerificationMeta(
    'bannerUrl',
  );
  @override
  late final GeneratedColumn<String> bannerUrl = GeneratedColumn<String>(
    'banner_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bioMeta = const VerificationMeta('bio');
  @override
  late final GeneratedColumn<String> bio = GeneratedColumn<String>(
    'bio',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarLocalPathMeta = const VerificationMeta(
    'avatarLocalPath',
  );
  @override
  late final GeneratedColumn<String> avatarLocalPath = GeneratedColumn<String>(
    'avatar_local_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bannerLocalPathMeta = const VerificationMeta(
    'bannerLocalPath',
  );
  @override
  late final GeneratedColumn<String> bannerLocalPath = GeneratedColumn<String>(
    'banner_local_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isFollowerMeta = const VerificationMeta(
    'isFollower',
  );
  @override
  late final GeneratedColumn<bool> isFollower = GeneratedColumn<bool>(
    'is_follower',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_follower" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isFollowingMeta = const VerificationMeta(
    'isFollowing',
  );
  @override
  late final GeneratedColumn<bool> isFollowing = GeneratedColumn<bool>(
    'is_following',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_following" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    ownerId,
    userId,
    latestRawJson,
    name,
    screenName,
    avatarUrl,
    bannerUrl,
    bio,
    avatarLocalPath,
    bannerLocalPath,
    isFollower,
    isFollowing,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'follow_users';
  @override
  VerificationContext validateIntegrity(
    Insertable<FollowUser> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('latest_raw_json')) {
      context.handle(
        _latestRawJsonMeta,
        latestRawJson.isAcceptableOrUnknown(
          data['latest_raw_json']!,
          _latestRawJsonMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('screen_name')) {
      context.handle(
        _screenNameMeta,
        screenName.isAcceptableOrUnknown(data['screen_name']!, _screenNameMeta),
      );
    }
    if (data.containsKey('avatar_url')) {
      context.handle(
        _avatarUrlMeta,
        avatarUrl.isAcceptableOrUnknown(data['avatar_url']!, _avatarUrlMeta),
      );
    }
    if (data.containsKey('banner_url')) {
      context.handle(
        _bannerUrlMeta,
        bannerUrl.isAcceptableOrUnknown(data['banner_url']!, _bannerUrlMeta),
      );
    }
    if (data.containsKey('bio')) {
      context.handle(
        _bioMeta,
        bio.isAcceptableOrUnknown(data['bio']!, _bioMeta),
      );
    }
    if (data.containsKey('avatar_local_path')) {
      context.handle(
        _avatarLocalPathMeta,
        avatarLocalPath.isAcceptableOrUnknown(
          data['avatar_local_path']!,
          _avatarLocalPathMeta,
        ),
      );
    }
    if (data.containsKey('banner_local_path')) {
      context.handle(
        _bannerLocalPathMeta,
        bannerLocalPath.isAcceptableOrUnknown(
          data['banner_local_path']!,
          _bannerLocalPathMeta,
        ),
      );
    }
    if (data.containsKey('is_follower')) {
      context.handle(
        _isFollowerMeta,
        isFollower.isAcceptableOrUnknown(data['is_follower']!, _isFollowerMeta),
      );
    }
    if (data.containsKey('is_following')) {
      context.handle(
        _isFollowingMeta,
        isFollowing.isAcceptableOrUnknown(
          data['is_following']!,
          _isFollowingMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ownerId, userId};
  @override
  FollowUser map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FollowUser(
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      latestRawJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}latest_raw_json'],
      ),
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      screenName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}screen_name'],
      ),
      avatarUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_url'],
      ),
      bannerUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}banner_url'],
      ),
      bio: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bio'],
      ),
      avatarLocalPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_local_path'],
      ),
      bannerLocalPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}banner_local_path'],
      ),
      isFollower: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_follower'],
      )!,
      isFollowing: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_following'],
      )!,
    );
  }

  @override
  $FollowUsersTable createAlias(String alias) {
    return $FollowUsersTable(attachedDatabase, alias);
  }
}

class FollowUser extends DataClass implements Insertable<FollowUser> {
  final String ownerId;
  final String userId;
  final String? latestRawJson;
  final String? name;
  final String? screenName;
  final String? avatarUrl;
  final String? bannerUrl;
  final String? bio;
  final String? avatarLocalPath;
  final String? bannerLocalPath;
  final bool isFollower;
  final bool isFollowing;
  const FollowUser({
    required this.ownerId,
    required this.userId,
    this.latestRawJson,
    this.name,
    this.screenName,
    this.avatarUrl,
    this.bannerUrl,
    this.bio,
    this.avatarLocalPath,
    this.bannerLocalPath,
    required this.isFollower,
    required this.isFollowing,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['owner_id'] = Variable<String>(ownerId);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || latestRawJson != null) {
      map['latest_raw_json'] = Variable<String>(latestRawJson);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || screenName != null) {
      map['screen_name'] = Variable<String>(screenName);
    }
    if (!nullToAbsent || avatarUrl != null) {
      map['avatar_url'] = Variable<String>(avatarUrl);
    }
    if (!nullToAbsent || bannerUrl != null) {
      map['banner_url'] = Variable<String>(bannerUrl);
    }
    if (!nullToAbsent || bio != null) {
      map['bio'] = Variable<String>(bio);
    }
    if (!nullToAbsent || avatarLocalPath != null) {
      map['avatar_local_path'] = Variable<String>(avatarLocalPath);
    }
    if (!nullToAbsent || bannerLocalPath != null) {
      map['banner_local_path'] = Variable<String>(bannerLocalPath);
    }
    map['is_follower'] = Variable<bool>(isFollower);
    map['is_following'] = Variable<bool>(isFollowing);
    return map;
  }

  FollowUsersCompanion toCompanion(bool nullToAbsent) {
    return FollowUsersCompanion(
      ownerId: Value(ownerId),
      userId: Value(userId),
      latestRawJson: latestRawJson == null && nullToAbsent
          ? const Value.absent()
          : Value(latestRawJson),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      screenName: screenName == null && nullToAbsent
          ? const Value.absent()
          : Value(screenName),
      avatarUrl: avatarUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarUrl),
      bannerUrl: bannerUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(bannerUrl),
      bio: bio == null && nullToAbsent ? const Value.absent() : Value(bio),
      avatarLocalPath: avatarLocalPath == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarLocalPath),
      bannerLocalPath: bannerLocalPath == null && nullToAbsent
          ? const Value.absent()
          : Value(bannerLocalPath),
      isFollower: Value(isFollower),
      isFollowing: Value(isFollowing),
    );
  }

  factory FollowUser.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FollowUser(
      ownerId: serializer.fromJson<String>(json['ownerId']),
      userId: serializer.fromJson<String>(json['userId']),
      latestRawJson: serializer.fromJson<String?>(json['latestRawJson']),
      name: serializer.fromJson<String?>(json['name']),
      screenName: serializer.fromJson<String?>(json['screenName']),
      avatarUrl: serializer.fromJson<String?>(json['avatarUrl']),
      bannerUrl: serializer.fromJson<String?>(json['bannerUrl']),
      bio: serializer.fromJson<String?>(json['bio']),
      avatarLocalPath: serializer.fromJson<String?>(json['avatarLocalPath']),
      bannerLocalPath: serializer.fromJson<String?>(json['bannerLocalPath']),
      isFollower: serializer.fromJson<bool>(json['isFollower']),
      isFollowing: serializer.fromJson<bool>(json['isFollowing']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ownerId': serializer.toJson<String>(ownerId),
      'userId': serializer.toJson<String>(userId),
      'latestRawJson': serializer.toJson<String?>(latestRawJson),
      'name': serializer.toJson<String?>(name),
      'screenName': serializer.toJson<String?>(screenName),
      'avatarUrl': serializer.toJson<String?>(avatarUrl),
      'bannerUrl': serializer.toJson<String?>(bannerUrl),
      'bio': serializer.toJson<String?>(bio),
      'avatarLocalPath': serializer.toJson<String?>(avatarLocalPath),
      'bannerLocalPath': serializer.toJson<String?>(bannerLocalPath),
      'isFollower': serializer.toJson<bool>(isFollower),
      'isFollowing': serializer.toJson<bool>(isFollowing),
    };
  }

  FollowUser copyWith({
    String? ownerId,
    String? userId,
    Value<String?> latestRawJson = const Value.absent(),
    Value<String?> name = const Value.absent(),
    Value<String?> screenName = const Value.absent(),
    Value<String?> avatarUrl = const Value.absent(),
    Value<String?> bannerUrl = const Value.absent(),
    Value<String?> bio = const Value.absent(),
    Value<String?> avatarLocalPath = const Value.absent(),
    Value<String?> bannerLocalPath = const Value.absent(),
    bool? isFollower,
    bool? isFollowing,
  }) => FollowUser(
    ownerId: ownerId ?? this.ownerId,
    userId: userId ?? this.userId,
    latestRawJson: latestRawJson.present
        ? latestRawJson.value
        : this.latestRawJson,
    name: name.present ? name.value : this.name,
    screenName: screenName.present ? screenName.value : this.screenName,
    avatarUrl: avatarUrl.present ? avatarUrl.value : this.avatarUrl,
    bannerUrl: bannerUrl.present ? bannerUrl.value : this.bannerUrl,
    bio: bio.present ? bio.value : this.bio,
    avatarLocalPath: avatarLocalPath.present
        ? avatarLocalPath.value
        : this.avatarLocalPath,
    bannerLocalPath: bannerLocalPath.present
        ? bannerLocalPath.value
        : this.bannerLocalPath,
    isFollower: isFollower ?? this.isFollower,
    isFollowing: isFollowing ?? this.isFollowing,
  );
  FollowUser copyWithCompanion(FollowUsersCompanion data) {
    return FollowUser(
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      userId: data.userId.present ? data.userId.value : this.userId,
      latestRawJson: data.latestRawJson.present
          ? data.latestRawJson.value
          : this.latestRawJson,
      name: data.name.present ? data.name.value : this.name,
      screenName: data.screenName.present
          ? data.screenName.value
          : this.screenName,
      avatarUrl: data.avatarUrl.present ? data.avatarUrl.value : this.avatarUrl,
      bannerUrl: data.bannerUrl.present ? data.bannerUrl.value : this.bannerUrl,
      bio: data.bio.present ? data.bio.value : this.bio,
      avatarLocalPath: data.avatarLocalPath.present
          ? data.avatarLocalPath.value
          : this.avatarLocalPath,
      bannerLocalPath: data.bannerLocalPath.present
          ? data.bannerLocalPath.value
          : this.bannerLocalPath,
      isFollower: data.isFollower.present
          ? data.isFollower.value
          : this.isFollower,
      isFollowing: data.isFollowing.present
          ? data.isFollowing.value
          : this.isFollowing,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FollowUser(')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('latestRawJson: $latestRawJson, ')
          ..write('name: $name, ')
          ..write('screenName: $screenName, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('bannerUrl: $bannerUrl, ')
          ..write('bio: $bio, ')
          ..write('avatarLocalPath: $avatarLocalPath, ')
          ..write('bannerLocalPath: $bannerLocalPath, ')
          ..write('isFollower: $isFollower, ')
          ..write('isFollowing: $isFollowing')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    ownerId,
    userId,
    latestRawJson,
    name,
    screenName,
    avatarUrl,
    bannerUrl,
    bio,
    avatarLocalPath,
    bannerLocalPath,
    isFollower,
    isFollowing,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FollowUser &&
          other.ownerId == this.ownerId &&
          other.userId == this.userId &&
          other.latestRawJson == this.latestRawJson &&
          other.name == this.name &&
          other.screenName == this.screenName &&
          other.avatarUrl == this.avatarUrl &&
          other.bannerUrl == this.bannerUrl &&
          other.bio == this.bio &&
          other.avatarLocalPath == this.avatarLocalPath &&
          other.bannerLocalPath == this.bannerLocalPath &&
          other.isFollower == this.isFollower &&
          other.isFollowing == this.isFollowing);
}

class FollowUsersCompanion extends UpdateCompanion<FollowUser> {
  final Value<String> ownerId;
  final Value<String> userId;
  final Value<String?> latestRawJson;
  final Value<String?> name;
  final Value<String?> screenName;
  final Value<String?> avatarUrl;
  final Value<String?> bannerUrl;
  final Value<String?> bio;
  final Value<String?> avatarLocalPath;
  final Value<String?> bannerLocalPath;
  final Value<bool> isFollower;
  final Value<bool> isFollowing;
  final Value<int> rowid;
  const FollowUsersCompanion({
    this.ownerId = const Value.absent(),
    this.userId = const Value.absent(),
    this.latestRawJson = const Value.absent(),
    this.name = const Value.absent(),
    this.screenName = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.bannerUrl = const Value.absent(),
    this.bio = const Value.absent(),
    this.avatarLocalPath = const Value.absent(),
    this.bannerLocalPath = const Value.absent(),
    this.isFollower = const Value.absent(),
    this.isFollowing = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FollowUsersCompanion.insert({
    required String ownerId,
    required String userId,
    this.latestRawJson = const Value.absent(),
    this.name = const Value.absent(),
    this.screenName = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.bannerUrl = const Value.absent(),
    this.bio = const Value.absent(),
    this.avatarLocalPath = const Value.absent(),
    this.bannerLocalPath = const Value.absent(),
    this.isFollower = const Value.absent(),
    this.isFollowing = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ownerId = Value(ownerId),
       userId = Value(userId);
  static Insertable<FollowUser> custom({
    Expression<String>? ownerId,
    Expression<String>? userId,
    Expression<String>? latestRawJson,
    Expression<String>? name,
    Expression<String>? screenName,
    Expression<String>? avatarUrl,
    Expression<String>? bannerUrl,
    Expression<String>? bio,
    Expression<String>? avatarLocalPath,
    Expression<String>? bannerLocalPath,
    Expression<bool>? isFollower,
    Expression<bool>? isFollowing,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ownerId != null) 'owner_id': ownerId,
      if (userId != null) 'user_id': userId,
      if (latestRawJson != null) 'latest_raw_json': latestRawJson,
      if (name != null) 'name': name,
      if (screenName != null) 'screen_name': screenName,
      if (avatarUrl != null) 'avatar_url': avatarUrl,
      if (bannerUrl != null) 'banner_url': bannerUrl,
      if (bio != null) 'bio': bio,
      if (avatarLocalPath != null) 'avatar_local_path': avatarLocalPath,
      if (bannerLocalPath != null) 'banner_local_path': bannerLocalPath,
      if (isFollower != null) 'is_follower': isFollower,
      if (isFollowing != null) 'is_following': isFollowing,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FollowUsersCompanion copyWith({
    Value<String>? ownerId,
    Value<String>? userId,
    Value<String?>? latestRawJson,
    Value<String?>? name,
    Value<String?>? screenName,
    Value<String?>? avatarUrl,
    Value<String?>? bannerUrl,
    Value<String?>? bio,
    Value<String?>? avatarLocalPath,
    Value<String?>? bannerLocalPath,
    Value<bool>? isFollower,
    Value<bool>? isFollowing,
    Value<int>? rowid,
  }) {
    return FollowUsersCompanion(
      ownerId: ownerId ?? this.ownerId,
      userId: userId ?? this.userId,
      latestRawJson: latestRawJson ?? this.latestRawJson,
      name: name ?? this.name,
      screenName: screenName ?? this.screenName,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      bannerUrl: bannerUrl ?? this.bannerUrl,
      bio: bio ?? this.bio,
      avatarLocalPath: avatarLocalPath ?? this.avatarLocalPath,
      bannerLocalPath: bannerLocalPath ?? this.bannerLocalPath,
      isFollower: isFollower ?? this.isFollower,
      isFollowing: isFollowing ?? this.isFollowing,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (latestRawJson.present) {
      map['latest_raw_json'] = Variable<String>(latestRawJson.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (screenName.present) {
      map['screen_name'] = Variable<String>(screenName.value);
    }
    if (avatarUrl.present) {
      map['avatar_url'] = Variable<String>(avatarUrl.value);
    }
    if (bannerUrl.present) {
      map['banner_url'] = Variable<String>(bannerUrl.value);
    }
    if (bio.present) {
      map['bio'] = Variable<String>(bio.value);
    }
    if (avatarLocalPath.present) {
      map['avatar_local_path'] = Variable<String>(avatarLocalPath.value);
    }
    if (bannerLocalPath.present) {
      map['banner_local_path'] = Variable<String>(bannerLocalPath.value);
    }
    if (isFollower.present) {
      map['is_follower'] = Variable<bool>(isFollower.value);
    }
    if (isFollowing.present) {
      map['is_following'] = Variable<bool>(isFollowing.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FollowUsersCompanion(')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('latestRawJson: $latestRawJson, ')
          ..write('name: $name, ')
          ..write('screenName: $screenName, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('bannerUrl: $bannerUrl, ')
          ..write('bio: $bio, ')
          ..write('avatarLocalPath: $avatarLocalPath, ')
          ..write('bannerLocalPath: $bannerLocalPath, ')
          ..write('isFollower: $isFollower, ')
          ..write('isFollowing: $isFollowing, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FollowUsersHistoryTable extends FollowUsersHistory
    with TableInfo<$FollowUsersHistoryTable, FollowUserHistoryEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FollowUsersHistoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _reverseDiffJsonMeta = const VerificationMeta(
    'reverseDiffJson',
  );
  @override
  late final GeneratedColumn<String> reverseDiffJson = GeneratedColumn<String>(
    'reverse_diff_json',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    ownerId,
    userId,
    reverseDiffJson,
    timestamp,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'follow_users_history';
  @override
  VerificationContext validateIntegrity(
    Insertable<FollowUserHistoryEntry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('reverse_diff_json')) {
      context.handle(
        _reverseDiffJsonMeta,
        reverseDiffJson.isAcceptableOrUnknown(
          data['reverse_diff_json']!,
          _reverseDiffJsonMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_reverseDiffJsonMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FollowUserHistoryEntry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FollowUserHistoryEntry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      reverseDiffJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reverse_diff_json'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
    );
  }

  @override
  $FollowUsersHistoryTable createAlias(String alias) {
    return $FollowUsersHistoryTable(attachedDatabase, alias);
  }
}

class FollowUserHistoryEntry extends DataClass
    implements Insertable<FollowUserHistoryEntry> {
  final int id;
  final String ownerId;
  final String userId;
  final String reverseDiffJson;
  final DateTime timestamp;
  const FollowUserHistoryEntry({
    required this.id,
    required this.ownerId,
    required this.userId,
    required this.reverseDiffJson,
    required this.timestamp,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['owner_id'] = Variable<String>(ownerId);
    map['user_id'] = Variable<String>(userId);
    map['reverse_diff_json'] = Variable<String>(reverseDiffJson);
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  FollowUsersHistoryCompanion toCompanion(bool nullToAbsent) {
    return FollowUsersHistoryCompanion(
      id: Value(id),
      ownerId: Value(ownerId),
      userId: Value(userId),
      reverseDiffJson: Value(reverseDiffJson),
      timestamp: Value(timestamp),
    );
  }

  factory FollowUserHistoryEntry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FollowUserHistoryEntry(
      id: serializer.fromJson<int>(json['id']),
      ownerId: serializer.fromJson<String>(json['ownerId']),
      userId: serializer.fromJson<String>(json['userId']),
      reverseDiffJson: serializer.fromJson<String>(json['reverseDiffJson']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ownerId': serializer.toJson<String>(ownerId),
      'userId': serializer.toJson<String>(userId),
      'reverseDiffJson': serializer.toJson<String>(reverseDiffJson),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  FollowUserHistoryEntry copyWith({
    int? id,
    String? ownerId,
    String? userId,
    String? reverseDiffJson,
    DateTime? timestamp,
  }) => FollowUserHistoryEntry(
    id: id ?? this.id,
    ownerId: ownerId ?? this.ownerId,
    userId: userId ?? this.userId,
    reverseDiffJson: reverseDiffJson ?? this.reverseDiffJson,
    timestamp: timestamp ?? this.timestamp,
  );
  FollowUserHistoryEntry copyWithCompanion(FollowUsersHistoryCompanion data) {
    return FollowUserHistoryEntry(
      id: data.id.present ? data.id.value : this.id,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      userId: data.userId.present ? data.userId.value : this.userId,
      reverseDiffJson: data.reverseDiffJson.present
          ? data.reverseDiffJson.value
          : this.reverseDiffJson,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FollowUserHistoryEntry(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('reverseDiffJson: $reverseDiffJson, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, ownerId, userId, reverseDiffJson, timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FollowUserHistoryEntry &&
          other.id == this.id &&
          other.ownerId == this.ownerId &&
          other.userId == this.userId &&
          other.reverseDiffJson == this.reverseDiffJson &&
          other.timestamp == this.timestamp);
}

class FollowUsersHistoryCompanion
    extends UpdateCompanion<FollowUserHistoryEntry> {
  final Value<int> id;
  final Value<String> ownerId;
  final Value<String> userId;
  final Value<String> reverseDiffJson;
  final Value<DateTime> timestamp;
  const FollowUsersHistoryCompanion({
    this.id = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.userId = const Value.absent(),
    this.reverseDiffJson = const Value.absent(),
    this.timestamp = const Value.absent(),
  });
  FollowUsersHistoryCompanion.insert({
    this.id = const Value.absent(),
    required String ownerId,
    required String userId,
    required String reverseDiffJson,
    required DateTime timestamp,
  }) : ownerId = Value(ownerId),
       userId = Value(userId),
       reverseDiffJson = Value(reverseDiffJson),
       timestamp = Value(timestamp);
  static Insertable<FollowUserHistoryEntry> custom({
    Expression<int>? id,
    Expression<String>? ownerId,
    Expression<String>? userId,
    Expression<String>? reverseDiffJson,
    Expression<DateTime>? timestamp,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (ownerId != null) 'owner_id': ownerId,
      if (userId != null) 'user_id': userId,
      if (reverseDiffJson != null) 'reverse_diff_json': reverseDiffJson,
      if (timestamp != null) 'timestamp': timestamp,
    });
  }

  FollowUsersHistoryCompanion copyWith({
    Value<int>? id,
    Value<String>? ownerId,
    Value<String>? userId,
    Value<String>? reverseDiffJson,
    Value<DateTime>? timestamp,
  }) {
    return FollowUsersHistoryCompanion(
      id: id ?? this.id,
      ownerId: ownerId ?? this.ownerId,
      userId: userId ?? this.userId,
      reverseDiffJson: reverseDiffJson ?? this.reverseDiffJson,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (reverseDiffJson.present) {
      map['reverse_diff_json'] = Variable<String>(reverseDiffJson.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FollowUsersHistoryCompanion(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('reverseDiffJson: $reverseDiffJson, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }
}

class $ChangeReportsTable extends ChangeReports
    with TableInfo<$ChangeReportsTable, ChangeReportEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ChangeReportsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES logged_accounts (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _changeTypeMeta = const VerificationMeta(
    'changeType',
  );
  @override
  late final GeneratedColumn<String> changeType = GeneratedColumn<String>(
    'change_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userSnapshotJsonMeta = const VerificationMeta(
    'userSnapshotJson',
  );
  @override
  late final GeneratedColumn<String> userSnapshotJson = GeneratedColumn<String>(
    'user_snapshot_json',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    ownerId,
    userId,
    changeType,
    timestamp,
    userSnapshotJson,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'change_reports';
  @override
  VerificationContext validateIntegrity(
    Insertable<ChangeReportEntry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('change_type')) {
      context.handle(
        _changeTypeMeta,
        changeType.isAcceptableOrUnknown(data['change_type']!, _changeTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_changeTypeMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('user_snapshot_json')) {
      context.handle(
        _userSnapshotJsonMeta,
        userSnapshotJson.isAcceptableOrUnknown(
          data['user_snapshot_json']!,
          _userSnapshotJsonMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ChangeReportEntry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ChangeReportEntry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      changeType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}change_type'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
      userSnapshotJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_snapshot_json'],
      ),
    );
  }

  @override
  $ChangeReportsTable createAlias(String alias) {
    return $ChangeReportsTable(attachedDatabase, alias);
  }
}

class ChangeReportEntry extends DataClass
    implements Insertable<ChangeReportEntry> {
  final int id;
  final String ownerId;
  final String userId;
  final String changeType;
  final DateTime timestamp;
  final String? userSnapshotJson;
  const ChangeReportEntry({
    required this.id,
    required this.ownerId,
    required this.userId,
    required this.changeType,
    required this.timestamp,
    this.userSnapshotJson,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['owner_id'] = Variable<String>(ownerId);
    map['user_id'] = Variable<String>(userId);
    map['change_type'] = Variable<String>(changeType);
    map['timestamp'] = Variable<DateTime>(timestamp);
    if (!nullToAbsent || userSnapshotJson != null) {
      map['user_snapshot_json'] = Variable<String>(userSnapshotJson);
    }
    return map;
  }

  ChangeReportsCompanion toCompanion(bool nullToAbsent) {
    return ChangeReportsCompanion(
      id: Value(id),
      ownerId: Value(ownerId),
      userId: Value(userId),
      changeType: Value(changeType),
      timestamp: Value(timestamp),
      userSnapshotJson: userSnapshotJson == null && nullToAbsent
          ? const Value.absent()
          : Value(userSnapshotJson),
    );
  }

  factory ChangeReportEntry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ChangeReportEntry(
      id: serializer.fromJson<int>(json['id']),
      ownerId: serializer.fromJson<String>(json['ownerId']),
      userId: serializer.fromJson<String>(json['userId']),
      changeType: serializer.fromJson<String>(json['changeType']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      userSnapshotJson: serializer.fromJson<String?>(json['userSnapshotJson']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ownerId': serializer.toJson<String>(ownerId),
      'userId': serializer.toJson<String>(userId),
      'changeType': serializer.toJson<String>(changeType),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'userSnapshotJson': serializer.toJson<String?>(userSnapshotJson),
    };
  }

  ChangeReportEntry copyWith({
    int? id,
    String? ownerId,
    String? userId,
    String? changeType,
    DateTime? timestamp,
    Value<String?> userSnapshotJson = const Value.absent(),
  }) => ChangeReportEntry(
    id: id ?? this.id,
    ownerId: ownerId ?? this.ownerId,
    userId: userId ?? this.userId,
    changeType: changeType ?? this.changeType,
    timestamp: timestamp ?? this.timestamp,
    userSnapshotJson: userSnapshotJson.present
        ? userSnapshotJson.value
        : this.userSnapshotJson,
  );
  ChangeReportEntry copyWithCompanion(ChangeReportsCompanion data) {
    return ChangeReportEntry(
      id: data.id.present ? data.id.value : this.id,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      userId: data.userId.present ? data.userId.value : this.userId,
      changeType: data.changeType.present
          ? data.changeType.value
          : this.changeType,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      userSnapshotJson: data.userSnapshotJson.present
          ? data.userSnapshotJson.value
          : this.userSnapshotJson,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ChangeReportEntry(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('changeType: $changeType, ')
          ..write('timestamp: $timestamp, ')
          ..write('userSnapshotJson: $userSnapshotJson')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, ownerId, userId, changeType, timestamp, userSnapshotJson);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ChangeReportEntry &&
          other.id == this.id &&
          other.ownerId == this.ownerId &&
          other.userId == this.userId &&
          other.changeType == this.changeType &&
          other.timestamp == this.timestamp &&
          other.userSnapshotJson == this.userSnapshotJson);
}

class ChangeReportsCompanion extends UpdateCompanion<ChangeReportEntry> {
  final Value<int> id;
  final Value<String> ownerId;
  final Value<String> userId;
  final Value<String> changeType;
  final Value<DateTime> timestamp;
  final Value<String?> userSnapshotJson;
  const ChangeReportsCompanion({
    this.id = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.userId = const Value.absent(),
    this.changeType = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.userSnapshotJson = const Value.absent(),
  });
  ChangeReportsCompanion.insert({
    this.id = const Value.absent(),
    required String ownerId,
    required String userId,
    required String changeType,
    required DateTime timestamp,
    this.userSnapshotJson = const Value.absent(),
  }) : ownerId = Value(ownerId),
       userId = Value(userId),
       changeType = Value(changeType),
       timestamp = Value(timestamp);
  static Insertable<ChangeReportEntry> custom({
    Expression<int>? id,
    Expression<String>? ownerId,
    Expression<String>? userId,
    Expression<String>? changeType,
    Expression<DateTime>? timestamp,
    Expression<String>? userSnapshotJson,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (ownerId != null) 'owner_id': ownerId,
      if (userId != null) 'user_id': userId,
      if (changeType != null) 'change_type': changeType,
      if (timestamp != null) 'timestamp': timestamp,
      if (userSnapshotJson != null) 'user_snapshot_json': userSnapshotJson,
    });
  }

  ChangeReportsCompanion copyWith({
    Value<int>? id,
    Value<String>? ownerId,
    Value<String>? userId,
    Value<String>? changeType,
    Value<DateTime>? timestamp,
    Value<String?>? userSnapshotJson,
  }) {
    return ChangeReportsCompanion(
      id: id ?? this.id,
      ownerId: ownerId ?? this.ownerId,
      userId: userId ?? this.userId,
      changeType: changeType ?? this.changeType,
      timestamp: timestamp ?? this.timestamp,
      userSnapshotJson: userSnapshotJson ?? this.userSnapshotJson,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (changeType.present) {
      map['change_type'] = Variable<String>(changeType.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (userSnapshotJson.present) {
      map['user_snapshot_json'] = Variable<String>(userSnapshotJson.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ChangeReportsCompanion(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('userId: $userId, ')
          ..write('changeType: $changeType, ')
          ..write('timestamp: $timestamp, ')
          ..write('userSnapshotJson: $userSnapshotJson')
          ..write(')'))
        .toString();
  }
}

class $MediaHistoryTable extends MediaHistory
    with TableInfo<$MediaHistoryTable, MediaHistoryEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MediaHistoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _mediaTypeMeta = const VerificationMeta(
    'mediaType',
  );
  @override
  late final GeneratedColumn<String> mediaType = GeneratedColumn<String>(
    'media_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _localFilePathMeta = const VerificationMeta(
    'localFilePath',
  );
  @override
  late final GeneratedColumn<String> localFilePath = GeneratedColumn<String>(
    'local_file_path',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _remoteUrlMeta = const VerificationMeta(
    'remoteUrl',
  );
  @override
  late final GeneratedColumn<String> remoteUrl = GeneratedColumn<String>(
    'remote_url',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    mediaType,
    localFilePath,
    remoteUrl,
    timestamp,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'media_history';
  @override
  VerificationContext validateIntegrity(
    Insertable<MediaHistoryEntry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('media_type')) {
      context.handle(
        _mediaTypeMeta,
        mediaType.isAcceptableOrUnknown(data['media_type']!, _mediaTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_mediaTypeMeta);
    }
    if (data.containsKey('local_file_path')) {
      context.handle(
        _localFilePathMeta,
        localFilePath.isAcceptableOrUnknown(
          data['local_file_path']!,
          _localFilePathMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_localFilePathMeta);
    }
    if (data.containsKey('remote_url')) {
      context.handle(
        _remoteUrlMeta,
        remoteUrl.isAcceptableOrUnknown(data['remote_url']!, _remoteUrlMeta),
      );
    } else if (isInserting) {
      context.missing(_remoteUrlMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MediaHistoryEntry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MediaHistoryEntry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      mediaType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}media_type'],
      )!,
      localFilePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}local_file_path'],
      )!,
      remoteUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remote_url'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
    );
  }

  @override
  $MediaHistoryTable createAlias(String alias) {
    return $MediaHistoryTable(attachedDatabase, alias);
  }
}

class MediaHistoryEntry extends DataClass
    implements Insertable<MediaHistoryEntry> {
  final int id;
  final String userId;
  final String mediaType;
  final String localFilePath;
  final String remoteUrl;
  final DateTime timestamp;
  const MediaHistoryEntry({
    required this.id,
    required this.userId,
    required this.mediaType,
    required this.localFilePath,
    required this.remoteUrl,
    required this.timestamp,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['user_id'] = Variable<String>(userId);
    map['media_type'] = Variable<String>(mediaType);
    map['local_file_path'] = Variable<String>(localFilePath);
    map['remote_url'] = Variable<String>(remoteUrl);
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  MediaHistoryCompanion toCompanion(bool nullToAbsent) {
    return MediaHistoryCompanion(
      id: Value(id),
      userId: Value(userId),
      mediaType: Value(mediaType),
      localFilePath: Value(localFilePath),
      remoteUrl: Value(remoteUrl),
      timestamp: Value(timestamp),
    );
  }

  factory MediaHistoryEntry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MediaHistoryEntry(
      id: serializer.fromJson<int>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      mediaType: serializer.fromJson<String>(json['mediaType']),
      localFilePath: serializer.fromJson<String>(json['localFilePath']),
      remoteUrl: serializer.fromJson<String>(json['remoteUrl']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'userId': serializer.toJson<String>(userId),
      'mediaType': serializer.toJson<String>(mediaType),
      'localFilePath': serializer.toJson<String>(localFilePath),
      'remoteUrl': serializer.toJson<String>(remoteUrl),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  MediaHistoryEntry copyWith({
    int? id,
    String? userId,
    String? mediaType,
    String? localFilePath,
    String? remoteUrl,
    DateTime? timestamp,
  }) => MediaHistoryEntry(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    mediaType: mediaType ?? this.mediaType,
    localFilePath: localFilePath ?? this.localFilePath,
    remoteUrl: remoteUrl ?? this.remoteUrl,
    timestamp: timestamp ?? this.timestamp,
  );
  MediaHistoryEntry copyWithCompanion(MediaHistoryCompanion data) {
    return MediaHistoryEntry(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      mediaType: data.mediaType.present ? data.mediaType.value : this.mediaType,
      localFilePath: data.localFilePath.present
          ? data.localFilePath.value
          : this.localFilePath,
      remoteUrl: data.remoteUrl.present ? data.remoteUrl.value : this.remoteUrl,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MediaHistoryEntry(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('mediaType: $mediaType, ')
          ..write('localFilePath: $localFilePath, ')
          ..write('remoteUrl: $remoteUrl, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, userId, mediaType, localFilePath, remoteUrl, timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MediaHistoryEntry &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.mediaType == this.mediaType &&
          other.localFilePath == this.localFilePath &&
          other.remoteUrl == this.remoteUrl &&
          other.timestamp == this.timestamp);
}

class MediaHistoryCompanion extends UpdateCompanion<MediaHistoryEntry> {
  final Value<int> id;
  final Value<String> userId;
  final Value<String> mediaType;
  final Value<String> localFilePath;
  final Value<String> remoteUrl;
  final Value<DateTime> timestamp;
  const MediaHistoryCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.mediaType = const Value.absent(),
    this.localFilePath = const Value.absent(),
    this.remoteUrl = const Value.absent(),
    this.timestamp = const Value.absent(),
  });
  MediaHistoryCompanion.insert({
    this.id = const Value.absent(),
    required String userId,
    required String mediaType,
    required String localFilePath,
    required String remoteUrl,
    required DateTime timestamp,
  }) : userId = Value(userId),
       mediaType = Value(mediaType),
       localFilePath = Value(localFilePath),
       remoteUrl = Value(remoteUrl),
       timestamp = Value(timestamp);
  static Insertable<MediaHistoryEntry> custom({
    Expression<int>? id,
    Expression<String>? userId,
    Expression<String>? mediaType,
    Expression<String>? localFilePath,
    Expression<String>? remoteUrl,
    Expression<DateTime>? timestamp,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (mediaType != null) 'media_type': mediaType,
      if (localFilePath != null) 'local_file_path': localFilePath,
      if (remoteUrl != null) 'remote_url': remoteUrl,
      if (timestamp != null) 'timestamp': timestamp,
    });
  }

  MediaHistoryCompanion copyWith({
    Value<int>? id,
    Value<String>? userId,
    Value<String>? mediaType,
    Value<String>? localFilePath,
    Value<String>? remoteUrl,
    Value<DateTime>? timestamp,
  }) {
    return MediaHistoryCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      mediaType: mediaType ?? this.mediaType,
      localFilePath: localFilePath ?? this.localFilePath,
      remoteUrl: remoteUrl ?? this.remoteUrl,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (mediaType.present) {
      map['media_type'] = Variable<String>(mediaType.value);
    }
    if (localFilePath.present) {
      map['local_file_path'] = Variable<String>(localFilePath.value);
    }
    if (remoteUrl.present) {
      map['remote_url'] = Variable<String>(remoteUrl.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MediaHistoryCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('mediaType: $mediaType, ')
          ..write('localFilePath: $localFilePath, ')
          ..write('remoteUrl: $remoteUrl, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $LoggedAccountsTable loggedAccounts = $LoggedAccountsTable(this);
  late final $AccountProfileHistoryTable accountProfileHistory =
      $AccountProfileHistoryTable(this);
  late final $FollowUsersTable followUsers = $FollowUsersTable(this);
  late final $FollowUsersHistoryTable followUsersHistory =
      $FollowUsersHistoryTable(this);
  late final $ChangeReportsTable changeReports = $ChangeReportsTable(this);
  late final $MediaHistoryTable mediaHistory = $MediaHistoryTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    loggedAccounts,
    accountProfileHistory,
    followUsers,
    followUsersHistory,
    changeReports,
    mediaHistory,
  ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules([
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'logged_accounts',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('account_profile_history', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'logged_accounts',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('follow_users', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'logged_accounts',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('change_reports', kind: UpdateKind.delete)],
    ),
  ]);
}

typedef $$LoggedAccountsTableCreateCompanionBuilder =
    LoggedAccountsCompanion Function({
      required String id,
      Value<String?> name,
      Value<String?> screenName,
      Value<String?> bio,
      Value<String?> location,
      Value<String?> link,
      Value<String?> joinTime,
      Value<bool?> isVerified,
      Value<bool?> isProtected,
      Value<int> followersCount,
      Value<int> followingCount,
      Value<int> statusesCount,
      Value<int> mediaCount,
      Value<int> favouritesCount,
      Value<int> listedCount,
      Value<String?> latestRawJson,
      Value<String?> avatarUrl,
      Value<String?> bannerUrl,
      Value<String?> avatarLocalPath,
      Value<String?> bannerLocalPath,
      Value<int> rowid,
    });
typedef $$LoggedAccountsTableUpdateCompanionBuilder =
    LoggedAccountsCompanion Function({
      Value<String> id,
      Value<String?> name,
      Value<String?> screenName,
      Value<String?> bio,
      Value<String?> location,
      Value<String?> link,
      Value<String?> joinTime,
      Value<bool?> isVerified,
      Value<bool?> isProtected,
      Value<int> followersCount,
      Value<int> followingCount,
      Value<int> statusesCount,
      Value<int> mediaCount,
      Value<int> favouritesCount,
      Value<int> listedCount,
      Value<String?> latestRawJson,
      Value<String?> avatarUrl,
      Value<String?> bannerUrl,
      Value<String?> avatarLocalPath,
      Value<String?> bannerLocalPath,
      Value<int> rowid,
    });

final class $$LoggedAccountsTableReferences
    extends BaseReferences<_$AppDatabase, $LoggedAccountsTable, LoggedAccount> {
  $$LoggedAccountsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<
    $AccountProfileHistoryTable,
    List<AccountProfileHistoryEntry>
  >
  _accountProfileHistoryRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.accountProfileHistory,
        aliasName: $_aliasNameGenerator(
          db.loggedAccounts.id,
          db.accountProfileHistory.ownerId,
        ),
      );

  $$AccountProfileHistoryTableProcessedTableManager
  get accountProfileHistoryRefs {
    final manager = $$AccountProfileHistoryTableTableManager(
      $_db,
      $_db.accountProfileHistory,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _accountProfileHistoryRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FollowUsersTable, List<FollowUser>>
  _followUsersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.followUsers,
    aliasName: $_aliasNameGenerator(
      db.loggedAccounts.id,
      db.followUsers.ownerId,
    ),
  );

  $$FollowUsersTableProcessedTableManager get followUsersRefs {
    final manager = $$FollowUsersTableTableManager(
      $_db,
      $_db.followUsers,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_followUsersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ChangeReportsTable, List<ChangeReportEntry>>
  _changeReportsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.changeReports,
    aliasName: $_aliasNameGenerator(
      db.loggedAccounts.id,
      db.changeReports.ownerId,
    ),
  );

  $$ChangeReportsTableProcessedTableManager get changeReportsRefs {
    final manager = $$ChangeReportsTableTableManager(
      $_db,
      $_db.changeReports,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_changeReportsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$LoggedAccountsTableFilterComposer
    extends Composer<_$AppDatabase, $LoggedAccountsTable> {
  $$LoggedAccountsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bio => $composableBuilder(
    column: $table.bio,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get link => $composableBuilder(
    column: $table.link,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get joinTime => $composableBuilder(
    column: $table.joinTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isVerified => $composableBuilder(
    column: $table.isVerified,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isProtected => $composableBuilder(
    column: $table.isProtected,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get followersCount => $composableBuilder(
    column: $table.followersCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get followingCount => $composableBuilder(
    column: $table.followingCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get statusesCount => $composableBuilder(
    column: $table.statusesCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mediaCount => $composableBuilder(
    column: $table.mediaCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get favouritesCount => $composableBuilder(
    column: $table.favouritesCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get listedCount => $composableBuilder(
    column: $table.listedCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bannerUrl => $composableBuilder(
    column: $table.bannerUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bannerLocalPath => $composableBuilder(
    column: $table.bannerLocalPath,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> accountProfileHistoryRefs(
    Expression<bool> Function($$AccountProfileHistoryTableFilterComposer f) f,
  ) {
    final $$AccountProfileHistoryTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.accountProfileHistory,
          getReferencedColumn: (t) => t.ownerId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$AccountProfileHistoryTableFilterComposer(
                $db: $db,
                $table: $db.accountProfileHistory,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<bool> followUsersRefs(
    Expression<bool> Function($$FollowUsersTableFilterComposer f) f,
  ) {
    final $$FollowUsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.followUsers,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FollowUsersTableFilterComposer(
            $db: $db,
            $table: $db.followUsers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> changeReportsRefs(
    Expression<bool> Function($$ChangeReportsTableFilterComposer f) f,
  ) {
    final $$ChangeReportsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.changeReports,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ChangeReportsTableFilterComposer(
            $db: $db,
            $table: $db.changeReports,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$LoggedAccountsTableOrderingComposer
    extends Composer<_$AppDatabase, $LoggedAccountsTable> {
  $$LoggedAccountsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bio => $composableBuilder(
    column: $table.bio,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get link => $composableBuilder(
    column: $table.link,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get joinTime => $composableBuilder(
    column: $table.joinTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isVerified => $composableBuilder(
    column: $table.isVerified,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isProtected => $composableBuilder(
    column: $table.isProtected,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get followersCount => $composableBuilder(
    column: $table.followersCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get followingCount => $composableBuilder(
    column: $table.followingCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get statusesCount => $composableBuilder(
    column: $table.statusesCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mediaCount => $composableBuilder(
    column: $table.mediaCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get favouritesCount => $composableBuilder(
    column: $table.favouritesCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get listedCount => $composableBuilder(
    column: $table.listedCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bannerUrl => $composableBuilder(
    column: $table.bannerUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bannerLocalPath => $composableBuilder(
    column: $table.bannerLocalPath,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$LoggedAccountsTableAnnotationComposer
    extends Composer<_$AppDatabase, $LoggedAccountsTable> {
  $$LoggedAccountsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bio =>
      $composableBuilder(column: $table.bio, builder: (column) => column);

  GeneratedColumn<String> get location =>
      $composableBuilder(column: $table.location, builder: (column) => column);

  GeneratedColumn<String> get link =>
      $composableBuilder(column: $table.link, builder: (column) => column);

  GeneratedColumn<String> get joinTime =>
      $composableBuilder(column: $table.joinTime, builder: (column) => column);

  GeneratedColumn<bool> get isVerified => $composableBuilder(
    column: $table.isVerified,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isProtected => $composableBuilder(
    column: $table.isProtected,
    builder: (column) => column,
  );

  GeneratedColumn<int> get followersCount => $composableBuilder(
    column: $table.followersCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get followingCount => $composableBuilder(
    column: $table.followingCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get statusesCount => $composableBuilder(
    column: $table.statusesCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get mediaCount => $composableBuilder(
    column: $table.mediaCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get favouritesCount => $composableBuilder(
    column: $table.favouritesCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get listedCount => $composableBuilder(
    column: $table.listedCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => column,
  );

  GeneratedColumn<String> get avatarUrl =>
      $composableBuilder(column: $table.avatarUrl, builder: (column) => column);

  GeneratedColumn<String> get bannerUrl =>
      $composableBuilder(column: $table.bannerUrl, builder: (column) => column);

  GeneratedColumn<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bannerLocalPath => $composableBuilder(
    column: $table.bannerLocalPath,
    builder: (column) => column,
  );

  Expression<T> accountProfileHistoryRefs<T extends Object>(
    Expression<T> Function($$AccountProfileHistoryTableAnnotationComposer a) f,
  ) {
    final $$AccountProfileHistoryTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.accountProfileHistory,
          getReferencedColumn: (t) => t.ownerId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$AccountProfileHistoryTableAnnotationComposer(
                $db: $db,
                $table: $db.accountProfileHistory,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> followUsersRefs<T extends Object>(
    Expression<T> Function($$FollowUsersTableAnnotationComposer a) f,
  ) {
    final $$FollowUsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.followUsers,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FollowUsersTableAnnotationComposer(
            $db: $db,
            $table: $db.followUsers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> changeReportsRefs<T extends Object>(
    Expression<T> Function($$ChangeReportsTableAnnotationComposer a) f,
  ) {
    final $$ChangeReportsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.changeReports,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ChangeReportsTableAnnotationComposer(
            $db: $db,
            $table: $db.changeReports,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$LoggedAccountsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LoggedAccountsTable,
          LoggedAccount,
          $$LoggedAccountsTableFilterComposer,
          $$LoggedAccountsTableOrderingComposer,
          $$LoggedAccountsTableAnnotationComposer,
          $$LoggedAccountsTableCreateCompanionBuilder,
          $$LoggedAccountsTableUpdateCompanionBuilder,
          (LoggedAccount, $$LoggedAccountsTableReferences),
          LoggedAccount,
          PrefetchHooks Function({
            bool accountProfileHistoryRefs,
            bool followUsersRefs,
            bool changeReportsRefs,
          })
        > {
  $$LoggedAccountsTableTableManager(
    _$AppDatabase db,
    $LoggedAccountsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LoggedAccountsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LoggedAccountsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LoggedAccountsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> screenName = const Value.absent(),
                Value<String?> bio = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> link = const Value.absent(),
                Value<String?> joinTime = const Value.absent(),
                Value<bool?> isVerified = const Value.absent(),
                Value<bool?> isProtected = const Value.absent(),
                Value<int> followersCount = const Value.absent(),
                Value<int> followingCount = const Value.absent(),
                Value<int> statusesCount = const Value.absent(),
                Value<int> mediaCount = const Value.absent(),
                Value<int> favouritesCount = const Value.absent(),
                Value<int> listedCount = const Value.absent(),
                Value<String?> latestRawJson = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String?> bannerUrl = const Value.absent(),
                Value<String?> avatarLocalPath = const Value.absent(),
                Value<String?> bannerLocalPath = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LoggedAccountsCompanion(
                id: id,
                name: name,
                screenName: screenName,
                bio: bio,
                location: location,
                link: link,
                joinTime: joinTime,
                isVerified: isVerified,
                isProtected: isProtected,
                followersCount: followersCount,
                followingCount: followingCount,
                statusesCount: statusesCount,
                mediaCount: mediaCount,
                favouritesCount: favouritesCount,
                listedCount: listedCount,
                latestRawJson: latestRawJson,
                avatarUrl: avatarUrl,
                bannerUrl: bannerUrl,
                avatarLocalPath: avatarLocalPath,
                bannerLocalPath: bannerLocalPath,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> name = const Value.absent(),
                Value<String?> screenName = const Value.absent(),
                Value<String?> bio = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> link = const Value.absent(),
                Value<String?> joinTime = const Value.absent(),
                Value<bool?> isVerified = const Value.absent(),
                Value<bool?> isProtected = const Value.absent(),
                Value<int> followersCount = const Value.absent(),
                Value<int> followingCount = const Value.absent(),
                Value<int> statusesCount = const Value.absent(),
                Value<int> mediaCount = const Value.absent(),
                Value<int> favouritesCount = const Value.absent(),
                Value<int> listedCount = const Value.absent(),
                Value<String?> latestRawJson = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String?> bannerUrl = const Value.absent(),
                Value<String?> avatarLocalPath = const Value.absent(),
                Value<String?> bannerLocalPath = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LoggedAccountsCompanion.insert(
                id: id,
                name: name,
                screenName: screenName,
                bio: bio,
                location: location,
                link: link,
                joinTime: joinTime,
                isVerified: isVerified,
                isProtected: isProtected,
                followersCount: followersCount,
                followingCount: followingCount,
                statusesCount: statusesCount,
                mediaCount: mediaCount,
                favouritesCount: favouritesCount,
                listedCount: listedCount,
                latestRawJson: latestRawJson,
                avatarUrl: avatarUrl,
                bannerUrl: bannerUrl,
                avatarLocalPath: avatarLocalPath,
                bannerLocalPath: bannerLocalPath,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$LoggedAccountsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                accountProfileHistoryRefs = false,
                followUsersRefs = false,
                changeReportsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (accountProfileHistoryRefs) db.accountProfileHistory,
                    if (followUsersRefs) db.followUsers,
                    if (changeReportsRefs) db.changeReports,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (accountProfileHistoryRefs)
                        await $_getPrefetchedData<
                          LoggedAccount,
                          $LoggedAccountsTable,
                          AccountProfileHistoryEntry
                        >(
                          currentTable: table,
                          referencedTable: $$LoggedAccountsTableReferences
                              ._accountProfileHistoryRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$LoggedAccountsTableReferences(
                                db,
                                table,
                                p0,
                              ).accountProfileHistoryRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (followUsersRefs)
                        await $_getPrefetchedData<
                          LoggedAccount,
                          $LoggedAccountsTable,
                          FollowUser
                        >(
                          currentTable: table,
                          referencedTable: $$LoggedAccountsTableReferences
                              ._followUsersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$LoggedAccountsTableReferences(
                                db,
                                table,
                                p0,
                              ).followUsersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (changeReportsRefs)
                        await $_getPrefetchedData<
                          LoggedAccount,
                          $LoggedAccountsTable,
                          ChangeReportEntry
                        >(
                          currentTable: table,
                          referencedTable: $$LoggedAccountsTableReferences
                              ._changeReportsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$LoggedAccountsTableReferences(
                                db,
                                table,
                                p0,
                              ).changeReportsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$LoggedAccountsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LoggedAccountsTable,
      LoggedAccount,
      $$LoggedAccountsTableFilterComposer,
      $$LoggedAccountsTableOrderingComposer,
      $$LoggedAccountsTableAnnotationComposer,
      $$LoggedAccountsTableCreateCompanionBuilder,
      $$LoggedAccountsTableUpdateCompanionBuilder,
      (LoggedAccount, $$LoggedAccountsTableReferences),
      LoggedAccount,
      PrefetchHooks Function({
        bool accountProfileHistoryRefs,
        bool followUsersRefs,
        bool changeReportsRefs,
      })
    >;
typedef $$AccountProfileHistoryTableCreateCompanionBuilder =
    AccountProfileHistoryCompanion Function({
      Value<int> id,
      required String ownerId,
      required String reverseDiffJson,
      required DateTime timestamp,
    });
typedef $$AccountProfileHistoryTableUpdateCompanionBuilder =
    AccountProfileHistoryCompanion Function({
      Value<int> id,
      Value<String> ownerId,
      Value<String> reverseDiffJson,
      Value<DateTime> timestamp,
    });

final class $$AccountProfileHistoryTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $AccountProfileHistoryTable,
          AccountProfileHistoryEntry
        > {
  $$AccountProfileHistoryTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $LoggedAccountsTable _ownerIdTable(_$AppDatabase db) =>
      db.loggedAccounts.createAlias(
        $_aliasNameGenerator(
          db.accountProfileHistory.ownerId,
          db.loggedAccounts.id,
        ),
      );

  $$LoggedAccountsTableProcessedTableManager get ownerId {
    final $_column = $_itemColumn<String>('owner_id')!;

    final manager = $$LoggedAccountsTableTableManager(
      $_db,
      $_db.loggedAccounts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$AccountProfileHistoryTableFilterComposer
    extends Composer<_$AppDatabase, $AccountProfileHistoryTable> {
  $$AccountProfileHistoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  $$LoggedAccountsTableFilterComposer get ownerId {
    final $$LoggedAccountsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableFilterComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AccountProfileHistoryTableOrderingComposer
    extends Composer<_$AppDatabase, $AccountProfileHistoryTable> {
  $$AccountProfileHistoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  $$LoggedAccountsTableOrderingComposer get ownerId {
    final $$LoggedAccountsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableOrderingComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AccountProfileHistoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $AccountProfileHistoryTable> {
  $$AccountProfileHistoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  $$LoggedAccountsTableAnnotationComposer get ownerId {
    final $$LoggedAccountsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableAnnotationComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AccountProfileHistoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AccountProfileHistoryTable,
          AccountProfileHistoryEntry,
          $$AccountProfileHistoryTableFilterComposer,
          $$AccountProfileHistoryTableOrderingComposer,
          $$AccountProfileHistoryTableAnnotationComposer,
          $$AccountProfileHistoryTableCreateCompanionBuilder,
          $$AccountProfileHistoryTableUpdateCompanionBuilder,
          (AccountProfileHistoryEntry, $$AccountProfileHistoryTableReferences),
          AccountProfileHistoryEntry,
          PrefetchHooks Function({bool ownerId})
        > {
  $$AccountProfileHistoryTableTableManager(
    _$AppDatabase db,
    $AccountProfileHistoryTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AccountProfileHistoryTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$AccountProfileHistoryTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$AccountProfileHistoryTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> ownerId = const Value.absent(),
                Value<String> reverseDiffJson = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
              }) => AccountProfileHistoryCompanion(
                id: id,
                ownerId: ownerId,
                reverseDiffJson: reverseDiffJson,
                timestamp: timestamp,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String ownerId,
                required String reverseDiffJson,
                required DateTime timestamp,
              }) => AccountProfileHistoryCompanion.insert(
                id: id,
                ownerId: ownerId,
                reverseDiffJson: reverseDiffJson,
                timestamp: timestamp,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$AccountProfileHistoryTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({ownerId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (ownerId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.ownerId,
                                referencedTable:
                                    $$AccountProfileHistoryTableReferences
                                        ._ownerIdTable(db),
                                referencedColumn:
                                    $$AccountProfileHistoryTableReferences
                                        ._ownerIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$AccountProfileHistoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AccountProfileHistoryTable,
      AccountProfileHistoryEntry,
      $$AccountProfileHistoryTableFilterComposer,
      $$AccountProfileHistoryTableOrderingComposer,
      $$AccountProfileHistoryTableAnnotationComposer,
      $$AccountProfileHistoryTableCreateCompanionBuilder,
      $$AccountProfileHistoryTableUpdateCompanionBuilder,
      (AccountProfileHistoryEntry, $$AccountProfileHistoryTableReferences),
      AccountProfileHistoryEntry,
      PrefetchHooks Function({bool ownerId})
    >;
typedef $$FollowUsersTableCreateCompanionBuilder =
    FollowUsersCompanion Function({
      required String ownerId,
      required String userId,
      Value<String?> latestRawJson,
      Value<String?> name,
      Value<String?> screenName,
      Value<String?> avatarUrl,
      Value<String?> bannerUrl,
      Value<String?> bio,
      Value<String?> avatarLocalPath,
      Value<String?> bannerLocalPath,
      Value<bool> isFollower,
      Value<bool> isFollowing,
      Value<int> rowid,
    });
typedef $$FollowUsersTableUpdateCompanionBuilder =
    FollowUsersCompanion Function({
      Value<String> ownerId,
      Value<String> userId,
      Value<String?> latestRawJson,
      Value<String?> name,
      Value<String?> screenName,
      Value<String?> avatarUrl,
      Value<String?> bannerUrl,
      Value<String?> bio,
      Value<String?> avatarLocalPath,
      Value<String?> bannerLocalPath,
      Value<bool> isFollower,
      Value<bool> isFollowing,
      Value<int> rowid,
    });

final class $$FollowUsersTableReferences
    extends BaseReferences<_$AppDatabase, $FollowUsersTable, FollowUser> {
  $$FollowUsersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $LoggedAccountsTable _ownerIdTable(_$AppDatabase db) =>
      db.loggedAccounts.createAlias(
        $_aliasNameGenerator(db.followUsers.ownerId, db.loggedAccounts.id),
      );

  $$LoggedAccountsTableProcessedTableManager get ownerId {
    final $_column = $_itemColumn<String>('owner_id')!;

    final manager = $$LoggedAccountsTableTableManager(
      $_db,
      $_db.loggedAccounts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FollowUsersTableFilterComposer
    extends Composer<_$AppDatabase, $FollowUsersTable> {
  $$FollowUsersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bannerUrl => $composableBuilder(
    column: $table.bannerUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bio => $composableBuilder(
    column: $table.bio,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bannerLocalPath => $composableBuilder(
    column: $table.bannerLocalPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFollower => $composableBuilder(
    column: $table.isFollower,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFollowing => $composableBuilder(
    column: $table.isFollowing,
    builder: (column) => ColumnFilters(column),
  );

  $$LoggedAccountsTableFilterComposer get ownerId {
    final $$LoggedAccountsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableFilterComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FollowUsersTableOrderingComposer
    extends Composer<_$AppDatabase, $FollowUsersTable> {
  $$FollowUsersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bannerUrl => $composableBuilder(
    column: $table.bannerUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bio => $composableBuilder(
    column: $table.bio,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bannerLocalPath => $composableBuilder(
    column: $table.bannerLocalPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFollower => $composableBuilder(
    column: $table.isFollower,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFollowing => $composableBuilder(
    column: $table.isFollowing,
    builder: (column) => ColumnOrderings(column),
  );

  $$LoggedAccountsTableOrderingComposer get ownerId {
    final $$LoggedAccountsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableOrderingComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FollowUsersTableAnnotationComposer
    extends Composer<_$AppDatabase, $FollowUsersTable> {
  $$FollowUsersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get latestRawJson => $composableBuilder(
    column: $table.latestRawJson,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get screenName => $composableBuilder(
    column: $table.screenName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get avatarUrl =>
      $composableBuilder(column: $table.avatarUrl, builder: (column) => column);

  GeneratedColumn<String> get bannerUrl =>
      $composableBuilder(column: $table.bannerUrl, builder: (column) => column);

  GeneratedColumn<String> get bio =>
      $composableBuilder(column: $table.bio, builder: (column) => column);

  GeneratedColumn<String> get avatarLocalPath => $composableBuilder(
    column: $table.avatarLocalPath,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bannerLocalPath => $composableBuilder(
    column: $table.bannerLocalPath,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isFollower => $composableBuilder(
    column: $table.isFollower,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isFollowing => $composableBuilder(
    column: $table.isFollowing,
    builder: (column) => column,
  );

  $$LoggedAccountsTableAnnotationComposer get ownerId {
    final $$LoggedAccountsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableAnnotationComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FollowUsersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FollowUsersTable,
          FollowUser,
          $$FollowUsersTableFilterComposer,
          $$FollowUsersTableOrderingComposer,
          $$FollowUsersTableAnnotationComposer,
          $$FollowUsersTableCreateCompanionBuilder,
          $$FollowUsersTableUpdateCompanionBuilder,
          (FollowUser, $$FollowUsersTableReferences),
          FollowUser,
          PrefetchHooks Function({bool ownerId})
        > {
  $$FollowUsersTableTableManager(_$AppDatabase db, $FollowUsersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FollowUsersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FollowUsersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FollowUsersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> ownerId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> latestRawJson = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> screenName = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String?> bannerUrl = const Value.absent(),
                Value<String?> bio = const Value.absent(),
                Value<String?> avatarLocalPath = const Value.absent(),
                Value<String?> bannerLocalPath = const Value.absent(),
                Value<bool> isFollower = const Value.absent(),
                Value<bool> isFollowing = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FollowUsersCompanion(
                ownerId: ownerId,
                userId: userId,
                latestRawJson: latestRawJson,
                name: name,
                screenName: screenName,
                avatarUrl: avatarUrl,
                bannerUrl: bannerUrl,
                bio: bio,
                avatarLocalPath: avatarLocalPath,
                bannerLocalPath: bannerLocalPath,
                isFollower: isFollower,
                isFollowing: isFollowing,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String ownerId,
                required String userId,
                Value<String?> latestRawJson = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> screenName = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String?> bannerUrl = const Value.absent(),
                Value<String?> bio = const Value.absent(),
                Value<String?> avatarLocalPath = const Value.absent(),
                Value<String?> bannerLocalPath = const Value.absent(),
                Value<bool> isFollower = const Value.absent(),
                Value<bool> isFollowing = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FollowUsersCompanion.insert(
                ownerId: ownerId,
                userId: userId,
                latestRawJson: latestRawJson,
                name: name,
                screenName: screenName,
                avatarUrl: avatarUrl,
                bannerUrl: bannerUrl,
                bio: bio,
                avatarLocalPath: avatarLocalPath,
                bannerLocalPath: bannerLocalPath,
                isFollower: isFollower,
                isFollowing: isFollowing,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FollowUsersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({ownerId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (ownerId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.ownerId,
                                referencedTable: $$FollowUsersTableReferences
                                    ._ownerIdTable(db),
                                referencedColumn: $$FollowUsersTableReferences
                                    ._ownerIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FollowUsersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FollowUsersTable,
      FollowUser,
      $$FollowUsersTableFilterComposer,
      $$FollowUsersTableOrderingComposer,
      $$FollowUsersTableAnnotationComposer,
      $$FollowUsersTableCreateCompanionBuilder,
      $$FollowUsersTableUpdateCompanionBuilder,
      (FollowUser, $$FollowUsersTableReferences),
      FollowUser,
      PrefetchHooks Function({bool ownerId})
    >;
typedef $$FollowUsersHistoryTableCreateCompanionBuilder =
    FollowUsersHistoryCompanion Function({
      Value<int> id,
      required String ownerId,
      required String userId,
      required String reverseDiffJson,
      required DateTime timestamp,
    });
typedef $$FollowUsersHistoryTableUpdateCompanionBuilder =
    FollowUsersHistoryCompanion Function({
      Value<int> id,
      Value<String> ownerId,
      Value<String> userId,
      Value<String> reverseDiffJson,
      Value<DateTime> timestamp,
    });

class $$FollowUsersHistoryTableFilterComposer
    extends Composer<_$AppDatabase, $FollowUsersHistoryTable> {
  $$FollowUsersHistoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ownerId => $composableBuilder(
    column: $table.ownerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FollowUsersHistoryTableOrderingComposer
    extends Composer<_$AppDatabase, $FollowUsersHistoryTable> {
  $$FollowUsersHistoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ownerId => $composableBuilder(
    column: $table.ownerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FollowUsersHistoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $FollowUsersHistoryTable> {
  $$FollowUsersHistoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get ownerId =>
      $composableBuilder(column: $table.ownerId, builder: (column) => column);

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get reverseDiffJson => $composableBuilder(
    column: $table.reverseDiffJson,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);
}

class $$FollowUsersHistoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FollowUsersHistoryTable,
          FollowUserHistoryEntry,
          $$FollowUsersHistoryTableFilterComposer,
          $$FollowUsersHistoryTableOrderingComposer,
          $$FollowUsersHistoryTableAnnotationComposer,
          $$FollowUsersHistoryTableCreateCompanionBuilder,
          $$FollowUsersHistoryTableUpdateCompanionBuilder,
          (
            FollowUserHistoryEntry,
            BaseReferences<
              _$AppDatabase,
              $FollowUsersHistoryTable,
              FollowUserHistoryEntry
            >,
          ),
          FollowUserHistoryEntry,
          PrefetchHooks Function()
        > {
  $$FollowUsersHistoryTableTableManager(
    _$AppDatabase db,
    $FollowUsersHistoryTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FollowUsersHistoryTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FollowUsersHistoryTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FollowUsersHistoryTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> ownerId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> reverseDiffJson = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
              }) => FollowUsersHistoryCompanion(
                id: id,
                ownerId: ownerId,
                userId: userId,
                reverseDiffJson: reverseDiffJson,
                timestamp: timestamp,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String ownerId,
                required String userId,
                required String reverseDiffJson,
                required DateTime timestamp,
              }) => FollowUsersHistoryCompanion.insert(
                id: id,
                ownerId: ownerId,
                userId: userId,
                reverseDiffJson: reverseDiffJson,
                timestamp: timestamp,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FollowUsersHistoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FollowUsersHistoryTable,
      FollowUserHistoryEntry,
      $$FollowUsersHistoryTableFilterComposer,
      $$FollowUsersHistoryTableOrderingComposer,
      $$FollowUsersHistoryTableAnnotationComposer,
      $$FollowUsersHistoryTableCreateCompanionBuilder,
      $$FollowUsersHistoryTableUpdateCompanionBuilder,
      (
        FollowUserHistoryEntry,
        BaseReferences<
          _$AppDatabase,
          $FollowUsersHistoryTable,
          FollowUserHistoryEntry
        >,
      ),
      FollowUserHistoryEntry,
      PrefetchHooks Function()
    >;
typedef $$ChangeReportsTableCreateCompanionBuilder =
    ChangeReportsCompanion Function({
      Value<int> id,
      required String ownerId,
      required String userId,
      required String changeType,
      required DateTime timestamp,
      Value<String?> userSnapshotJson,
    });
typedef $$ChangeReportsTableUpdateCompanionBuilder =
    ChangeReportsCompanion Function({
      Value<int> id,
      Value<String> ownerId,
      Value<String> userId,
      Value<String> changeType,
      Value<DateTime> timestamp,
      Value<String?> userSnapshotJson,
    });

final class $$ChangeReportsTableReferences
    extends
        BaseReferences<_$AppDatabase, $ChangeReportsTable, ChangeReportEntry> {
  $$ChangeReportsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $LoggedAccountsTable _ownerIdTable(_$AppDatabase db) =>
      db.loggedAccounts.createAlias(
        $_aliasNameGenerator(db.changeReports.ownerId, db.loggedAccounts.id),
      );

  $$LoggedAccountsTableProcessedTableManager get ownerId {
    final $_column = $_itemColumn<String>('owner_id')!;

    final manager = $$LoggedAccountsTableTableManager(
      $_db,
      $_db.loggedAccounts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ChangeReportsTableFilterComposer
    extends Composer<_$AppDatabase, $ChangeReportsTable> {
  $$ChangeReportsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get changeType => $composableBuilder(
    column: $table.changeType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userSnapshotJson => $composableBuilder(
    column: $table.userSnapshotJson,
    builder: (column) => ColumnFilters(column),
  );

  $$LoggedAccountsTableFilterComposer get ownerId {
    final $$LoggedAccountsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableFilterComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ChangeReportsTableOrderingComposer
    extends Composer<_$AppDatabase, $ChangeReportsTable> {
  $$ChangeReportsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get changeType => $composableBuilder(
    column: $table.changeType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userSnapshotJson => $composableBuilder(
    column: $table.userSnapshotJson,
    builder: (column) => ColumnOrderings(column),
  );

  $$LoggedAccountsTableOrderingComposer get ownerId {
    final $$LoggedAccountsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableOrderingComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ChangeReportsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ChangeReportsTable> {
  $$ChangeReportsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get changeType => $composableBuilder(
    column: $table.changeType,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<String> get userSnapshotJson => $composableBuilder(
    column: $table.userSnapshotJson,
    builder: (column) => column,
  );

  $$LoggedAccountsTableAnnotationComposer get ownerId {
    final $$LoggedAccountsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.loggedAccounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LoggedAccountsTableAnnotationComposer(
            $db: $db,
            $table: $db.loggedAccounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ChangeReportsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ChangeReportsTable,
          ChangeReportEntry,
          $$ChangeReportsTableFilterComposer,
          $$ChangeReportsTableOrderingComposer,
          $$ChangeReportsTableAnnotationComposer,
          $$ChangeReportsTableCreateCompanionBuilder,
          $$ChangeReportsTableUpdateCompanionBuilder,
          (ChangeReportEntry, $$ChangeReportsTableReferences),
          ChangeReportEntry,
          PrefetchHooks Function({bool ownerId})
        > {
  $$ChangeReportsTableTableManager(_$AppDatabase db, $ChangeReportsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ChangeReportsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ChangeReportsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ChangeReportsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> ownerId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> changeType = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
                Value<String?> userSnapshotJson = const Value.absent(),
              }) => ChangeReportsCompanion(
                id: id,
                ownerId: ownerId,
                userId: userId,
                changeType: changeType,
                timestamp: timestamp,
                userSnapshotJson: userSnapshotJson,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String ownerId,
                required String userId,
                required String changeType,
                required DateTime timestamp,
                Value<String?> userSnapshotJson = const Value.absent(),
              }) => ChangeReportsCompanion.insert(
                id: id,
                ownerId: ownerId,
                userId: userId,
                changeType: changeType,
                timestamp: timestamp,
                userSnapshotJson: userSnapshotJson,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ChangeReportsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({ownerId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (ownerId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.ownerId,
                                referencedTable: $$ChangeReportsTableReferences
                                    ._ownerIdTable(db),
                                referencedColumn: $$ChangeReportsTableReferences
                                    ._ownerIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ChangeReportsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ChangeReportsTable,
      ChangeReportEntry,
      $$ChangeReportsTableFilterComposer,
      $$ChangeReportsTableOrderingComposer,
      $$ChangeReportsTableAnnotationComposer,
      $$ChangeReportsTableCreateCompanionBuilder,
      $$ChangeReportsTableUpdateCompanionBuilder,
      (ChangeReportEntry, $$ChangeReportsTableReferences),
      ChangeReportEntry,
      PrefetchHooks Function({bool ownerId})
    >;
typedef $$MediaHistoryTableCreateCompanionBuilder =
    MediaHistoryCompanion Function({
      Value<int> id,
      required String userId,
      required String mediaType,
      required String localFilePath,
      required String remoteUrl,
      required DateTime timestamp,
    });
typedef $$MediaHistoryTableUpdateCompanionBuilder =
    MediaHistoryCompanion Function({
      Value<int> id,
      Value<String> userId,
      Value<String> mediaType,
      Value<String> localFilePath,
      Value<String> remoteUrl,
      Value<DateTime> timestamp,
    });

class $$MediaHistoryTableFilterComposer
    extends Composer<_$AppDatabase, $MediaHistoryTable> {
  $$MediaHistoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get mediaType => $composableBuilder(
    column: $table.mediaType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get localFilePath => $composableBuilder(
    column: $table.localFilePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remoteUrl => $composableBuilder(
    column: $table.remoteUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MediaHistoryTableOrderingComposer
    extends Composer<_$AppDatabase, $MediaHistoryTable> {
  $$MediaHistoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get mediaType => $composableBuilder(
    column: $table.mediaType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get localFilePath => $composableBuilder(
    column: $table.localFilePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remoteUrl => $composableBuilder(
    column: $table.remoteUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MediaHistoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $MediaHistoryTable> {
  $$MediaHistoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get mediaType =>
      $composableBuilder(column: $table.mediaType, builder: (column) => column);

  GeneratedColumn<String> get localFilePath => $composableBuilder(
    column: $table.localFilePath,
    builder: (column) => column,
  );

  GeneratedColumn<String> get remoteUrl =>
      $composableBuilder(column: $table.remoteUrl, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);
}

class $$MediaHistoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MediaHistoryTable,
          MediaHistoryEntry,
          $$MediaHistoryTableFilterComposer,
          $$MediaHistoryTableOrderingComposer,
          $$MediaHistoryTableAnnotationComposer,
          $$MediaHistoryTableCreateCompanionBuilder,
          $$MediaHistoryTableUpdateCompanionBuilder,
          (
            MediaHistoryEntry,
            BaseReferences<
              _$AppDatabase,
              $MediaHistoryTable,
              MediaHistoryEntry
            >,
          ),
          MediaHistoryEntry,
          PrefetchHooks Function()
        > {
  $$MediaHistoryTableTableManager(_$AppDatabase db, $MediaHistoryTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MediaHistoryTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MediaHistoryTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MediaHistoryTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> mediaType = const Value.absent(),
                Value<String> localFilePath = const Value.absent(),
                Value<String> remoteUrl = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
              }) => MediaHistoryCompanion(
                id: id,
                userId: userId,
                mediaType: mediaType,
                localFilePath: localFilePath,
                remoteUrl: remoteUrl,
                timestamp: timestamp,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String userId,
                required String mediaType,
                required String localFilePath,
                required String remoteUrl,
                required DateTime timestamp,
              }) => MediaHistoryCompanion.insert(
                id: id,
                userId: userId,
                mediaType: mediaType,
                localFilePath: localFilePath,
                remoteUrl: remoteUrl,
                timestamp: timestamp,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MediaHistoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MediaHistoryTable,
      MediaHistoryEntry,
      $$MediaHistoryTableFilterComposer,
      $$MediaHistoryTableOrderingComposer,
      $$MediaHistoryTableAnnotationComposer,
      $$MediaHistoryTableCreateCompanionBuilder,
      $$MediaHistoryTableUpdateCompanionBuilder,
      (
        MediaHistoryEntry,
        BaseReferences<_$AppDatabase, $MediaHistoryTable, MediaHistoryEntry>,
      ),
      MediaHistoryEntry,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$LoggedAccountsTableTableManager get loggedAccounts =>
      $$LoggedAccountsTableTableManager(_db, _db.loggedAccounts);
  $$AccountProfileHistoryTableTableManager get accountProfileHistory =>
      $$AccountProfileHistoryTableTableManager(_db, _db.accountProfileHistory);
  $$FollowUsersTableTableManager get followUsers =>
      $$FollowUsersTableTableManager(_db, _db.followUsers);
  $$FollowUsersHistoryTableTableManager get followUsersHistory =>
      $$FollowUsersHistoryTableTableManager(_db, _db.followUsersHistory);
  $$ChangeReportsTableTableManager get changeReports =>
      $$ChangeReportsTableTableManager(_db, _db.changeReports);
  $$MediaHistoryTableTableManager get mediaHistory =>
      $$MediaHistoryTableTableManager(_db, _db.mediaHistory);
}


### FILE: ./services/image_history_service.dart
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import '../main.dart';
import '../models/app_settings.dart';
import '../services/database.dart';
import 'log_service.dart';

final imageHistoryServiceProvider = Provider<ImageHistoryService>((ref) {
  final db = ref.watch(databaseProvider);
  final dio = Dio(
    BaseOptions(
      connectTimeout: const Duration(seconds: 10),
      receiveTimeout: const Duration(seconds: 30),
    ),
  );
  return ImageHistoryService(db, dio);
});

enum MediaType { avatar, banner }

const String _kMediaHistoryDirName = 'media_history';

class ImageHistoryService {
  final AppDatabase _db;
  final Dio _dio;
  String? _basePath;

  ImageHistoryService(this._db, this._dio);

  Future<String> _getMediaHistoryPath() async {
    if (_basePath != null) return _basePath!;

    final supportDir = await getApplicationSupportDirectory();
    final mediaDir = Directory(p.join(supportDir.path, _kMediaHistoryDirName));

    if (!await mediaDir.exists()) {
      await mediaDir.create(recursive: true);
    }
    _basePath = mediaDir.path;
    return _basePath!;
  }

  Future<bool> _downloadImage(String url, String savePath) async {
    try {
      await _dio.download(url, savePath, options: Options());
      return true;
    } on DioException catch (e) {
      logger.e("Image download failed for $url: ${e.message}", error: e);
      try {
        final file = File(savePath);
        if (await file.exists()) {
          await file.delete();
        }
      } catch (_) {}
      return false;
    } catch (e, s) {
      logger.e("Unknown error downloading $url", error: e, stackTrace: s);
      try {
        final file = File(savePath);
        if (await file.exists()) {
          await file.delete();
        }
      } catch (_) {
        logger.w("Failed to delete partially downloaded file at $savePath");
      }
      return false;
    }
  }

  Future<String?> processMediaUpdate({
    required String userId,
    required String ownerId,
    required MediaType mediaType,
    required String? oldUrl,
    required String? newUrl,
    required AppSettings settings,
  }) async {
    String? effectiveNewUrl = newUrl;
    String? effectiveOldUrl = oldUrl;
    const String suffixRegex = r'_(normal|bigger|400x400)';

    if (mediaType == MediaType.avatar) {
      if (settings.avatarQuality == AvatarQuality.low) {
        if (effectiveNewUrl != null) {
          effectiveNewUrl = effectiveNewUrl.replaceFirst(
            RegExp(suffixRegex),
            '_bigger',
          );
        }
        if (effectiveOldUrl != null) {
          effectiveOldUrl = effectiveOldUrl.replaceFirst(
            RegExp(suffixRegex),
            '_bigger',
          );
        }
      } else {
        if (effectiveNewUrl != null) {
          effectiveNewUrl = effectiveNewUrl.replaceFirst(
            RegExp(suffixRegex),
            '_400x400',
          );
        }
        if (effectiveOldUrl != null) {
          effectiveOldUrl = effectiveOldUrl.replaceFirst(
            RegExp(suffixRegex),
            '_400x400',
          );
        }
      }
    }

    final bool shouldSave =
        (mediaType == MediaType.avatar && settings.saveAvatarHistory) ||
        (mediaType == MediaType.banner && settings.saveBannerHistory);
    if (!shouldSave) return null;
    if (effectiveNewUrl == null || effectiveNewUrl.isEmpty) {
      return null;
    }

    logger.i("Change detected for $userId ($mediaType): $effectiveNewUrl");

    final basePath = await _getMediaHistoryPath();
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final fileExtension = p
        .extension(effectiveNewUrl.split('?').first)
        .replaceAll(RegExp(r'[^a-zA-Z0-9]'), '');
    String qualitySuffix = '';
    if (mediaType == MediaType.avatar) {
      // 仅为头像添加质量后缀
      qualitySuffix = (settings.avatarQuality == AvatarQuality.high)
          ? '_high'
          : '_low';
    }
    final fileName =
        '${ownerId}_${userId}_${mediaType.name}_$timestamp$qualitySuffix${fileExtension.isNotEmpty ? fileExtension : '.jpg'}';
    final absoluteSavePath = p.join(basePath, fileName);

    final success = await _downloadImage(effectiveNewUrl, absoluteSavePath);

    if (!success) {
      logger.w("Failed to download $effectiveNewUrl. Aborting history save.");
      return null;
    }

    final relativeFilePath = p.join(_kMediaHistoryDirName, fileName);

    final historyCompanion = MediaHistoryCompanion(
      userId: Value(userId),
      mediaType: Value(mediaType.name),
      localFilePath: Value(relativeFilePath),
      remoteUrl: Value(effectiveNewUrl),
      timestamp: Value(DateTime.now()),
    );
    await _db.insertMediaHistory(historyCompanion);

    // 6. TODO: 在这里实现“清理策略” (saveLatest, saveLastN)

    return relativeFilePath;
  }
}


### FILE: ./services/log_service.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import '../providers/log_provider.dart'; // <--- Import the provider file

// --- 2. Create a custom LogOutput ---
class _RiverpodLogOutput extends LogOutput {

  @override
  void output(OutputEvent event) {
    for (var line in event.lines) {
      
      // --- MODIFICATION: Call the global notifier ---
      // (修改：调用全局 notifier)
      globalLogHistoryNotifier.addLog(line);
      // --- END MODIFICATION ---
    }
  }

}

// --- 3. RESTORE the global logger variable ---
// (恢复全局的 logger 变量)
final logger = Logger(
  printer: SimplePrinter(
    colors: false,
    printTime: true,
  ),

  filter: ProductionFilter(), // ✅ 永远启用日志（新增）

  // (Set the output to *both* Console and our new Notifier)
  output: MultiOutput([
    if (!bool.fromEnvironment('dart.vm.product')) ConsoleOutput(), // ✅ 仅在非 release 下输出到控制台
    _RiverpodLogOutput(), // (This sends to our LogHistoryNotifier)
  ]),
);

// --- 4. REWRITE the loggerProvider ---
// (重写 loggerProvider)
final loggerProvider = Provider<Logger>((ref) {
  // (The provider now just returns the global instance)
  // (provider 现在只返回全局实例)
  return logger;
});


### FILE: ./services/secure_storage_service.dart
import 'package:autonitor/services/log_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

final secureStorageServiceProvider = Provider((ref) => SecureStorageService());

class SecureStorageService {
  final _storage = const FlutterSecureStorage();

  static const _activeAccountIdKey = 'active_account_id';

  /// 保存指定 ID 的 cookie
  Future<void> saveCookie(String id, String cookie) async {
    try {
      // 使用账号 ID 作为 key 的一部分，确保唯一性
      await _storage.write(key: 'cookie_$id', value: cookie);
    } catch (e, s) {
      logger.e("Error saving cookie for ID $id", error: e, stackTrace: s);
      // 可以考虑向上抛出异常，让调用者知道失败了
      // throw Exception('Failed to save cookie: $e');
    }
  }

  /// 读取指定 ID 的 cookie
  Future<String?> getCookie(String id) async {
    try {
      return await _storage.read(key: 'cookie_$id');
    } catch (e, s) {
      logger.e("Error reading cookie for ID $id: $e", error: e, stackTrace: s);
      return null;
    }
  }

  /// 删除指定 ID 的 cookie
  Future<void> deleteCookie(String id) async {
    try {
      await _storage.delete(key: 'cookie_$id');
    } catch (e, s) {
      logger.e("Error deleting cookie for ID $id: $e", error: e, stackTrace: s);
      // 可以考虑向上抛出异常
      // throw Exception('Failed to delete cookie: $e');
    }
  }

  Future<Map<String, String>> getAllCookies() async {
    try {
      // 读取所有 secure storage 中的键值对
      final allValues = await _storage.readAll();
      final Map<String, String> cookies = {};
      // 筛选出以 'cookie_' 开头的键
      allValues.forEach((key, value) {
        if (key.startsWith('cookie_')) {
          // 提取 ID (去掉 'cookie_' 前缀)
          final id = key.substring('cookie_'.length);
          cookies[id] = value;
        }
      });
      return cookies;
    } catch (e, s) {
      logger.e("Error reading all cookies", error: e, stackTrace: s);
      return {}; // 出错时返回空 Map
    }
  }

  Future<String?> readActiveAccountId() async {
    try {
      return await _storage.read(key: _activeAccountIdKey);
    } catch (e, s) {
      logger.e("Error reading active account ID", error: e, stackTrace: s);
      return null;
    }
  }

  Future<void> saveActiveAccountId(String id) async {
    try {
      await _storage.write(key: _activeAccountIdKey, value: id);
    } catch (e, s) {
      logger.e("Error saving active account ID", error: e, stackTrace: s);
    }
  }

  Future<void> deleteActiveAccountId() async {
    try {
      await _storage.delete(key: _activeAccountIdKey);
    } catch (e, s) {
      logger.e("Error deleting active account ID", error: e, stackTrace: s);
    }
  }
}


### FILE: ./services/settings_service.dart
import 'dart:convert'; // 用于 JSON 编解码
import 'package:shared_preferences/shared_preferences.dart'; // 导入插件
import '../models/app_settings.dart';
import 'log_service.dart'; // 导入设置模型

/// 用于加载和保存应用设置的服务类。
class SettingsService {
  // 用于在 shared_preferences 中存储设置的键
  static const _settingsKey = 'app_settings_v1';

  /// 从 shared preferences 加载设置。
  /// 如果找不到或发生错误，则返回默认设置。
  Future<AppSettings> loadSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonString = prefs.getString(_settingsKey);
      if (jsonString != null) {
        // 如果找到了 JSON 字符串，解码并用 fromJson 创建 AppSettings 对象
        final jsonMap = jsonDecode(jsonString) as Map<String, dynamic>;
        return AppSettings.fromJson(jsonMap);
      }
    } catch (e, s) {
      // 记录错误或处理损坏的数据
      logger.e('加载设置时出错: $e', error: e, stackTrace: s);
    }
    // 如果加载失败或不存在设置，则返回默认设置
    return AppSettings();
  }

  /// 将给定的设置保存到 shared preferences。
  Future<void> saveSettings(AppSettings settings) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      // 将 AppSettings 对象用 toJson 转换为 JSON Map，然后编码为字符串
      final jsonString = jsonEncode(settings.toJson());
      // 将 JSON 字符串保存到 shared preferences
      await prefs.setString(_settingsKey, jsonString);
    } catch (e, s) {
      // 记录错误或处理保存失败
      logger.e('Error saving settings: $e', error: e, stackTrace: s);
    }
  }
}


### FILE: ./services/twitter_api_service.dart
import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'log_service.dart';

final twitterApiServiceProvider = Provider((ref) => TwitterApiService());

class TwitterApiService {
  final Dio _dio;

  TwitterApiService() : _dio = Dio() {
    // 在这里可以为 Dio 设置一些基础配置，比如超时时间
    //_dio.options.connectTimeout = const Duration(seconds: 10);
    //_dio.options.receiveTimeout = const Duration(seconds: 10);
  }

  /// 从 Cookie 字符串中解析 'ct0' CSRF token。
  String? _parseCsrfToken(String cookie) {
    try {
      final parts = cookie.split(';');
      final csrfPart = parts.firstWhere(
        (part) => part.trim().startsWith('ct0='),
        orElse: () => '',
      );
      if (csrfPart.isNotEmpty) {
        final token = csrfPart.split('=')[1].trim();
        return token.isNotEmpty ? token : null;
      }
    } catch (e, s) {
      logger.e("Parsing the ct0 token failed: $e", error: e, stackTrace: s);
    }
    return null;
  }

  /// 通过 Rest ID (twid) 获取用户 Profile 信息
  ///
  /// 成功时返回解码后的 JSON Map，失败时抛出异常。
  Future<Map<String, dynamic>> getUserByRestId(
    String userId,
    String cookie,
  ) async {
    final csrfToken = _parseCsrfToken(cookie);
    if (csrfToken == null) {
      throw Exception("Unable to parse x-csrf-token (ct0) from Cookie");
    }

    // 1. 准备 Query Parameters
    final variables = {
      "userId": userId,
      // "withSafetyModeUserFields": true // 可以根据需要添加
    };

    final features = {
      "hidden_profile_subscriptions_enabled": true,
      "responsive_web_graphql_exclude_directive_enabled": true,
      "verified_phone_label_enabled": false,
      "highlights_tweets_tab_ui_enabled": true,
      "creator_subscriptions_tweet_preview_api_enabled": true,
      "responsive_web_graphql_skip_user_profile_image_extensions_enabled":
          false,
      "responsive_web_graphql_timeline_navigation_enabled": true,
      "rweb_tipjar_consumption_enabled": false,
      "subscriptions_feature_can_gift_premium": false,
      "payments_enabled": false,
      "responsive_web_twitter_article_notes_tab_enabled": false,
      "profile_label_improvements_pcf_label_in_post_enabled": false,
      "responsive_web_profile_redirect_enabled": false,
      // ... 可以从您提供的 URL 中复制更多 feature flags
    };

    final queryParameters = {
      'variables': jsonEncode(variables),
      'features': jsonEncode(features),
    };

    // 2. 准备 Headers
    final headers = {
      'authorization':
          'Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA',
      'x-csrf-token': csrfToken,
      'Cookie': cookie,
      // --- 从您命令中复制的其他 Headers ---
      'x-twitter-active-user': 'yes',
      'x-twitter-auth-type': 'OAuth2Session',
      'x-twitter-client-language': 'en',
      // --- 推荐添加的浏览器 Headers ---
      'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36',
      'Referer': 'https://x.com/',
    };

    // 3. 定义 URL
    const String url =
        'https://x.com/i/api/graphql/q9yeu7UlEs2YVx_-Z8Ps7Q/UserByRestId';

    try {
      // 4. 发送 GET 请求
      final response = await _dio.get(
        url,
        queryParameters: queryParameters,
        options: Options(headers: headers),
      );

      // 5. 检查响应并返回数据
      if (response.statusCode == 200 && response.data != null) {
        logger.d("Response data: ${response.data}");
        return response.data as Map<String, dynamic>;
      } else {
        throw Exception('Failed to fetch user information: Status ${response.statusCode}');
      }
    } on DioException catch (e, s) {
      logger.e("Dio Error on getUserByRestId: ${e.response?.data}", error: e, stackTrace: s);
      throw Exception('Network request failed: ${e.message}');
    } catch (e, s) {
      // 捕获其他未知错误
      logger.e("Unknown error on getUserByRestId", error: e, stackTrace: s);
      throw Exception('An unknown error occurred.');
    }
  }
}


### FILE: ./services/twitter_api_v1_service.dart
import 'dart:async';
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'log_service.dart';

final twitterApiV1ServiceProvider = Provider((ref) => TwitterApiV1Service());

class UserListResult {
  final List<Map<String, dynamic>> users;
  final String? nextCursor;
  UserListResult({required this.users, this.nextCursor});
}

class TwitterApiV1Service {
  final Dio _dio;
  // --- 新增：重试相关常量 ---
  static const int _maxRetries = 10000; // 最多重试次数
  static const Duration _retryDelay = Duration(milliseconds: 500); // 每次重试间隔
  // --- 新增结束 ---

  TwitterApiV1Service() : _dio = Dio() {
    _dio.options.connectTimeout = const Duration(seconds: 15);
    _dio.options.receiveTimeout = const Duration(seconds: 15);
    // 阻止 Dio 因为 404 抛出异常，我们手动检查状态码
    _dio.options.validateStatus = (status) {
      return status != null && (status >= 200 && status < 300 || status == 404);
    };
  }

  String? _parseCsrfToken(String cookie) {
    try {
      final parts = cookie.split(';');
      final csrfPart = parts.firstWhere(
        (part) => part.trim().startsWith('ct0='),
        orElse: () => '',
      );
      if (csrfPart.isNotEmpty) {
        final token = csrfPart.split('=')[1].trim();
        return token.isNotEmpty ? token : null;
      }
    } catch (e, s) {
      logger.e("TwitterApiV1Service: Failed to parse ct0 token: $e", error: e, stackTrace: s);
    }
    return null;
  }

  Future<UserListResult> _fetchList(
    String endpoint,
    String userId,
    String cookie,
    String? cursor,
    int count,
    String listTypeLogName,
  ) async {
    final Map<String, dynamic> queryParameters = {
      'include_profile_interstitial_type': 0, 'include_blocking': 0,
      'include_blocked_by': 0, 'include_followed_by': 1,
      'include_want_retweets': 0, 'include_mute_edge': 0,
      'include_can_dm': 1, 'include_can_media_tag': 1,
      'include_ext_is_blue_verified': 1, 'include_ext_verified_type': 1,
      'include_ext_profile_image_shape': 0, 'skip_status': 1,
      'user_id': userId, 'count': count,
      // 'with_total_count': true, // Removed based on previous step
    };
    if (cursor != null && cursor != '0') {
      queryParameters['cursor'] = cursor;
    } else if (cursor == null) {
      queryParameters['cursor'] = "-1";
    }

    final csrfToken = _parseCsrfToken(cookie);
    if (csrfToken == null) {
      logger.e(
        "TwitterApiV1Service: FATAL - ct0 token not found in cookie for $listTypeLogName.",
      );
      throw Exception("Cannot get ct0 token from cookie (x-csrf-token)");
    }

    final headers = {
      'accept': '*/*',
      'authorization':
          'Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA',
      'Cookie': cookie,
      'dnt': '1',
      'priority': 'u=1, i',
      'sec-ch-ua':
          '"Not)A;Brand";v="8", "Chromium";v="138", "Google Chrome";v="138"',
      'sec-ch-ua-mobile': '?0',
      'sec-ch-ua-platform': '"Linux"',
      'sec-fetch-dest': 'empty',
      'sec-fetch-mode': 'cors',
      'sec-fetch-site': 'same-origin',
      'user-agent':
          'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36',
      'x-csrf-token': csrfToken,
      'x-twitter-active-user': 'yes',
      'x-twitter-auth-type': 'OAuth2Session',
      'x-twitter-client-language': 'en',
      'Referer': 'https://x.com/',
    };

    int attempt = 0;
    while (attempt <= _maxRetries) {
      attempt++;
      logger.d(
        "TwitterApiV1Service: Fetching $listTypeLogName for $userId with cursor ${queryParameters['cursor']} (Attempt $attempt/$_maxRetries)...",
      );

      try {
        final response = await _dio.get(
          endpoint,
          queryParameters: queryParameters,
          options: Options(headers: headers),
        );

        // --- 手动检查状态码 ---
        if (response.statusCode == 200 && response.data != null) {
          if (response.data is Map<String, dynamic>) {
            final Map<String, dynamic> data = response.data;
            final List<dynamic> userList = data['users'] ?? [];
            final dynamic nextCursorValue =
                data['next_cursor'] ?? data['next_cursor_str'];
            final String? nextCursor = nextCursorValue?.toString();
            final List<Map<String, dynamic>> usersMapList = userList
                .map((user) => user as Map<String, dynamic>)
                .toList();
            return UserListResult(
              users: usersMapList,
              nextCursor: nextCursor,
            ); // 成功，返回结果
          } else {
            _logAndThrow(
              "Error fetching $listTypeLogName - Unexpected response format: ${response.data}",
            );
          }
        } else if (response.statusCode == 404) {
          _log(
            "Warning: Received 404 fetching $listTypeLogName (Attempt $attempt). Retrying in ${_retryDelay.inSeconds}s...",
          );
          if (attempt >= _maxRetries) {
            _logAndThrow(
              "Failed fetching $listTypeLogName after $_maxRetries attempts (404).",
            );
          }
          await Future.delayed(_retryDelay); // 等待后重试
          continue; // 继续下一次循环尝试
        } else if (response.statusCode == 403) {
          _logAndThrow(
            'Authorization failed (403). Headers or Cookie might be incorrect/expired.',
          );
        } else if (response.statusCode == 429) {
          _logAndThrow('Rate limit exceeded (429). Please wait and try again.');
        } else {
          // 其他 4xx 错误通常不可重试
          _logAndThrow(
            'Failed to fetch $listTypeLogName: Status ${response.statusCode}, Data: ${response.data}',
          );
        }
        // --- 检查结束 ---
      } on DioException catch (e) {
        // DioException 现在主要捕获 5xx 服务器错误或连接超时等
        _log(
          "DioError fetching $listTypeLogName (Attempt $attempt): ${e.message}. Retrying in ${_retryDelay.inSeconds}s...",
        );
        if (attempt >= _maxRetries) {
          _logAndThrow(
            "Failed fetching $listTypeLogName after $_maxRetries attempts (Network/Server Error): ${e.message}",
          );
        }
        await Future.delayed(_retryDelay); // 等待后重试
        continue; // 继续下一次循环尝试
      } catch (e) {
        // 捕获其他未知错误 (例如 JSON 解析错误)
        _log(
          "Unknown error fetching $listTypeLogName (Attempt $attempt): $e. Retrying in ${_retryDelay.inSeconds}s...",
        );
        if (attempt >= _maxRetries) {
          _logAndThrow(
            "Failed fetching $listTypeLogName after $_maxRetries attempts (Unknown Error): $e",
          );
        }
        await Future.delayed(_retryDelay); // 等待后重试
        continue; // 继续下一次循环尝试
      }
    }
    // 如果循环结束还没有返回，说明发生意外情况
    throw Exception('Failed to fetch $listTypeLogName after multiple retries.');
  }

  // --- 辅助方法用于日志记录和抛出异常 ---
  void _log(String message) {
    logger.d("TwitterApiV1Service: $message");
  }

  Never _logAndThrow(String errorMessage) {
    logger.e("TwitterApiV1Service: $errorMessage", error: Exception(errorMessage), stackTrace: StackTrace.current);
    throw Exception(errorMessage); // 抛出异常中断执行
  }
  // --- 辅助方法结束 ---

  Future<UserListResult> getFollowers(
    String userId,
    String cookie, {
    String? cursor,
    int count = 200,
  }) async {
    return _fetchList(
      'https://x.com/i/api/1.1/followers/list.json',
      userId,
      cookie,
      cursor,
      count,
      'followers',
    );
  }

  Future<UserListResult> getFollowing(
    String userId,
    String cookie, {
    String? cursor,
    int count = 200,
  }) async {
    return _fetchList(
      'https://x.com/i/api/1.1/friends/list.json',
      userId,
      cookie,
      cursor,
      count,
      'following',
    );
  }
}


### FILE: ./ui/accounts_page.dart
import 'package:autonitor/ui/auth/webview_login_page.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/auth_provider.dart';
import '../l10n/app_localizations.dart';
import '../models/account.dart';
import 'package:flutter/services.dart';

import '../services/log_service.dart';

class AccountsPage extends ConsumerStatefulWidget {
  const AccountsPage({super.key});

  @override
  ConsumerState<AccountsPage> createState() => _AccountsPageState();
}

class _AccountsPageState extends ConsumerState<AccountsPage> {
  bool _isRefreshing = false;

  Future<void> _navigateAndAddAccount(BuildContext context) async {
    final source = await _showLoginOptions(context);
    if (source == null) return;

    String? cookie;
    if (source == 'browser') {
      cookie = await Navigator.push<String>(
        context,
        MaterialPageRoute(builder: (_) => const WebViewLoginPage()),
      );
    } else if (source == 'manual') {
      cookie = await _showManualInputDialog(context);
    }

    if (cookie != null && cookie.isNotEmpty) {
      await _handleLogin(cookie);
    }
  }

  Future<void> _confirmAndDelete(Account account) async {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(
          l10n.delete,
          style: TextStyle(color: theme.colorScheme.onPrimaryContainer),
        ),
        content: Text(l10n.confirm_delete_account(account.id)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
            onPressed: () => Navigator.pop(context, true),
            child: Text(l10n.delete),
          ),
        ],
      ),
    );
    if (confirmed == true && mounted) {
      ref.read(accountsProvider.notifier).removeAccount(account.id);
    }
  }

  Future<String?> _showLoginOptions(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.choose_login_method),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, 'manual'),
            child: Text(l10n.manual_cookie),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, 'browser'),
            child: Text(l10n.browser_login),
          ),
        ],
      ),
    );
  }

  Future<String?> _showManualInputDialog(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final controller = TextEditingController();
    return showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.manual_cookie),
        content: TextField(controller: controller, maxLines: 5),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(l10n.cancel),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, controller.text),
            child: Text(l10n.ok),
          ),
        ],
      ),
    );
  }

  Future<void> _handleLogin(String cookie) async {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final currentContext = context;
    showDialog(
      context: currentContext,
      barrierDismissible: false,
      builder: (dialogContext) => PopScope(
        canPop: false,
        child: AlertDialog(
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text(l10n.saving_account),
            ],
          ),
        ),
      ),
    );
    try {
      await ref.read(accountsProvider.notifier).addAccount(cookie);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              l10n.account_added_successfully,
              style: TextStyle(color: theme.colorScheme.onPrimaryContainer),
            ),
            backgroundColor: theme.colorScheme.primaryContainer,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              "$e",
              style: TextStyle(color: theme.colorScheme.onError),
            ),
            backgroundColor: theme.colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        Navigator.pop(currentContext);
      }
    }
  }

  Future<void> _refreshAllAccounts() async {
    if (_isRefreshing) return;

    // --- 获取 Theme 和 l10n ---
    final theme = Theme.of(context);
    // final l10n = AppLocalizations.of(context)!; // Keep if you add l10n later

    setState(() => _isRefreshing = true);
    final currentContext = context;
    final scaffoldMessenger = ScaffoldMessenger.of(currentContext);

    // --- 新增：显示模态加载对话框 ---
    showDialog(
      context: currentContext,
      barrierDismissible: false,
      builder: (dialogContext) => PopScope(
        canPop: false,
        child: AlertDialog(
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text('Refreshing accounts...'), // Add l10n later
            ],
          ),
        ),
      ),
    );

    try {
      final accountsToRefresh = ref.read(accountsProvider);
      if (accountsToRefresh.isEmpty) {
        if (mounted) {
        // --- 修改 SnackBar 样式 ---
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(
              'No accounts to refresh.', // Add l10n later
              style: TextStyle(
                color: theme.colorScheme.onSecondaryContainer,
              ), // 信息文本颜色
            ),
            backgroundColor: theme.colorScheme.secondaryContainer, // 信息背景颜色
          ),
        );
        }
        // 注意：因为没有异步操作，需要在这里手动关闭对话框
        if (mounted) Navigator.pop(currentContext);
        setState(() => _isRefreshing = false); // 别忘了重置状态
        return;
      }

      final results = await ref
          .read(accountsProvider.notifier)
          .refreshAllAccountProfiles(accountsToRefresh);

      // 刷新完成后，先重新加载数据
      if (mounted) {
        await ref.read(accountsProvider.notifier).loadAccounts();
      }

      // 处理结果并显示总结 SnackBar
      int successCount = results.where((r) => r.success).length;
      int failureCount = results.length - successCount;
      String summary =
          'Refresh complete: $successCount succeeded'; // Add l10n later
      bool hasFailures = failureCount > 0;
      if (hasFailures) {
        summary += ', $failureCount failed.'; // Add l10n later
        results.where((r) => !r.success).forEach((failure) {
          logger.e("Refresh failed for ${failure.accountId}: ${failure.error}", error: Exception(failure.error), stackTrace: StackTrace.current);
        });
      }
      // --- 修改 SnackBar 样式 ---
      if (mounted) {
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text(
            summary,
            // 根据是否有失败使用不同颜色
            style: TextStyle(
              color: hasFailures
                  ? theme.colorScheme.onErrorContainer
                  : theme.colorScheme.onSecondaryContainer,
            ),
          ),
          backgroundColor: hasFailures
              ? theme.colorScheme.errorContainer
              : theme.colorScheme.secondaryContainer,
        ),
      );
      }
    } catch (e, s) {
      logger.e("Error during _refreshAllAccounts UI call: $e", error: e, stackTrace: s);
      // --- 修改 SnackBar 样式 ---
      if (mounted) {
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text(
            'An unexpected error occurred during refresh.', // Add l10n later
            style: TextStyle(color: theme.colorScheme.onError), // 错误文本颜色
          ),
          backgroundColor: theme.colorScheme.error, // 错误背景颜色
        ),
      );
      }
    } finally {
      // 确保无论如何都重置状态并关闭对话框
      if (mounted) {
        // 关闭模态对话框
        Navigator.pop(currentContext);
        // 重置刷新状态
        setState(() => _isRefreshing = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final accounts = ref.watch(accountsProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.accounts),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            tooltip: 'Refresh All Profiles', // Add l10n later
            onPressed: _isRefreshing ? null : _refreshAllAccounts,
          ),
        ],
      ),
      body: ListView.builder(
        itemCount: accounts.length + 1,
        itemBuilder: (context, index) {
          if (index == 0) {
            return Card(
              margin: const EdgeInsets.all(8.0),
              child: ListTile(
                leading: const Icon(Icons.add_circle_outline),
                title: Text(l10n.new_account),
                onTap: () => _navigateAndAddAccount(context),
              ),
            );
          }
          final account = accounts[index - 1];

          return Card(
            margin: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
            child: ListTile(
              leading: CircleAvatar(
                radius: 24,
                backgroundColor: Colors.transparent,
                child: Stack(
                  alignment: Alignment.center,
                  children: [
                    const Icon(Icons.person, size: 24),
                    if (account.avatarUrl != null &&
                        account.avatarUrl!.isNotEmpty)
                      ClipOval(
                        child: CachedNetworkImage(
                          imageUrl: account.avatarUrl!,
                          fit: BoxFit.cover,
                          width: 48,
                          height: 48,
                          fadeInDuration: const Duration(milliseconds: 300),
                          fadeOutDuration: const Duration(milliseconds: 100),
                          errorWidget: (context, url, error) =>
                              const SizedBox(),
                        ),
                      ),
                  ],
                ),
              ),
              title: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    account.name ?? 'Unknown Name',
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    "@${account.screenName ?? account.id}",
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Colors.grey.shade600,
                    ),
                  ),
                  Text(
                    "ID: ${account.id}",
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Colors.grey.shade600,
                    ),
                  ),
                ],
              ),
              trailing: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  IconButton(
                    icon: const Icon(Icons.cookie_outlined),
                    tooltip: l10n.view_cookie,
                    onPressed: () {
                      final theme = Theme.of(context);
                      final l10n = AppLocalizations.of(context)!;
                      showDialog(
                        context: context,
                        builder: (dialogContext) => AlertDialog(
                          title: Text(l10n.cookie),
                          content: Container(
                            width: double.maxFinite,
                            constraints: BoxConstraints(
                              maxHeight:
                                  MediaQuery.of(context).size.height * 0.6,
                            ),
                            decoration: BoxDecoration(
                              color: theme.colorScheme.surfaceContainerHighest,
                              borderRadius: BorderRadius.circular(8.0),
                            ),
                            child: SingleChildScrollView(
                              padding: const EdgeInsets.all(8.0),
                              child: TextField(
                                controller: TextEditingController(
                                  text: account.cookie,
                                ),
                                readOnly: true,
                                maxLines: null,
                                decoration: InputDecoration.collapsed(
                                  hintText: null,
                                ),
                                style: TextStyle(
                                  fontFamily: 'monospace',
                                  fontSize: 12,
                                  color: theme.colorScheme.onSurfaceVariant,
                                ),
                              ),
                            ),
                          ),
                          actions: [
                            TextButton(
                              child: Text(l10n.copy),
                              onPressed: () {
                                Clipboard.setData(
                                  ClipboardData(text: account.cookie),
                                );
                                Navigator.pop(dialogContext);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      l10n.copied_to_clipboard,
                                      style: TextStyle(
                                        color: theme
                                            .colorScheme
                                            .onPrimaryContainer,
                                      ),
                                    ),
                                    backgroundColor:
                                        theme.colorScheme.primaryContainer,
                                  ),
                                );
                              },
                            ),
                            ElevatedButton(
                              onPressed: () => Navigator.pop(dialogContext),
                              child: Text(l10n.ok),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                  IconButton(
                    icon: Icon(
                      Icons.delete_outline,
                      color: Theme.of(context).colorScheme.error,
                    ),
                    tooltip: l10n.delete,
                    onPressed: () {
                      _confirmAndDelete(account);
                    },
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}


### FILE: ./ui/auth/package.flutter/material.dart
// TODO Implement this library.


### FILE: ./ui/auth/webview_login_page.dart
import 'package:autonitor/services/log_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import '../../l10n/app_localizations.dart';

class WebViewLoginPage extends StatefulWidget {
  const WebViewLoginPage({super.key});

  @override
  State<WebViewLoginPage> createState() => _WebViewLoginPageState();
}

class _WebViewLoginPageState extends State<WebViewLoginPage> {
  final Uri _url = Uri.parse('https://x.com/login');
  final CookieManager _cookieManager = CookieManager.instance();

  bool _hasFoundAuthTokenInLastCheck = false;

  Future<void> _onLoginComplete() async {
    if (!mounted) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) =>
          const Center(child: CircularProgressIndicator(strokeWidth: 2)),
    );

    try {
      final WebUri targetUrl = WebUri("https://x.com");

      List<Cookie> gotCookies; // 将 gotCookies 提到 try 块之前

      try {
        // 尝试获取 cookie
        gotCookies = await _cookieManager.getCookies(url: targetUrl);
      } catch (e, s) {
        // --- 修改点 1：捕获所有 Error 和 Exception ---
        // [已修改] 捕获 *所有* 异常和错误 (StateError, PlatformException, Error, etc.)
        // 只要 getCookies 失败，就视为空列表，让后续逻辑处理 "No cookie found" 提示。
        logger.e(
          "Error during getCookies, treating as empty list: $e\n$s",
          error: e,
          stackTrace: s,
        );
        gotCookies = []; // 手动设置为空列表
      }

      // 先关闭加载圈
      if (!mounted) return;
      // 这一行现在是安全的，因为内部的catch会捕获所有错误
      Navigator.pop(context);

      // 检查 cookie 是否存在 (现在的 gotCookies 可能是 [] 了)
      if (gotCookies.isEmpty) {
        if (!mounted) return;
        final l10n = AppLocalizations.of(context)!;
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text(l10n.no_cookie_found)));
        return;
      }

      // 是否有 auth_token
      final bool hasAuthToken = gotCookies.any((c) => c.name == 'auth_token');
      _hasFoundAuthTokenInLastCheck = hasAuthToken;

      if (!hasAuthToken) {
        if (!mounted) return;
        final l10n = AppLocalizations.of(context)!;
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text(l10n.no_auth_token_found)));
        return;
      }

      // 构造 cookie 字符串
      final String finalCookieString = gotCookies
          .map((c) => '${c.name}=${c.value}')
          .join('; ');

      // 弹出确认框
      if (!mounted) return;
      final l10n = AppLocalizations.of(context)!;
      final bool? isConfirmed = await showDialog<bool>(
        context: context,
        builder: (context) {
          return AlertDialog(
            title: Text(l10n.cookie),
            content: SingleChildScrollView(
              child: SelectableText(
                finalCookieString,
                style: const TextStyle(fontSize: 12),
              ),
            ),
            actions: [
              TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.pop(context, false),
              ),
              ElevatedButton(
                child: Text(l10n.ok),
                onPressed: () => Navigator.pop(context, true),
              ),
            ],
          );
        },
      );

      if (isConfirmed == true && mounted) {
        Navigator.pop(context, finalCookieString);
      }
    } catch (e, s) {
      // --- 修改点 2：捕获所有 Error 和 Exception ---
      logger.e(
        "Unhandled error in _onLoginComplete: $e\n$s",
        error: e,
        stackTrace: s,
      );
      if (mounted) {
        Navigator.pop(context);
      } // 关闭加载圈
      if (mounted) {
        // 其他未预料到的错误仍会在这里显示
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text("$e")));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.browser_login),
        actions: [
          if (_hasFoundAuthTokenInLastCheck)
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: Tooltip(
                message: l10n.found_auth_token_last_check,
                child: const Icon(Icons.check_circle, color: Colors.green),
              ),
            ),
          TextButton(
            onPressed: _onLoginComplete,
            child: Text(l10n.im_logged_in),
          ),
        ],
      ),
      body: InAppWebView(
        initialUrlRequest: URLRequest(url: WebUri.uri(_url)),
        initialSettings: InAppWebViewSettings(
          clearSessionCache: true,
          clearCache: true,
        ),
      ),
    );
  }
}


### FILE: ./ui/commits_page.dart
import 'package:flutter/material.dart';
import '../l10n/app_localizations.dart';

class CommitsPage extends StatelessWidget {
  const CommitsPage({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      // 3. 添加 AppBar
      appBar: AppBar(title: Text(l10n.data)),
      body: const Center(child: Text('Data Page - Coming Soon')),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // TODO: 在这里添加点击搜索按钮的逻辑
        },
        child: const Icon(Icons.search),
      ),
    );
  }
}


### FILE: ./ui/home_page.dart
import 'package:autonitor/services/log_service.dart';
import 'package:autonitor/ui/user_detail_page.dart';
import 'package:autonitor/models/twitter_user.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:autonitor/models/cache_data.dart';
import 'package:autonitor/providers/auth_provider.dart';
import 'package:autonitor/ui/user_list_page.dart';
import '../l10n/app_localizations.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../providers/report_providers.dart';
import '../providers/analysis_provider.dart';

// Providers (cacheProvider, userListProvider) 现在在 auth_provider.dart 中定义

class HomePage extends ConsumerStatefulWidget {
  final VoidCallback onNavigateToAccounts;
  const HomePage({super.key, required this.onNavigateToAccounts});
  @override
  ConsumerState<HomePage> createState() => _HomePageState();
}

class _HomePageState extends ConsumerState<HomePage> {
  // 辅助方法：格式化 ISO 8601 时间字符串
  String _getFormattedLastUpdate(
    BuildContext context,
    AppLocalizations l10n,
    String isoString,
  ) {
    if (isoString.isEmpty) {
      return l10n.last_updated_at("N/A");
    }
    try {
      final dateTime = DateTime.parse(isoString).toLocal();
      // 格式: YYYY-MM-DD HH:MM
      final formattedDate =
          "${dateTime.year.toString().padLeft(4, '0')}-"
          "${dateTime.month.toString().padLeft(2, '0')}-"
          "${dateTime.day.toString().padLeft(2, '0')} "
          "${dateTime.hour.toString().padLeft(2, '0')}:"
          "${dateTime.minute.toString().padLeft(2, '0')}";
      return l10n.last_updated_at(formattedDate);
    } catch (e, s) {
      logger.e("Error parsing lastUpdateTime: $e", error: e, stackTrace: s);
      return l10n.last_updated_at("Invalid Date");
    }
  }

  void _showAccountSwitcher(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final allAccounts = ref.read(accountsProvider);
    final activeAccount = ref.read(activeAccountProvider);
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return ListView(
          shrinkWrap: true,
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Text(
                l10n.switch_account,
                style: Theme.of(context).textTheme.titleLarge,
              ),
            ),
            ...allAccounts.map((account) {
              return ListTile(
                leading: SizedBox(
                  width: 48,
                  height: 48,
                  child: Stack(
                    alignment: Alignment.center,
                    children: [
                      Container(
                        alignment: Alignment.center,
                        child: const Icon(Icons.person, size: 24),
                      ),
                      if (account.avatarUrl != null &&
                          account.avatarUrl!.isNotEmpty)
                        ClipOval(
                          child: CachedNetworkImage(
                            imageUrl: account.avatarUrl!,
                            fadeInDuration: const Duration(milliseconds: 300),
                            placeholder: (context, url) =>
                                const SizedBox.shrink(),
                            errorWidget: (context, url, error) =>
                                const SizedBox.shrink(),
                            imageBuilder: (context, imageProvider) => Container(
                              width: 48,
                              height: 48,
                              decoration: BoxDecoration(
                                image: DecorationImage(
                                  image: imageProvider,
                                  fit: BoxFit.cover,
                                ),
                              ),
                            ),
                          ),
                        ),
                      if (account.id == activeAccount?.id)
                        Positioned(
                          right: 0,
                          bottom: 0,
                          child: Container(
                            width: 18,
                            height: 18,
                            decoration: const BoxDecoration(
                              color: Colors.white,
                              shape: BoxShape.circle,
                            ),
                            child: const Icon(
                              Icons.check_circle,
                              color: Colors.green,
                              size: 16,
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
                title: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      account.name ?? 'Unknown Name',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      "@${account.screenName ?? account.id}",
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Colors.grey.shade600,
                      ),
                    ),
                    Text(
                      "ID: ${account.id}",
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Colors.grey.shade600,
                      ),
                    ),
                  ],
                ),
                trailing: null,
                onTap: () {
                  ref.read(activeAccountProvider.notifier).setActive(account);
                  Navigator.pop(context);
                },
              );
            }),
          ],
        );
      },
    );
  }

  Future<void> _navigateToUserList(
    BuildContext context,
    String categoryKey,
  ) async {
    final activeAccount = ref.read(activeAccountProvider);
    if (activeAccount == null) return;
    logger.i(
      '--- HomePage: Navigating to UserListPage for category $categoryKey ---',
    );
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) =>
            UserListPage(ownerId: activeAccount.id, categoryKey: categoryKey),
      ),
    );
  }

  Widget _buildNoAccountState(BuildContext context, VoidCallback onNavigate) {
    final l10n = AppLocalizations.of(context)!;
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.group_outlined, size: 64, color: Colors.grey.shade400),
            const SizedBox(height: 24),
            Text(
              l10n.login_first,
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(l10n.login_first_description, textAlign: TextAlign.center),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              icon: const Icon(Icons.login),
              label: Text(l10n.log_in),
              onPressed: onNavigate,
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 12,
                ),
                textStyle: Theme.of(context).textTheme.titleMedium,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAccountView(BuildContext context) {
    final cacheAsyncValue = ref.watch(cacheProvider);
    return cacheAsyncValue.when(
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('加载缓存失败: $err')),
      data: (cacheData) {
        if (cacheData == null) {
          return _buildEmptyCacheState(context);
        }
        return _buildDataDisplay(context, cacheData);
      },
    );
  }

  Widget _buildEmptyCacheState(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(l10n.no_analysis_data),
          const SizedBox(height: 20),
          ElevatedButton.icon(
            icon: const Icon(Icons.sync),
            onPressed: () => ref.invalidate(cacheProvider),
            label: Text(l10n.run_analysis_now),
          ),
        ],
      ),
    );
  }

  Widget _buildDataDisplay(BuildContext context, CacheData cache) {
    final l10n = AppLocalizations.of(context)!;
    final activeAccount = ref.watch(activeAccountProvider);
    return RefreshIndicator(
      onRefresh: () async => ref.invalidate(cacheProvider),
      child: ListView(
        padding: const EdgeInsets.all(16.0),
        children: <Widget>[
          Card(
            clipBehavior: Clip.antiAlias,
            margin: EdgeInsets.zero,
            child: InkWell(
              onTap: () {
                if (activeAccount == null) return;
                final user = TwitterUser(
                  avatarUrl: activeAccount.avatarUrl ?? '',
                  avatarLocalPath: activeAccount.avatarLocalPath ?? '',
                  bannerLocalPath: activeAccount.bannerLocalPath ?? '',
                  name: activeAccount.name ?? 'Unknown',
                  id: activeAccount.screenName ?? activeAccount.id,
                  restId: activeAccount.id,
                  joinTime: activeAccount.joinTime ?? '',
                  bio: activeAccount.bio,
                  location: activeAccount.location,
                  bannerUrl: activeAccount.bannerUrl,
                  link: activeAccount.link,
                  followersCount: activeAccount.followersCount,
                  followingCount: activeAccount.followingCount,
                  statusesCount: activeAccount.statusesCount,
                  mediaCount: activeAccount.mediaCount,
                  favouritesCount: activeAccount.favouritesCount,
                  listedCount: activeAccount.listedCount,
                  latestRawJson: activeAccount.latestRawJson,
                  isProtected: activeAccount.isProtected,
                  isVerified: activeAccount.isVerified,
                );
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => UserDetailPage(user: user, ownerId: activeAccount.id),
                  ),
                );
              },
              child: Column(
                children: [
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
                    child: Row(
                      children: [
                        Hero(
                          tag: 'avatar_${activeAccount?.id}',
                          child: CircleAvatar(
                            radius: 24,
                            backgroundColor: Colors.transparent,
                            child: Stack(
                              alignment: Alignment.center,
                              children: [
                                const Icon(Icons.person, size: 24),
                                if (activeAccount?.avatarUrl != null &&
                                    activeAccount!.avatarUrl!.isNotEmpty)
                                  ClipOval(
                                    child: CachedNetworkImage(
                                      imageUrl: activeAccount.avatarUrl!,
                                      fit: BoxFit.cover,
                                      width: 48,
                                      height: 48,
                                      fadeInDuration: const Duration(
                                        milliseconds: 300,
                                      ),
                                      fadeOutDuration: const Duration(
                                        milliseconds: 100,
                                      ),
                                      errorWidget: (context, url, error) =>
                                          const SizedBox(),
                                    ),
                                  ),
                              ],
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                activeAccount?.name ?? 'Unknown Name',
                                style: Theme.of(context).textTheme.titleMedium
                                    ?.copyWith(fontWeight: FontWeight.bold),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                              Text(
                                "@${activeAccount?.screenName ?? activeAccount?.id ?? '...'}",
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(color: Colors.grey.shade600),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                              Text(
                                "ID: ${activeAccount?.id ?? '...'}",
                                style: Theme.of(context).textTheme.bodySmall
                                    ?.copyWith(color: Colors.grey.shade600),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ],
                          ),
                        ),
                        IconButton(
                          icon: const Icon(Icons.swap_horiz),
                          tooltip: l10n.switch_account,
                          onPressed: () => _showAccountSwitcher(context),
                        ),
                      ],
                    ),
                  ),
                  const Divider(height: 1, indent: 0, endIndent: 0),
                  IntrinsicHeight(
                    child: Row(
                      children: [
                        Expanded(
                          child: InkWell(
                            onTap: () =>
                                _navigateToUserList(context, 'following'),
                            child: Padding(
                              padding: const EdgeInsets.symmetric(
                                vertical: 12.0,
                              ),
                              child: Column(
                                children: [
                                  Text(
                                    cache.followingCount.toString(),
                                    style: Theme.of(context)
                                        .textTheme
                                        .titleMedium
                                        ?.copyWith(fontWeight: FontWeight.bold),
                                  ),
                                  const SizedBox(height: 2),
                                  Text(
                                    l10n.following,
                                    style: Theme.of(
                                      context,
                                    ).textTheme.bodySmall,
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                        const VerticalDivider(width: 1),
                        Expanded(
                          child: InkWell(
                            onTap: () =>
                                _navigateToUserList(context, 'followers'),
                            child: Padding(
                              padding: const EdgeInsets.symmetric(
                                vertical: 12.0,
                              ),
                              child: Column(
                                children: [
                                  Text(
                                    cache.followersCount.toString(),
                                    style: Theme.of(context)
                                        .textTheme
                                        .titleMedium
                                        ?.copyWith(fontWeight: FontWeight.bold),
                                  ),
                                  const SizedBox(height: 2),
                                  Text(
                                    l10n.followers,
                                    style: Theme.of(
                                      context,
                                    ).textTheme.bodySmall,
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 24),
          Card(
            margin: EdgeInsets.zero,
            child: Column(
              children: [
                _buildDetailListItem(
                  context,
                  'normal_unfollowed',
                  Icons.person_remove_outlined,
                  l10n.normal_unfollowed,
                  cache.unfollowedCount,
                ),
                _buildDetailListItem(
                  context,
                  'mutual_unfollowed',
                  Icons.group_off_rounded,
                  l10n.mutual_unfollowed,
                  cache.mutualUnfollowedCount,
                ),
                _buildDetailListItem(
                  context,
                  'oneway_unfollowed',
                  Icons.group_off_outlined,
                  l10n.oneway_unfollowed,
                  cache.singleUnfollowedCount,
                ),
                _buildDetailListItem(
                  context,
                  'temporarily_restricted',
                  Icons.warning_amber_rounded,
                  l10n.temporarily_restricted,
                  cache.temporarilyRestrictedCount,
                ),
                _buildDetailListItem(
                  context,
                  'suspended',
                  Icons.lock_outline,
                  l10n.suspended,
                  cache.frozenCount,
                ),
                _buildDetailListItem(
                  context,
                  'deactivated',
                  Icons.no_accounts_outlined,
                  l10n.deactivated,
                  cache.deactivatedCount,
                ),
                _buildDetailListItem(
                  context,
                  'be_followed_back',
                  Icons.group_add_outlined,
                  l10n.be_followed_back,
                  cache.refollowedCount,
                ),
                _buildDetailListItem(
                  context,
                  'new_followers_following',
                  Icons.person_add_alt_1_outlined,
                  l10n.new_followers_following,
                  cache.newFollowersCount,
                  showDivider: false,
                ),
              ],
            ),
          ),
          const SizedBox(height: 80),

          // --- 新增：上次更新时间 ---
          Padding(
            padding: const EdgeInsets.only(top: 8.0, bottom: 16.0),
            child: Center(
              child: Text(
                _getFormattedLastUpdate(context, l10n, cache.lastUpdateTime),
                style: Theme.of(
                  context,
                ).textTheme.bodySmall?.copyWith(color: Colors.grey.shade600),
              ),
            ),
          ),
          // --- 新增结束 ---
        ],
      ),
    );
  }

  Widget _buildDetailListItem(
    BuildContext context,
    String categoryKey,
    IconData icon,
    String label,
    int count, {
    bool showDivider = true,
  }) {
    return InkWell(
      onTap: () => _navigateToUserList(context, categoryKey),
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: 16.0,
              vertical: 12.0,
            ),
            child: Row(
              children: [
                Icon(icon, color: Theme.of(context).colorScheme.primary),
                const SizedBox(width: 16),
                Expanded(
                  child: Text(
                    label,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                ),
                Text(
                  count.toString(),
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: Theme.of(context).colorScheme.secondary,
                  ),
                ),
                const SizedBox(width: 8),
                const Icon(Icons.chevron_right, color: Colors.grey),
              ],
            ),
          ),
          if (showDivider) const Divider(height: 1, indent: 56),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final activeAccount = ref.watch(activeAccountProvider);
    return Scaffold(
      appBar: AppBar(title: Text(l10n.app_title)),
      body: activeAccount == null
          ? _buildNoAccountState(context, widget.onNavigateToAccounts)
          : _buildAccountView(context),
      floatingActionButton: activeAccount == null
          ? null
          : FloatingActionButton.extended(
              onPressed: () async {
                final currentContext = context;
                final currentRef = ref;
                final currentL10n = AppLocalizations.of(currentContext)!;
                final currentTheme = Theme.of(currentContext);

                // --- 修改：在 showDialog 之前启动分析 ---
                // (这将立即设置 analysisIsRunningProvider 为 true)
                // (并且异步执行，不会阻塞 UI)
                // 我们在 try/catch 之外调用它，因为日志对话框会处理自己的错误
                // 确保 accountToProcess 在调用前被检查
                final accountToProcess = currentRef.read(activeAccountProvider);
                if (accountToProcess == null) {
                  ScaffoldMessenger.of(currentContext).showSnackBar(
                    SnackBar(
                      content: Text(
                        currentL10n.no_active_account_error,
                        style: TextStyle(
                          color: currentTheme.colorScheme.onError,
                        ),
                      ),
                      backgroundColor: currentTheme.colorScheme.error,
                    ),
                  );
                  return; // 没有活动账号，不执行
                }

                // 异步调用，但不等待它
                // 我们将通过 analysisIsRunningProvider 观察它的完成
                currentRef
                    .read(analysisServiceProvider.notifier)
                    .runAnalysis(accountToProcess)
                    .catchError((e, s) {
                      // 即使在 provider 中捕获了错误，这里也可能需要一个顶层捕获
                      // 以防 runAnalysisProcess 本身抛出（例如 accountToProcess 为 null）
                      // 已经在 provider 内部处理了
                      logger.e(
                        "runAnalysisProcess top-level error (should be handled in Notifier): $e",
                        error: e,
                        stackTrace: s,
                      );
                    })
                    .whenComplete(() {
                      // 无论成功还是失败，都触发 cacheProvider 刷新
                      currentRef.invalidate(cacheProvider);
                    });

                // --- 立即显示对话框 ---
                showDialog(
                  context: currentContext,
                  barrierDismissible: false,
                  builder: (dialogContext) => PopScope(
                    canPop: false,
                    child: AlertDialog(
                      title: Row(
                        children: [
                          Consumer(
                            // 让转圈动画也监听状态
                            builder: (context, ref, child) {
                              final isRunning = ref.watch(
                                analysisIsRunningProvider,
                              );
                              return isRunning
                                  ? SizedBox(
                                      width: 24,
                                      height: 24,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 3,
                                      ),
                                    )
                                  : Icon(
                                      Icons.check_circle,
                                      color: Colors.green,
                                    ); // 完成时显示勾
                            },
                          ),
                          SizedBox(width: 16),
                          Text(currentL10n.analysis_log),
                        ],
                      ),
                      // --- 修改：使用不可编辑的 TextField ---
                      content: SizedBox(
                        width: double.maxFinite,
                        height: MediaQuery.of(currentContext).size.height * 0.7,
                        child: Consumer(
                          builder: (context, ref, child) {
                            final logs = ref.watch(analysisLogProvider);
                            final String logText = logs.join('\n');
                            // 使用 TextEditingController 来设置文本
                            final controller = TextEditingController(
                              text: logText,
                            );

                            return Container(
                              decoration: BoxDecoration(
                                color: currentTheme
                                    .colorScheme
                                    .surfaceContainerHighest,
                                borderRadius: BorderRadius.circular(8.0),
                              ),
                              child: SingleChildScrollView(
                                reverse: true, // 尝试自动滚动到底部
                                padding: const EdgeInsets.all(8.0),
                                child: TextField(
                                  controller: controller,
                                  readOnly: true,
                                  maxLines: null,
                                  decoration: InputDecoration.collapsed(
                                    hintText: null,
                                  ),
                                  style: TextStyle(
                                    fontSize: 10,
                                    fontFamily: 'monospace',
                                    color: currentTheme
                                        .colorScheme
                                        .onSurfaceVariant,
                                  ),
                                ),
                              ),
                            );
                          },
                        ),
                      ),
                      // --- 修改：根据状态显示/隐藏关闭按钮 ---
                      actions: [
                        Consumer(
                          builder: (context, ref, child) {
                            final isRunning = ref.watch(
                              analysisIsRunningProvider,
                            );
                            // 运行时隐藏按钮
                            if (isRunning) return const SizedBox.shrink();
                            // 运行结束后显示按钮
                            return TextButton(
                              child: Text(currentL10n.close),
                              onPressed: () => Navigator.pop(dialogContext),
                            );
                          },
                        ),
                      ],
                    ),
                  ),
                );
                // --- 移除 try/catch/finally 块 ---
                // (因为逻辑已经移入 Notifier 和 Dialog 状态)
              },
              label: Text(l10n.run),
              icon: const Icon(Icons.play_arrow),
            ),
    );
  }
}


### FILE: ./ui/main_scaffold.dart
import 'package:flutter/material.dart';
import 'home_page.dart';
import 'commits_page.dart';
import 'accounts_page.dart';
import 'settings_page.dart';
import '../l10n/app_localizations.dart';

class MainScaffold extends StatefulWidget {
  const MainScaffold({super.key});

  @override
  State<MainScaffold> createState() => _MainScaffoldState();
}

class _MainScaffoldState extends State<MainScaffold> {
  int _selectedIndex = 0;

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    final List<Widget> pages = <Widget>[
      HomePage(onNavigateToAccounts: () => _onItemTapped(2)),
      CommitsPage(),
      AccountsPage(),
      SettingsPage(),
    ];

    final List<Widget> pagesWithVisibility = <Widget>[
      pages[0], // HomePage
      Visibility(
        visible: _selectedIndex == 1,
        maintainState: false,
        child: pages[1], // CommitsPage
      ),
      pages[2], // AccountsPage
      pages[3], // SettingsPage
    ];

    return Scaffold(
      body: IndexedStack(index: _selectedIndex, children: pagesWithVisibility),
      bottomNavigationBar: NavigationBar(
        selectedIndex: _selectedIndex,
        onDestinationSelected: _onItemTapped,
        labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        destinations: <NavigationDestination>[
          NavigationDestination(
            icon: const Icon(Icons.home_outlined),
            selectedIcon: const Icon(Icons.home),
            label: l10n.home,
          ),
          NavigationDestination(
            icon: const Icon(Icons.folder_outlined),
            selectedIcon: const Icon(Icons.folder_open_outlined),
            label: l10n.data,
          ),
          NavigationDestination(
            icon: const Icon(Icons.people_alt_outlined),
            selectedIcon: const Icon(Icons.people_alt),
            label: l10n.accounts,
          ),
          NavigationDestination(
            icon: const Icon(Icons.settings_outlined),
            selectedIcon: const Icon(Icons.settings),
            label: l10n.settings,
          ),
        ],
      ),
    );
  }
}


### FILE: ./ui/settings_page.dart
import 'package:autonitor/models/app_settings.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/log_provider.dart';
import '../providers/settings_provider.dart';
import '../l10n/app_localizations.dart';
import 'package:flutter/services.dart';

class SettingsPage extends ConsumerStatefulWidget {
  const SettingsPage({super.key});

  @override
  ConsumerState<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends ConsumerState<SettingsPage> {
  late TextEditingController _historyLimitController;

  @override
  void initState() {
    super.initState();
    _historyLimitController = TextEditingController();
  }

  @override
  void dispose() {
    _historyLimitController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // 1. 获取 l10n (您可能需要导入 'l10n/app_localizations.dart')
    final l10n = AppLocalizations.of(context)!;

    // 2. 监听 settingsProvider
    final settingsValue = ref.watch(settingsProvider);

    // 3. 返回一个 Scaffold
    return Scaffold(
      // 4. 添加 AppBar
      appBar: AppBar(title: Text(l10n.settings)),
      // 5. body 是之前的 .when() 逻辑
      body: settingsValue.when(
        // 加载中状态：显示一个加载指示器
        loading: () => const Center(child: CircularProgressIndicator()),
        // 错误状态：显示错误信息
        error: (error, stackTrace) => Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text('加载设置失败: $error'),
          ),
        ),
        // 数据加载成功状态
        data: (settings) {
          // 构建设置列表 UI
          final currentTextInField = _historyLimitController.text;
          final settingsValue = settings.historyLimitN.toString();
          if (currentTextInField != settingsValue) {
            _historyLimitController.text = settingsValue;
            _historyLimitController.selection = TextSelection.fromPosition(
              TextPosition(offset: _historyLimitController.text.length),
            );
          }

          return ListView(
            children: [
              ListTile(
                title: Text(
                  l10n.general, // (From l10n)
                  style: TextStyle(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                dense: true,
              ),
              ListTile(
                title: Text(l10n.language),
                leading: const Icon(Icons.language),
                trailing: DropdownButton<String>(
                  alignment: Alignment.centerRight,
                  // 1. 当前选中的值：从 Provider 读取
                  value: settings.locale?.toLanguageTag() ?? 'Auto',

                  // 2. 下拉菜单的选项：创建一个包含所有可选语言的列表
                  items: const [
                    DropdownMenuItem<String>(
                      value: 'Auto',
                      child: Text('Auto'),
                    ),
                    DropdownMenuItem<String>(
                      value: 'en',
                      child: Text('English'),
                    ),
                    DropdownMenuItem<String>(
                      value: 'zh-CN',
                      child: Text('中文（中国）'),
                    ), // value 是 'zh-CN'
                    DropdownMenuItem<String>(
                      value: 'zh-TW',
                      child: Text('中文（台灣）'),
                    ), // value 是 'zh-TW'
                  ],

                  // 3. 当用户选择了新选项时的回调函数
                  onChanged: (String? newValue) {
                    if (newValue != null) {
                      Locale? newLocale; // 声明 newLocale
                      if (newValue == 'Auto') {
                        newLocale = null; // Auto 对应 null Locale
                      } else if (newValue == 'en') {
                        newLocale = const Locale('en');
                      } else if (newValue == 'zh-CN') {
                        newLocale = const Locale(
                          'zh',
                          'CN',
                        ); // 创建 Locale('zh', 'CN')
                      } else if (newValue == 'zh-TW') {
                        newLocale = const Locale('zh', 'TW');
                      }

                      // 调用 updateLocale 传入 Locale?
                      ref
                          .read(settingsProvider.notifier)
                          .updateLocale(newLocale);
                      // 更新提示文本（查找显示名称）
                      // Removed unused variable 'displaySelected'
                    }
                  },

                  // 4. (可选) 移除下拉按钮下划线，让它更简洁
                  underline: Container(),
                ),
                // 从加载的设置中获取语言并显示
              ),
              ListTile(
                leading: const Icon(Icons.brightness_6_outlined),
                title: Text(l10n.theme_mode),
                trailing: DropdownButton<ThemeMode>(
                  alignment: Alignment.centerRight,
                  value: settings.themeMode,
                  items: [
                    DropdownMenuItem(
                      value: ThemeMode.system,
                      child: Text(l10n.theme_mode_system),
                    ),
                    DropdownMenuItem(
                      value: ThemeMode.light,
                      child: Text(l10n.theme_mode_light),
                    ),
                    DropdownMenuItem(
                      value: ThemeMode.dark,
                      child: Text(l10n.theme_mode_dark),
                    ),
                  ],
                  onChanged: (ThemeMode? newValue) {
                    if (newValue != null) {
                      ref
                          .read(settingsProvider.notifier)
                          .updateThemeMode(newValue);
                    }
                  },
                  underline: Container(),
                ),
              ),
              const Divider(),
              ListTile(
                title: Text(
                  l10n.storage_settings, // (From l10n)
                  style: TextStyle(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                dense: true,
              ),
              SwitchListTile(
                secondary: const Icon(Icons.person_outline_outlined),
                title: Text(l10n.save_avatar_history),
                value: settings.saveAvatarHistory,
                onChanged: (bool newValue) {
                  ref
                      .read(settingsProvider.notifier)
                      .updateSaveAvatarHistory(newValue);
                },
              ),
              ListTile(
                enabled: settings.saveAvatarHistory,
                leading: const Icon(null),
                title: Text(l10n.avatar_quality),
                trailing: DropdownButton<AvatarQuality>(
                  value: settings.avatarQuality,
                  items: [
                    DropdownMenuItem(
                      value: AvatarQuality.high,
                      child: Text(l10n.quality_high),
                    ),
                    DropdownMenuItem(
                      value: AvatarQuality.low,
                      child: Text(l10n.quality_low),
                    ),
                  ],
                  onChanged: settings.saveAvatarHistory
                      ? (AvatarQuality? newValue) {
                          if (newValue != null) {
                            ref
                                .read(settingsProvider.notifier)
                                .updateAvatarQuality(newValue);
                          }
                        }
                      : null,
                ),
              ),
              SwitchListTile(
                secondary: const Icon(Icons.image_outlined),
                title: Text(l10n.save_banner_history),
                value: settings.saveBannerHistory,
                onChanged: (bool newValue) {
                  ref
                      .read(settingsProvider.notifier)
                      .updateSaveBannerHistory(newValue);
                },
              ),
              Padding(
                padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                child: Text(
                  l10n.history_strategy,
                  style: const TextStyle(fontSize: 12, color: Colors.grey),
                ),
              ),
              // (Radio button 1: Save All)
              // (单选按钮 1: 全部保存)
              RadioListTile<HistoryStrategy>(
                title: Text(l10n.strategy_save_all),
                value: HistoryStrategy.saveAll,
                groupValue:
                    settings.historyStrategy, // (The currently selected value)
                // (当前选中的值)
                onChanged: (HistoryStrategy? newValue) {
                  if (newValue != null) {
                    ref
                        .read(settingsProvider.notifier)
                        .updateHistoryStrategy(newValue);
                  }
                },
              ),

              // (Radio button 2: Save Latest)
              // (单选按钮 2: 仅保存最新)
              RadioListTile<HistoryStrategy>(
                title: Text(l10n.strategy_save_latest),
                value: HistoryStrategy.saveLatest,
                groupValue: settings.historyStrategy,
                onChanged: (HistoryStrategy? newValue) {
                  if (newValue != null) {
                    ref
                        .read(settingsProvider.notifier)
                        .updateHistoryStrategy(newValue);
                  }
                },
              ),

              // (Radio button 3: Save Last N)
              // (单选按钮 3: 保存 N 个)
              RadioListTile<HistoryStrategy>(
                value: HistoryStrategy.saveLastN,
                groupValue: settings.historyStrategy,
                onChanged: (HistoryStrategy? newValue) {
                  if (newValue != null) {
                    ref
                        .read(settingsProvider.notifier)
                        .updateHistoryStrategy(newValue);
                  }
                },

                // --- MODIFICATION: Title is now a complex Row ---
                // (修改：标题现在是一个复杂的 Row)
                title: Wrap(
                  // <--- This is the solution
                  // (Align items vertically in the middle, in case of wrapping)
                  // (如果换行，保持垂直居中)
                  crossAxisAlignment: WrapCrossAlignment.center,

                  // (Set horizontal spacing between elements)
                  // (设置元素之间的水平间距)
                  spacing: 2.0,

                  // (Set vertical spacing if it wraps to a new line)
                  // (如果换行，设置垂直间距)
                  runSpacing: 4.0,
                  children: [
                    // 1. The Prefix Text ("Save Last")
                    // (1. 前缀文本 ("保存最近"))
                    Text(
                      l10n.strategy_save_last_n,
                      // (This text never turns grey)
                      // (这个文本永远不会变灰)
                    ),

                    const SizedBox(width: 8), // (Spacing)
                    // 2. The Input Box
                    // (2. 输入框)
                    SizedBox(
                      width: 60, // (Adjust width)
                      child: TextFormField(
                        controller: _historyLimitController,
                        enabled:
                            settings.historyStrategy ==
                            HistoryStrategy.saveLastN,
                        keyboardType: TextInputType.number,
                        inputFormatters: [
                          FilteringTextInputFormatter.digitsOnly,
                        ],
                        textAlign: TextAlign.center,
                        decoration: const InputDecoration(
                          border: OutlineInputBorder(),
                          contentPadding: EdgeInsets.symmetric(
                            horizontal: 8.0,
                            vertical: 12.0,
                          ),
                          isDense: true, // (Makes it shorter)
                        ),

                        // (Save logic remains the same)
                        // (保存逻辑保持不变)
                        onEditingComplete: () {
                          final String value = _historyLimitController.text;
                          int n = int.tryParse(value) ?? 1;
                          if (n < 1) n = 1;
                          if (n > 500) n = 500;
                          ref
                              .read(settingsProvider.notifier)
                              .updateHistoryLimitN(n);
                          FocusScope.of(context).unfocus();
                        },
                        onTapOutside: (event) {
                          final String value = _historyLimitController.text;
                          int n = int.tryParse(value) ?? 1;
                          if (n < 1) n = 1;
                          if (n > 500) n = 500;
                          if (n != settings.historyLimitN) {
                            ref
                                .read(settingsProvider.notifier)
                                .updateHistoryLimitN(n);
                          }
                          FocusScope.of(context).unfocus();
                        },
                      ),
                    ),

                    const SizedBox(width: 6), // (Spacing)
                    // 3. The Suffix Text ("Changes")
                    // (3. 后缀文本 ("次更改"))
                    Text(l10n.strategy_save_last_n_suffix),
                  ],
                ),
              ),
              const Divider(),
              ListTile(
                title: Text(
                  l10n.log,
                  style: TextStyle(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                dense: true,
              ),
              ListTile(
                leading: const Icon(Icons.view_list_outlined),
                title: Text(l10n.view_log),
                onTap: () {
                  final logs = ref.read(logHistoryProvider);
                  final theme = Theme.of(context);
                  final logText = logs.join('\n'); // (Get the text once)

                  showDialog(
                    context: context,
                    builder: (dialogContext) => AlertDialog(
                      title: Text(l10n.view_log), // (You fixed this last time)
                      // --- (B) MODIFICATION: Use a read-only TextField ---
                      // (修改：使用只读的 TextField)
                      content: Container(
                        width: double.maxFinite,
                        constraints: BoxConstraints(
                          maxHeight: MediaQuery.of(context).size.height * 0.7,
                        ),
                        decoration: BoxDecoration(
                          color: theme.colorScheme.surfaceContainerHighest,
                          borderRadius: BorderRadius.circular(8.0),
                        ),
                        child: SingleChildScrollView(
                          reverse: true,
                          padding: const EdgeInsets.all(8.0),
                          child: TextField(
                            controller: TextEditingController(text: logText),
                            readOnly: true,
                            maxLines: null,
                            decoration: InputDecoration.collapsed(
                              hintText: null,
                            ),
                            style: TextStyle(
                              fontSize: 10,
                              fontFamily: 'monospace',
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ),
                      ),
                      // --- END (B) MODIFICATION ---

                      // --- (C) MODIFICATION: Add new buttons ---
                      // (修改：添加新按钮)
                      actions: [
                        TextButton(
                          child: Text(l10n.copy), // (Copy button)
                          onPressed: () {
                            Clipboard.setData(ClipboardData(text: logText));
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text(
                                  l10n.copied_to_clipboard,
                                  style: TextStyle(
                                    color: Theme.of(
                                      context,
                                    ).colorScheme.onPrimaryContainer,
                                  ),
                                ),
                                backgroundColor: Theme.of(
                                  context,
                                ).colorScheme.primaryContainer,
                              ),
                            );
                            Navigator.pop(dialogContext);
                          },
                        ),
                        TextButton(
                          child: Text(l10n.clear), // (Clear button)
                          onPressed: () {
                            ref
                                .read(logHistoryNotifierProvider.notifier)
                                .clearLog();
                            Navigator.pop(dialogContext);
                          },
                        ),
                        TextButton(
                          child: Text(l10n.close), // (Close button)
                          onPressed: () => Navigator.pop(dialogContext),
                        ),
                      ],
                      // --- END (C) MODIFICATION ---
                    ),
                  );
                },
              ),
              // 未来可以在这里添加其他设置项...
            ],
          );
        },
      ),
    );
  }
}


### FILE: ./ui/user_detail_page.dart
// [文件: lib/ui/user_detail_page.dart]

import 'dart:io';
import 'package:autonitor/providers/media_provider.dart'; // 确保这个 import 存在
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as p;

import 'package:autonitor/services/log_service.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../l10n/app_localizations.dart';
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../models/twitter_user.dart';
import 'dart:convert';
import 'package:flutter/services.dart';
import 'user_history_page.dart';

// 1. 确保它是 ConsumerWidget
class UserDetailPage extends ConsumerWidget {
  final TwitterUser user;
  final String ownerId;

  // --- 2. 添加新的可选历史参数 ---
  final bool isFromHistory;
  final String? snapshotJson;
  final int? snapshotId;
  final DateTime? snapshotTimestamp;
  // --- 修改结束 ---

  const UserDetailPage({
    super.key,
    required this.user,
    required this.ownerId,
    // --- 3. 更新构造函数 ---
    this.isFromHistory = false, // 默认为 false
    this.snapshotJson,
    this.snapshotId,
    this.snapshotTimestamp,
    // --- 修改结束 ---
  });

  @override
  // 4. 确保 build 方法有 WidgetRef ref
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    const double bannerAspectRatio = 1500 / 500;
    const double avatarOverhang = 40.0;
    logger.d('user.isProtected=${user.isProtected}');
    logger.d('user.isVerified=${user.isVerified}');

    // 5. 修复：这里的 provider 应该是 mediaDirectoryProvider
    //    (你之前的文件中这里是 appSupportDirProvider，我已为你修正)
    final mediaDirAsync = ref.watch(appSupportDirProvider);

    // --- (所有头像和横幅的路径拼接逻辑保持不变) ---
    // 头像逻辑
    final String? relativeAvatarPath = user.avatarLocalPath;
    final String? absoluteAvatarPath = (mediaDirAsync.hasValue &&
            relativeAvatarPath != null &&
            relativeAvatarPath.isNotEmpty)
        ? p.join(mediaDirAsync.value!, relativeAvatarPath)
        : null;

    final String? networkAvatarUrl = user.avatarUrl;
    bool isLocalHighQuality = false;
    if (absoluteAvatarPath != null && absoluteAvatarPath.contains('_high')) {
      isLocalHighQuality = true;
    }
    final String highQualityNetworkUrl = (networkAvatarUrl ?? '').replaceFirst(
      RegExp(r'_(normal|bigger|400x400)'),
      '_400x400',
    );
    bool fetchNetworkAvatar =
        !isLocalHighQuality && highQualityNetworkUrl.isNotEmpty;

    // 横幅逻辑
    final String? relativeBannerPath = user.bannerLocalPath;
    final String? absoluteBannerPath = (mediaDirAsync.hasValue &&
            relativeBannerPath != null &&
            relativeBannerPath.isNotEmpty)
        ? p.join(mediaDirAsync.value!, relativeBannerPath)
        : null;
    final String? networkBannerUrl = user.bannerUrl;
    // --- 逻辑结束 ---

    return Scaffold(
      appBar: AppBar(
        title: Text(user.name),
        actions: [
          // --- 6. 根据 isFromHistory 隐藏历史按钮 ---
          if (!isFromHistory)
            IconButton(
              icon: const Icon(Icons.history),
              tooltip: l10n.history,
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => UserHistoryPage(
                      user: user,
                      ownerId: ownerId, // 确保 ownerId 被传递
                    ),
                  ),
                );
              },
            ),
          // --- 修改结束 ---
        ],
      ),
      body: ListView(
        padding: EdgeInsets.zero,
        children: [
          Stack(
            // ... (横幅和头像的渲染逻辑... 均保持不变) ...
            clipBehavior: Clip.none,
            alignment: Alignment.topCenter,
            children: [
              AspectRatio(
                aspectRatio: bannerAspectRatio,
                child: (absoluteBannerPath != null)
                    ? Image.file(
                        File(absoluteBannerPath),
                        fit: BoxFit.cover,
                        errorBuilder: (context, error, stackTrace) {
                          return (networkBannerUrl ?? '').isNotEmpty
                              ? CachedNetworkImage(
                                  imageUrl: networkBannerUrl!,
                                  fit: BoxFit.cover,
                                  placeholder: (context, url) =>
                                      Container(color: Colors.grey.shade300),
                                  errorWidget: (context, url, error) =>
                                      Container(color: Colors.grey.shade300),
                                )
                              : Container(color: Colors.grey.shade300);
                        },
                      )
                    : (networkBannerUrl ?? '').isNotEmpty
                        ? CachedNetworkImage(
                            imageUrl: networkBannerUrl!,
                            fit: BoxFit.cover,
                            placeholder: (context, url) =>
                                Container(color: Colors.grey.shade300),
                            errorWidget: (context, url, error) =>
                                Container(color: Colors.grey.shade300),
                          )
                        : Container(color: Colors.grey.shade300),
              ),
              Positioned(
                left: 16,
                bottom: -avatarOverhang,
                child: Hero(
                  tag: 'avatar_${user.restId}',
                  child: CircleAvatar(
                    radius: 45,
                    backgroundColor: Colors.white,
                    child: CircleAvatar(
                      radius: 42,
                      backgroundColor:
                          Theme.of(context).colorScheme.surfaceContainerHighest,
                      child: ClipOval(
                        child: Stack(
                          fit: StackFit.expand,
                          children: [
                            Icon(
                              Icons.person,
                              size: 40,
                              color: Theme.of(context)
                                  .colorScheme
                                  .onSurfaceVariant
                                  .withOpacity(0.5),
                            ),
                            if (absoluteAvatarPath != null)
                              Image.file(
                                File(absoluteAvatarPath),
                                fit: BoxFit.cover,
                                width: 84,
                                height: 84,
                                frameBuilder:
                                    (context, child, frame, wasSync) {
                                  if (wasSync) return child;
                                  return AnimatedOpacity(
                                    opacity: frame == null ? 0 : 1,
                                    duration: const Duration(milliseconds: 200),
                                    child: child,
                                  );
                                },
                                errorBuilder: (context, e, s) =>
                                    const SizedBox.shrink(),
                              ),
                            if (fetchNetworkAvatar)
                              CachedNetworkImage(
                                imageUrl: highQualityNetworkUrl,
                                fit: BoxFit.cover,
                                width: 84,
                                height: 84,
                                fadeInDuration:
                                    const Duration(milliseconds: 300),
                                placeholder: (context, url) =>
                                    const SizedBox.shrink(),
                                errorWidget: (context, url, error) =>
                                    const SizedBox.shrink(),
                              ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          Padding(
            padding: const EdgeInsets.only(right: 16.0, top: 8.0),
            child: Align(
              alignment: Alignment.centerRight,
              child: FilledButton.tonalIcon(
                onPressed: () {
                  // --- 7. 修改 JSON 按钮逻辑 ---
                  // 优先使用快照 JSON，如果 (isFromHistory == false)，则回退到 user.latestRawJson
                  final rawJson = snapshotJson ?? user.latestRawJson;
                  // --- 修改结束 ---
                  
                  if (rawJson != null && rawJson.isNotEmpty) {
                    // ... (所有 jsonDecode 和 showDialog 逻辑保持不变) ...
                    String formattedJson = rawJson;
                    try {
                      final dynamic jsonObj = jsonDecode(rawJson);
                      const encoder = JsonEncoder.withIndent('  ');
                      formattedJson = encoder.convert(jsonObj);
                    } catch (e, s) {
                      logger.e(
                        "Error formatting JSON for display: $e",
                        error: e,
                        stackTrace: s,
                      );
                    }
                    showDialog(
                      context: context,
                      builder: (dialogContext) => AlertDialog(
                        title: const Text('JSON'),
                        content: Container(
                          width: double.maxFinite,
                          constraints: BoxConstraints(
                            maxHeight: MediaQuery.of(context).size.height * 0.6,
                          ),
                          decoration: BoxDecoration(
                            color: Theme.of(context)
                                .colorScheme
                                .surfaceContainerHighest,
                            borderRadius: BorderRadius.circular(8.0),
                          ),
                          child: SingleChildScrollView(
                            padding: const EdgeInsets.all(8.0),
                            child: TextField(
                              controller:
                                  TextEditingController(text: formattedJson),
                              readOnly: true,
                              maxLines: null,
                              decoration:
                                  const InputDecoration.collapsed(hintText: null),
                              style: TextStyle(
                                fontFamily: 'monospace',
                                fontSize: 12,
                                color: Theme.of(context)
                                    .colorScheme
                                    .onSurfaceVariant,
                              ),
                            ),
                          ),
                        ),
                        actions: <Widget>[
                          TextButton(
                            child: Text(l10n.copy),
                            onPressed: () {
                              Clipboard.setData(
                                ClipboardData(text: formattedJson),
                              );
                              Navigator.pop(dialogContext);
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(
                                    l10n.copied_to_clipboard,
                                    style: TextStyle(
                                      color: Theme.of(context)
                                          .colorScheme
                                          .onPrimaryContainer,
                                    ),
                                  ),
                                  backgroundColor: Theme.of(context)
                                      .colorScheme
                                      .primaryContainer,
                                ),
                              );
                            },
                          ),
                          ElevatedButton(
                            child: Text(l10n.ok),
                            onPressed: () {
                              Navigator.pop(dialogContext);
                            },
                          ),
                        ],
                      ),
                    );
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text(l10n.no_json_data_available)),
                    );
                  }
                },
                style: FilledButton.styleFrom(
                  backgroundColor: Colors.pink.shade100,
                  foregroundColor: Colors.pink.shade800,
                  padding:
                      const EdgeInsets.symmetric(horizontal: 18, vertical: 8),
                ),
                icon: const Icon(Icons.description_outlined, size: 20),
                label: const Text('JSON'),
              ),
            ),
          ),
          
          // ... (所有显示用户 bio, location, link, followers... 的代码保持不变) ...
          
          const SizedBox(height: 5),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.baseline,
              textBaseline: TextBaseline.alphabetic,
              children: [
                SelectableText.rich(
                  TextSpan(
                    style: Theme.of(context)
                        .textTheme
                        .headlineSmall
                        ?.copyWith(fontWeight: FontWeight.bold),
                    children: [
                      TextSpan(text: user.name),
                      if (user.isVerified)
                        WidgetSpan(
                          child: Padding(
                            padding:
                                const EdgeInsets.symmetric(horizontal: 4.0),
                            child: SvgPicture.asset(
                              'assets/icon/verified.svg',
                              width: 23,
                              height: 23,
                              colorFilter: const ColorFilter.mode(
                                Color(0xFF1DA1F2),
                                BlendMode.srcIn,
                              ),
                            ),
                          ),
                          alignment: PlaceholderAlignment.middle,
                        ),
                      if (user.isProtected)
                        WidgetSpan(
                          child: Padding(
                            padding: EdgeInsets.only(
                              left: user.isVerified ? 0.0 : 4.0,
                              right: 4.0,
                            ),
                            child: SvgPicture.asset(
                              'assets/icon/protected.svg',
                              width: 20,
                              height: 20,
                              colorFilter: ColorFilter.mode(
                                Theme.of(context).colorScheme.onSurface,
                                BlendMode.srcIn,
                              ),
                            ),
                          ),
                          alignment: PlaceholderAlignment.middle,
                        ),
                    ],
                  ),
                ),
                Row(
                  children: [
                    Flexible(
                      child: Text.rich(
                        TextSpan(
                          children: [
                            TextSpan(
                              text: '@',
                              style: Theme.of(context)
                                  .textTheme
                                  .bodyLarge
                                  ?.copyWith(color: Colors.grey.shade600),
                            ),
                            WidgetSpan(
                              alignment: PlaceholderAlignment.baseline,
                              baseline: TextBaseline.alphabetic,
                              child: SelectableText(
                                user.id,
                                style: Theme.of(context)
                                    .textTheme
                                    .bodyLarge
                                    ?.copyWith(color: Colors.grey.shade600),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(width: 4),
                  ],
                ),
                const SizedBox(height: 4),
                SelectableText(
                  user.bio ?? '',
                  style: Theme.of(context).textTheme.bodyLarge,
                ),
              ],
            ),
          ),
          const SizedBox(height: 5),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Wrap(
              spacing: 16.0,
              runSpacing: 4.0,
              children: [
                if (user.location != null && user.location!.isNotEmpty)
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(Icons.location_on_outlined,
                          color: Colors.grey, size: 16),
                      const SizedBox(width: 4),
                      Flexible(
                        child: SelectableText(
                          user.location ?? '',
                          style: const TextStyle(color: Colors.grey),
                        ),
                      ),
                    ],
                  ),
                if (user.link != null && user.link!.isNotEmpty)
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(Icons.link, color: Colors.grey, size: 16),
                      const SizedBox(width: 4),
                      Flexible(
                        child: InkWell(
                          onTap: () => _launchURL(context, user.link),
                          child: Text(
                            user.link ?? '',
                            style: const TextStyle(
                              color: Colors.blue,
                              decoration: TextDecoration.underline,
                              decorationColor: Colors.blue,
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Icon(Icons.calendar_month_outlined,
                        color: Colors.grey, size: 16),
                    const SizedBox(width: 4),
                    Flexible(
                      child: Text(
                        '${l10n.joined} ${user.joinTime}',
                        style: const TextStyle(color: Colors.grey),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            child: Wrap(
              spacing: 16.0,
              runSpacing: 4.0,
              children: [
                Text.rich(
                  TextSpan(
                    text: user.followingCount.toString(),
                    style: const TextStyle(fontWeight: FontWeight.bold),
                    children: [
                      TextSpan(
                        text: ' ${l10n.following}',
                        style: const TextStyle(
                            fontWeight: FontWeight.normal, color: Colors.grey),
                      ),
                    ],
                  ),
                ),
                Text.rich(
                  TextSpan(
                    text: user.followersCount.toString(),
                    style: const TextStyle(fontWeight: FontWeight.bold),
                    children: [
                      TextSpan(
                        text: ' ${l10n.followers}',
                        style: const TextStyle(
                            fontWeight: FontWeight.normal, color: Colors.grey),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 8, 16, 4),
            child: Text(
              l10n.view_on_twitter,
              style: const TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Icon(Icons.link,
                          color: Theme.of(context).colorScheme.primary,
                          size: 16),
                      const SizedBox(width: 6),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Text('ByScreenName',
                                style: TextStyle(fontSize: 12)),
                            const SizedBox(height: 4),
                            InkWell(
                              onTap: () => _launchURL(
                                  context, 'https://x.com/${user.id}'),
                              child: Text(
                                'https://x.com/${user.id}',
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                                style: const TextStyle(
                                  color: Colors.blue,
                                  decoration: TextDecoration.underline,
                                  decorationColor: Colors.blue,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Icon(Icons.link,
                          color: Theme.of(context).colorScheme.primary,
                          size: 16),
                      const SizedBox(width: 6),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Text('ByRestId',
                                style: TextStyle(fontSize: 12)),
                            const SizedBox(height: 4),
                            InkWell(
                              onTap: () => _launchURL(
                                  context,
                                  'https://x.com/intent/user?user_id=${user.restId}'),
                              child: Text(
                                'https://x.com/intent/user?user_id=${user.restId}',
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                                style: const TextStyle(
                                  color: Colors.blue,
                                  decoration: TextDecoration.underline,
                                  decorationColor: Colors.blue,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 4, 1, 0),
            child: Text(
              l10n.metadata,
              style: const TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ),
          _buildInfoTile(
            context,
            Icons.create,
            l10n.tweets,
            user.statusesCount.toString(),
          ),
          _buildInfoTile(
            context,
            Icons.image,
            l10n.media_count,
            user.mediaCount.toString(),
          ),
          _buildInfoTile(
            context,
            Icons.favorite,
            l10n.likes,
            user.favouritesCount.toString(),
          ),
          _buildInfoTile(
            context,
            Icons.list_alt,
            l10n.listed_count,
            user.listedCount.toString(),
          ),
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 4, 1, 0),
            child: Text(
              l10n.identity,
              style: const TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ),
          _buildInfoTile(context, Icons.fingerprint, "Rest ID", user.restId),
          
          // --- 8. 添加快照 ID 和时间戳 ---
          if (isFromHistory && snapshotId != null && snapshotTimestamp != null)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 24, horizontal: 16),
              child: Text(
                "Snapshot ID: $snapshotId\nTimestamp: ${snapshotTimestamp!.toLocal()}",
                textAlign: TextAlign.center,
                style: Theme.of(context)
                    .textTheme
                    .bodySmall
                    ?.copyWith(color: Colors.grey.shade600),
              ),
            ),
          // --- 修改结束 ---
        ],
      ),
    );
  }

  void _launchURL(BuildContext context, String? urlString) async {
    // ... (此辅助方法保持不变) ...
    if (urlString == null || urlString.isEmpty) {
      return;
    }
    final Uri? uri = Uri.tryParse(urlString);
    if (uri == null) {
      if (context.mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('无法打开链接: 格式错误')));
      }
      return;
    }
    try {
      await launchUrl(uri, mode: LaunchMode.platformDefault);
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('无法打开链接: $e')));
      }
    }
  }

  Widget _buildInfoTile(
    BuildContext context,
    IconData icon,
    String title,
    String subtitle, {
    bool isUrl = false,
  }) {
    // ... (此辅助方法保持不变) ...
    return ListTile(
      leading: Icon(icon, color: Theme.of(context).colorScheme.primary),
      title: Text(title),
      subtitle: SelectableText(
        subtitle,
        style: TextStyle(color: isUrl ? Colors.blue : null),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16.0),
    );
  }
}

### FILE: ./ui/user_history_page.dart
// [文件: lib/ui/user_history_page.dart]

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:autonitor/providers/media_provider.dart';
import 'package:autonitor/models/history_snapshot.dart'; // <-- 1. 修复：现在这个 import 会被使用了
import 'package:autonitor/providers/history_provider.dart';
import 'package:autonitor/ui/user_detail_page.dart';
import '../models/twitter_user.dart';
import '../l10n/app_localizations.dart';

class UserHistoryPage extends ConsumerWidget {
  final TwitterUser user;
  final String ownerId;

  const UserHistoryPage({
    super.key,
    required this.user,
    required this.ownerId,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final userId = user.restId; // <-- 2. 修复：使用 restId 更准确

    // 3. Watch 我们的新 Provider
    final params = ProfileHistoryParams(ownerId: ownerId, userId: userId);
    final historyAsync = ref.watch(profileHistoryProvider(params));

    // 4. Watch 媒体路径 Provider (用于渲染头像)
    final mediaDirAsync = ref.watch(appSupportDirProvider);

    return Scaffold(
      appBar: AppBar(
        title: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(l10n.user_history_page_title),
            const SizedBox(height: 2),
            Text(
              '@${user.id}', // <-- 这里显示 @handle 没问题
              style: Theme.of(context)
                  .textTheme
                  .titleSmall
                  ?.copyWith(color: Colors.grey.shade600),
            ),
          ],
        ),
      ),
      // 5. 使用 .when() 处理加载状态
      body: historyAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (err, stack) => Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            // 显示你截图中的错误
            child: Text('${l10n.failed_to_load_user_list}:\n$err'),
          ),
        ),
        data: (snapshots) {
          // 6. 处理空列表
          if (snapshots.isEmpty) {
            return Center(child: Text(l10n.no_users_in_this_category));
          }

          // 7. 构建列表
          return ListView.builder(
            itemCount: snapshots.length,
            itemBuilder: (context, index) {
              final snapshot = snapshots[index];
              final snapshotUser = snapshot.user; // 重建的 user 对象

              // --- 8. 复制 user_list_page 的头像渲染逻辑 ---
              final String? relativeLocalPath = snapshotUser.avatarLocalPath;
              final String? absoluteLocalPath = (mediaDirAsync.hasValue &&
                      relativeLocalPath != null &&
                      relativeLocalPath.isNotEmpty)
                  ? p.join(mediaDirAsync.value!, relativeLocalPath)
                  : null;

              final String? networkAvatarUrl = snapshotUser.avatarUrl;
              bool isLocalHighQuality = false;
              if (absoluteLocalPath != null &&
                  absoluteLocalPath.contains('_high')) {
                isLocalHighQuality = true;
              }
              final String highQualityNetworkUrl =
                  (networkAvatarUrl ?? '').replaceFirst(
                RegExp(r'_(normal|bigger|400x400)'),
                '_400x400',
              );
              bool fetchNetworkLayer =
                  !isLocalHighQuality && highQualityNetworkUrl.isNotEmpty;
              // --- 头像逻辑结束 ---

              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // 9. 添加你要求的 "设置页" 风格的 Header
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 16, 16, 4),
                    child: Text(
                      // 格式化时间
                      "ID: ${snapshot.entry.id}  (${snapshot.entry.timestamp.toLocal().toString().substring(0, 16)})",
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.primary,
                        fontWeight: FontWeight.bold,
                        fontSize: 12,
                      ),
                    ),
                  ),

                  // 10. 添加 "user_list_page" 风格的 ListTile
                  ListTile(
                    leading: Hero(
                      // 注意：Tag 必须是唯一的，我们用 snapshot ID 附加
                      tag: 'avatar_${snapshotUser.restId}_${snapshot.entry.id}',
                      child: CircleAvatar(
                        radius: 24,
                        backgroundColor: Colors.transparent,
                        child: Stack(
                          alignment: Alignment.center,
                          children: [
                            const Icon(Icons.person, size: 24),
                            if (absoluteLocalPath != null)
                              ClipOval(
                                child: Image.file(
                                  File(absoluteLocalPath),
                                  fit: BoxFit.cover,
                                  width: 48,
                                  height: 48,
                                  frameBuilder:
                                      (context, child, frame, wasSync) {
                                    if (wasSync) return child;
                                    return AnimatedOpacity(
                                      opacity: frame == null ? 0 : 1,
                                      duration:
                                          const Duration(milliseconds: 200),
                                      child: child,
                                    );
                                  },
                                  errorBuilder: (context, e, s) =>
                                      const SizedBox.shrink(),
                                ),
                              ),
                            if (fetchNetworkLayer)
                              ClipOval(
                                child: CachedNetworkImage(
                                  imageUrl: highQualityNetworkUrl,
                                  fit: BoxFit.cover,
                                  width: 48,
                                  height: 48,
                                  fadeInDuration:
                                      const Duration(milliseconds: 300),
                                  placeholder: (context, url) =>
                                      const SizedBox.shrink(),
                                  errorWidget: (context, url, error) =>
                                      const SizedBox.shrink(),
                                ),
                              ),
                          ],
                        ),
                      ),
                    ),
                    title: Row(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Flexible(
                          child: Text(
                            snapshotUser.name,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        if (snapshotUser.isVerified)
                          Padding(
                            padding: const EdgeInsets.only(left: 4.0),
                            child: SvgPicture.asset(
                              'assets/icon/verified.svg',
                              width: 18,
                              height: 18,
                              colorFilter: const ColorFilter.mode(
                                  Color(0xFF1DA1F2), BlendMode.srcIn),
                            ),
                          ),
                        if (snapshotUser.isProtected)
                          Padding(
                            padding: const EdgeInsets.only(left: 4.0),
                            child: SvgPicture.asset(
                              'assets/icon/protected.svg',
                              width: 18,
                              height: 18,
                              colorFilter: ColorFilter.mode(
                                Theme.of(context).colorScheme.onSurface,
                                BlendMode.srcIn,
                              ),
                            ),
                          ),
                      ],
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          "@${snapshotUser.id}",
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                        Text(
                          snapshotUser.bio ?? '',
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                          style: Theme.of(context).textTheme.bodyMedium,
                        ),
                      ],
                    ),
                    onTap: () {
                      // 11. 导航到详情页，并传递所有历史数据
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (_) => UserDetailPage(
                            user: snapshotUser, // 传入重建的 user
                            ownerId: ownerId,
                            isFromHistory: true, // 标记为来自历史
                            snapshotJson: snapshot.fullJson, // 传入重建的 JSON
                            snapshotId: snapshot.entry.id, // 传入快照 ID
                            snapshotTimestamp: snapshot.entry.timestamp, // 传入时间
                          ),
                        ),
                      );
                    },
                  ),
                ],
              );
            },
          );
        },
      ),
    );
  }
}

### FILE: ./ui/user_list_page.dart
// [文件: lib/ui/user_list_page.dart]

import 'dart:io';
import 'package:autonitor/services/log_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:autonitor/ui/user_detail_page.dart'; // <--- 这个文件只导入 UserDetailPage
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:path/path.dart' as p;
import '../l10n/app_localizations.dart';
import '../providers/report_providers.dart';
import 'package:autonitor/providers/media_provider.dart';

class UserListPage extends ConsumerStatefulWidget { // <--- 它应该定义 UserListPage
  final String ownerId;
  final String categoryKey;

  const UserListPage({
    super.key,
    required this.ownerId,
    required this.categoryKey,
  });

  @override
  ConsumerState<UserListPage> createState() => _UserListPageState();
}

class _UserListPageState extends ConsumerState<UserListPage> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      final param = UserListParam(
        ownerId: widget.ownerId,
        categoryKey: widget.categoryKey,
      );
      ref.read(userListProvider(param).notifier).fetchMore();
    }
  }

  String getLocalizedTitle(AppLocalizations l10n) {
    switch (widget.categoryKey) {
      case 'followers':
        return l10n.followers;
      case 'following':
        return l10n.following;
      case 'normal_unfollowed':
        return l10n.normal_unfollowed;
      case 'mutual_unfollowed':
        return l10n.mutual_unfollowed;
      case 'oneway_unfollowed':
        return l10n.oneway_unfollowed;
      case 'temporarily_restricted':
        return l10n.temporarily_restricted;
      case 'suspended':
        return l10n.suspended;
      case 'deactivated':
        return l10n.deactivated;
      case 'be_followed_back':
        return l10n.be_followed_back;
      case 'new_followers_following':
        return l10n.new_followers_following;
      default:
        return widget.categoryKey;
    }
  }

  Widget _buildSuspendedBanner(BuildContext context) {
    if (widget.categoryKey == 'suspended') {
      return AspectRatio(
        aspectRatio: 1500 / 500,
        child: Image.asset('assets/suspended_banner.png', fit: BoxFit.cover),
      );
    }
    return const SizedBox.shrink();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final param = UserListParam(
      ownerId: widget.ownerId,
      categoryKey: widget.categoryKey,
    );
    final userListAsync = ref.watch(userListProvider(param));
    final mediaDirAsync = ref.watch(appSupportDirProvider);

    return Scaffold(
      appBar: AppBar(title: Text(getLocalizedTitle(l10n))),
      body: Column(
        children: [
          _buildSuspendedBanner(context),
          Expanded(
            child: userListAsync.when(
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (err, stack) =>
                  Center(child: Text('${l10n.failed_to_load_user_list}: $err')),
              data: (users) {
                if (users.isEmpty) {
                  return Center(child: Text(l10n.no_users_in_this_category));
                }

                final bool hasMore = ref
                    .read(userListProvider(param).notifier)
                    .hasMore();
                final int itemCount = users.length + (hasMore ? 1 : 0);

                return ListView.builder(
                  controller: _scrollController,
                  itemCount: itemCount,
                  itemBuilder: (context, index) {
                    if (index == users.length) {
                      return const Center(
                        child: Padding(
                          padding: EdgeInsets.all(16.0),
                          child: SizedBox(
                            width: 24,
                            height: 24,
                            child: CircularProgressIndicator(strokeWidth: 3),
                          ),
                        ),
                      );
                    }

                    final user = users[index];
                    // --- (这是你已经实现的三层渲染逻辑) ---
                    final String? relativeLocalPath = user.avatarLocalPath;
                    final String? absoluteLocalPath =
                        (mediaDirAsync.hasValue &&
                            relativeLocalPath != null &&
                            relativeLocalPath.isNotEmpty)
                        ? p.join(mediaDirAsync.value!, relativeLocalPath)
                        : null;
                    logger.d(absoluteLocalPath);

                    bool isLocalHighQuality = false;
                    if (absoluteLocalPath != null &&
                        absoluteLocalPath.contains('_high')) {
                      isLocalHighQuality = true;
                    }

                    final String highQualityNetworkUrl =
                        (user.avatarUrl).replaceFirst(
                          RegExp(r'_(normal|bigger|400x400)'),
                          '_400x400',
                        );

                    bool fetchNetworkLayer =
                        !isLocalHighQuality && highQualityNetworkUrl.isNotEmpty;
                    // --- (逻辑结束) ---
                        
                    return ListTile(
                      leading: Hero(
                        tag: 'avatar_${user.restId}',
                        child: CircleAvatar(
                          radius: 24,
                          backgroundColor: Colors.transparent,
                          child: Stack(
                            alignment: Alignment.center,
                            children: [
                              // Layer 1: Base Icon
                              const Icon(Icons.person, size: 24),

                              // Layer 2: Local File
                              if (absoluteLocalPath != null)
                                ClipOval(
                                  child: Image.file(
                                    File(absoluteLocalPath),
                                    fit: BoxFit.cover,
                                    width: 48,
                                    height: 48,
                                    frameBuilder:
                                        (context, child, frame, wasSync) {
                                      if (wasSync) return child;
                                      return AnimatedOpacity(
                                        opacity: frame == null ? 0 : 1,
                                        duration: const Duration(
                                          milliseconds: 200, // (修正了毫秒)
                                        ),
                                        child: child,
                                      );
                                    },
                                    errorBuilder: (context, e, s) =>
                                        const SizedBox.shrink(),
                                  ),
                                ),

                              // Layer 3: Network File (High Quality)
                              if (fetchNetworkLayer)
                                ClipOval(
                                  child: CachedNetworkImage(
                                    imageUrl: highQualityNetworkUrl,
                                    fit: BoxFit.cover,
                                    width: 48,
                                    height: 48,
                                    fadeInDuration: const Duration(
                                      milliseconds: 300,
                                    ),
                                    placeholder: (context, url) =>
                                        const SizedBox.shrink(),
                                    errorWidget: (context, url, error) =>
                                        const SizedBox.shrink(),
                                  ),
                                ),
                            ],
                          ),
                        ),
                      ),
                      title: Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Flexible(
                            child: Text(
                              user.name,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          if (user.isVerified)
                            SvgPicture.asset(
                              'assets/icon/verified.svg',
                              width: 18,
                              height: 18,
                              colorFilter: const ColorFilter.mode(
                                Color(0xFF1DA1F2),
                                BlendMode.srcIn,
                              ),
                            ),
                          if (user.isProtected)
                            SvgPicture.asset(
                              'assets/icon/protected.svg',
                              width: 18,
                              height: 18,
                              colorFilter: ColorFilter.mode(
                                Theme.of(
                                  context,
                                ).colorScheme.onSurface,
                                BlendMode.srcIn,
                              ),
                            ),
                        ],
                      ),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "@${user.id}",
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                          Text(
                            user.bio ?? '',
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                            style: Theme.of(context).textTheme.bodyMedium,
                          ),
                        ],
                      ),
                      onTap: () {
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                            builder: (_) => UserDetailPage(
                              user: user,
                              ownerId: widget.ownerId, // <-- 你已经传递了 ownerId，很好！
                            ),
                          ),
                        );
                      },
                    );
                  },
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

### FILE: ./utils/diff_utils.dart
import 'dart:convert';

import 'package:autonitor/services/log_service.dart';

/// 特殊标记，用于表示一个键在新 JSON 中存在但在旧 JSON 中不存在，
/// 因此在反向补丁中需要被删除。
const _keyToBeRemovedMarker = '__KEY_TO_BE_REMOVED__';

/// 计算两个 JSON 字符串之间的反向差异。
/// 返回一个 JSON 字符串，表示从 newJsonString 变回 oldJsonString 所需的补丁。
/// 如果没有差异，则返回 null。
String? calculateReverseDiff(String? newJsonString, String? oldJsonString) {
  if (oldJsonString == null || oldJsonString.isEmpty) {
    // 如果没有旧版本，则无法计算差异
    return null;
  }
  if (newJsonString == null || newJsonString.isEmpty) {
    // 如果新版本为空，则反向补丁就是旧版本本身（理论上不应发生）
    return oldJsonString;
  }

  try {
    final newJson = jsonDecode(newJsonString);
    final oldJson = jsonDecode(oldJsonString);

    if (newJson is! Map<String, dynamic> || oldJson is! Map<String, dynamic>) {
      // 只处理 Map 类型的 JSON 对象
      if (newJsonString != oldJsonString) {
        // 如果顶层不是 Map 且内容不同，返回整个旧 JSON 作为补丁
        return oldJsonString;
      }
      return null; // 内容相同
    }

    final diff = _compareMaps(newJson, oldJson);

    if (diff.isEmpty) {
      return null; // 没有差异
    }

    return jsonEncode(diff);
  } catch (e, s) {
    logger.e("Error calculating JSON diff: $e", error: e, stackTrace: s);
    // 发生错误时，保守起见不生成补丁
    return null;
  }
}

/// 递归比较两个 Map 并生成反向差异。
Map<String, dynamic> _compareMaps(
  Map<String, dynamic> newMap,
  Map<String, dynamic> oldMap,
) {
  final diff = <String, dynamic>{};
  final allKeys = {...newMap.keys, ...oldMap.keys}; // 获取所有键的并集

  for (final key in allKeys) {
    final newValue = newMap[key];
    final oldValue = oldMap[key];

    if (oldMap.containsKey(key) && !newMap.containsKey(key)) {
      // 键只在旧 Map 中存在 (在新 Map 中被删除) -> 反向补丁记录旧值
      diff[key] = oldValue;
    } else if (newMap.containsKey(key) && !oldMap.containsKey(key)) {
      // 键只在新 Map 中存在 (是新增的) -> 反向补丁记录删除标记
      diff[key] = _keyToBeRemovedMarker;
    } else if (newMap.containsKey(key) && oldMap.containsKey(key)) {
      // 键在两者中都存在
      if (newValue is Map<String, dynamic> &&
          oldValue is Map<String, dynamic>) {
        // 如果值都是 Map，递归比较
        final nestedDiff = _compareMaps(newValue, oldValue);
        if (nestedDiff.isNotEmpty) {
          diff[key] = nestedDiff;
        }
      } else if (!_areEqual(newValue, oldValue)) {
        // 如果值不同 (且不是 Map)，反向补丁记录旧值
        diff[key] = oldValue;
      }
      // 如果值相同，则忽略，不加入 diff
    }
  }

  return diff;
}

/// 比较两个值是否相等 (考虑 List 和 Map 的深比较)
bool _areEqual(dynamic a, dynamic b) {
  if (a is Map && b is Map) {
    if (a.length != b.length) return false;
    for (final key in a.keys) {
      if (!b.containsKey(key) || !_areEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  } else if (a is List && b is List) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (!_areEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  return a == b;
}

/// 应用反向补丁到新的 JSON Map，以重建旧的 JSON Map。
Map<String, dynamic>? applyReversePatch(
  Map<String, dynamic>? newJson,
  String? patchString,
) {
  if (newJson == null) return null; // 无法在 null 上应用补丁
  if (patchString == null || patchString.isEmpty) return newJson; // 没有补丁，返回原样

  try {
    final patch = jsonDecode(patchString);
    if (patch is! Map<String, dynamic>) {
      // 如果补丁不是 Map，无法应用（理论上 calculateReverseDiff 不会生成这样的补丁）
      logger.e("Error applying patch: Patch is not a Map.");
      return newJson;
    }

    // 创建一个新 Map 来存储结果，避免直接修改 newJson
    final reconstructedJson = Map<String, dynamic>.from(newJson);
    _applyPatchRecursive(reconstructedJson, patch);
    return reconstructedJson;
  } catch (e, s) {
    logger.e("Error applying JSON patch: $e", error: e, stackTrace: s);
    // 发生错误时，返回原始 newJson
    return newJson;
  }
}

void _applyPatchRecursive(
  Map<String, dynamic> target,
  Map<String, dynamic> patch,
) {
  patch.forEach((key, patchValue) {
    if (patchValue == _keyToBeRemovedMarker) {
      // 如果补丁值是删除标记，则从目标中移除该键
      target.remove(key);
    } else if (patchValue is Map<String, dynamic> &&
        target[key] is Map<String, dynamic>) {
      // 如果补丁值和目标值都是 Map，递归应用补丁
      // 需要确保 target[key] 不是 null
      final targetValueMap = target[key] as Map<String, dynamic>?;
      if (targetValueMap != null) {
        _applyPatchRecursive(targetValueMap, patchValue);
      } else {
        // 如果目标值本来是 null 或不是 Map，则直接用补丁值覆盖（虽然理论上这不应发生）
        target[key] = patchValue;
      }
    } else {
      // 否则，直接用补丁值覆盖目标值（添加或修改）
      target[key] = patchValue;
    }
  });
}


